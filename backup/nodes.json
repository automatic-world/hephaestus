[{"_key":"LICENSE","_id":"nodes/LICENSE","_rev":"_jzRp_hO---","type":"file","name":"LICENSE","path":"C:\\workspace\\langchain-neo4j\\LICENSE"},{"_key":"Makefile","_id":"nodes/Makefile","_rev":"_jzRp_hq---","type":"file","name":"Makefile","path":"C:\\workspace\\langchain-neo4j\\Makefile"},{"_key":"README_md","_id":"nodes/README_md","_rev":"_jzRp_i2---","type":"file","name":"README.md","path":"C:\\workspace\\langchain-neo4j\\README.md"},{"_key":"_gitignore","_id":"nodes/_gitignore","_rev":"_jzRp_gy---","type":"file","name":".gitignore","path":"C:\\workspace\\langchain-neo4j\\.gitignore"},{"_key":"_idea","_id":"nodes/_idea","_rev":"_jzRp_jO---","type":"directory","name":".idea","path":"C:\\workspace\\langchain-neo4j\\.idea"},{"_key":"_idea__gitignore","_id":"nodes/_idea__gitignore","_rev":"_jzRp_jm---","type":"file","name":".gitignore","path":"C:\\workspace\\langchain-neo4j\\.idea\\.gitignore"},{"_key":"_idea_langchain-neo4j_iml","_id":"nodes/_idea_langchain-neo4j_iml","_rev":"_jzRp_k----","type":"file","name":"langchain-neo4j.iml","path":"C:\\workspace\\langchain-neo4j\\.idea\\langchain-neo4j.iml"},{"_key":"_idea_misc_xml","_id":"nodes/_idea_misc_xml","_rev":"_jzRp_kS---","type":"file","name":"misc.xml","path":"C:\\workspace\\langchain-neo4j\\.idea\\misc.xml"},{"_key":"_idea_modules_xml","_id":"nodes/_idea_modules_xml","_rev":"_jzRp_kq---","type":"file","name":"modules.xml","path":"C:\\workspace\\langchain-neo4j\\.idea\\modules.xml"},{"_key":"_idea_workspace_xml","_id":"nodes/_idea_workspace_xml","_rev":"_jzRp_lC---","type":"file","name":"workspace.xml","path":"C:\\workspace\\langchain-neo4j\\.idea\\workspace.xml"},{"_key":"langchain-neo4j","_id":"nodes/langchain-neo4j","_rev":"_jzRp_gi---","type":"project_root","name":"langchain-neo4j","path":"C:\\workspace\\langchain-neo4j"},{"_key":"langchain_neo4j","_id":"nodes/langchain_neo4j","_rev":"_jzRp_la---","type":"directory","name":"langchain_neo4j","path":"C:\\workspace\\langchain-neo4j\\langchain_neo4j"},{"_key":"langchain_neo4j___init___py","_id":"nodes/langchain_neo4j___init___py","_rev":"_jzRp_mO---","type":"file","name":"__init__.py","path":"C:\\workspace\\langchain-neo4j\\langchain_neo4j\\__init__.py"},{"_key":"langchain_neo4j_chains","_id":"nodes/langchain_neo4j_chains","_rev":"_jzRp_mm---","type":"directory","name":"chains","path":"C:\\workspace\\langchain-neo4j\\langchain_neo4j\\chains"},{"_key":"langchain_neo4j_chains___init___py","_id":"nodes/langchain_neo4j_chains___init___py","_rev":"_jzRp_n----","type":"file","name":"__init__.py","path":"C:\\workspace\\langchain-neo4j\\langchain_neo4j\\chains\\__init__.py"},{"_key":"langchain_neo4j_chains_graph_qa","_id":"nodes/langchain_neo4j_chains_graph_qa","_rev":"_jzRp_na---","type":"directory","name":"graph_qa","path":"C:\\workspace\\langchain-neo4j\\langchain_neo4j\\chains\\graph_qa"},{"_key":"langchain_neo4j_chains_graph_qa___init___py","_id":"nodes/langchain_neo4j_chains_graph_qa___init___py","_rev":"_jzRpA_y---","type":"file","name":"__init__.py","path":"C:\\workspace\\langchain-neo4j\\langchain_neo4j\\chains\\graph_qa\\__init__.py"},{"_key":"langchain_neo4j_chains_graph_qa_cypher_py","_id":"nodes/langchain_neo4j_chains_graph_qa_cypher_py","_rev":"_jzRp_n2---","type":"file","name":"cypher.py","path":"C:\\workspace\\langchain-neo4j\\langchain_neo4j\\chains\\graph_qa\\cypher.py"},{"_key":"langchain_neo4j_chains_graph_qa_cypher_py_GraphCypherQAChain","_id":"nodes/langchain_neo4j_chains_graph_qa_cypher_py_GraphCypherQAChain","_rev":"_jzRpKvS---","type":"class","name":"GraphCypherQAChain","defined_in":"langchain_neo4j_chains_graph_qa_cypher_py","lineno":103,"docstring":"Chain for question-answering against a graph by generating Cypher statements.\n\n*Security note*: Make sure that the database connection uses credentials\n    that are narrowly-scoped to only include necessary permissions.\n    Failure to do so may result in data corruption or loss, since the calling\n    code may attempt commands that would result in deletion, mutation\n    of data if appropriately prompted or reading sensitive data if such\n    data is present in the database.\n    The best way to guard against such negative outcomes is to (as appropriate)\n    limit the permissions granted to the credentials used with this tool.\n\n    See https://python.langchain.com/docs/security for more information.","source":"class GraphCypherQAChain(Chain):\n    \"\"\"Chain for question-answering against a graph by generating Cypher statements.\n\n    *Security note*: Make sure that the database connection uses credentials\n        that are narrowly-scoped to only include necessary permissions.\n        Failure to do so may result in data corruption or loss, since the calling\n        code may attempt commands that would result in deletion, mutation\n        of data if appropriately prompted or reading sensitive data if such\n        data is present in the database.\n        The best way to guard against such negative outcomes is to (as appropriate)\n        limit the permissions granted to the credentials used with this tool.\n\n        See https://python.langchain.com/docs/security for more information.\n    \"\"\"\n\n    graph: GraphStore = Field(exclude=True)\n    cypher_generation_chain: Runnable[Dict[str, Any], str]\n    qa_chain: Runnable[Dict[str, Any], str]\n    graph_schema: str\n    input_key: str = \"query\"  #: :meta private:\n    output_key: str = \"result\"  #: :meta private:\n    top_k: int = 10\n    \"\"\"Number of results to return from the query\"\"\"\n    return_intermediate_steps: bool = False\n    \"\"\"Whether or not to return the intermediate steps along with the final answer.\"\"\"\n    return_direct: bool = False\n    \"\"\"Whether or not to return the result of querying the graph directly.\"\"\"\n    cypher_query_corrector: Optional[CypherQueryCorrector] = None\n    \"\"\"Optional cypher validation tool\"\"\"\n    use_function_response: bool = False\n    \"\"\"Whether to wrap the database context as tool/function response\"\"\"\n    allow_dangerous_requests: bool = False\n    \"\"\"Forced user opt-in to acknowledge that the chain can make dangerous requests.\n    \n    *Security note*: Make sure that the database connection uses credentials\n        that are narrowly-scoped to only include necessary permissions.\n        Failure to do so may result in data corruption or loss, since the calling\n        code may attempt commands that would result in deletion, mutation\n        of data if appropriately prompted or reading sensitive data if such\n        data is present in the database.\n        The best way to guard against such negative outcomes is to (as appropriate)\n        limit the permissions granted to the credentials used with this tool.\n\n        See https://python.langchain.com/docs/security for more information.\n    \"\"\"\n\n    def __init__(self, **kwargs: Any) -> None:\n        \"\"\"Initialize the chain.\"\"\"\n        super().__init__(**kwargs)\n        if self.allow_dangerous_requests is not True:\n            raise ValueError(\n                \"In order to use this chain, you must acknowledge that it can make \"\n                \"dangerous requests by setting `allow_dangerous_requests` to `True`.\"\n                \"You must narrowly scope the permissions of the database connection \"\n                \"to only include necessary permissions. Failure to do so may result \"\n                \"in data corruption or loss or reading sensitive data if such data is \"\n                \"present in the database.\"\n                \"Only use this chain if you understand the risks and have taken the \"\n                \"necessary precautions. \"\n                \"See https://python.langchain.com/docs/security for more information.\"\n            )\n\n    @property\n    def input_keys(self) -> List[str]:\n        \"\"\"Return the input keys.\n\n        :meta private:\n        \"\"\"\n        return [self.input_key]\n\n    @property\n    def output_keys(self) -> List[str]:\n        \"\"\"Return the output keys.\n\n        :meta private:\n        \"\"\"\n        _output_keys = [self.output_key]\n        return _output_keys\n\n    @property\n    def _chain_type(self) -> str:\n        return \"graph_cypher_chain\"\n\n    @classmethod\n    def from_llm(\n        cls,\n        llm: Optional[BaseLanguageModel] = None,\n        *,\n        qa_prompt: Optional[BasePromptTemplate] = None,\n        cypher_prompt: Optional[BasePromptTemplate] = None,\n        cypher_llm: Optional[BaseLanguageModel] = None,\n        qa_llm: Optional[BaseLanguageModel] = None,\n        exclude_types: List[str] = [],\n        include_types: List[str] = [],\n        validate_cypher: bool = False,\n        qa_llm_kwargs: Optional[Dict[str, Any]] = None,\n        cypher_llm_kwargs: Optional[Dict[str, Any]] = None,\n        use_function_response: bool = False,\n        function_response_system: str = FUNCTION_RESPONSE_SYSTEM,\n        **kwargs: Any,\n    ) -> GraphCypherQAChain:\n        \"\"\"Initialize from LLM.\"\"\"\n        # Ensure at least one LLM is provided\n        if llm is None and qa_llm is None and cypher_llm is None:\n            raise ValueError(\"At least one LLM must be provided\")\n\n        # Prevent all three LLMs from being provided simultaneously\n        if llm is not None and qa_llm is not None and cypher_llm is not None:\n            raise ValueError(\n                \"You can specify up to two of 'cypher_llm', 'qa_llm'\"\n                \", and 'llm', but not all three simultaneously.\"\n            )\n\n        # Assign default LLMs if specific ones are not provided\n        if llm is not None:\n            qa_llm = qa_llm or llm\n            cypher_llm = cypher_llm or llm\n        else:\n            # If llm is None, both qa_llm and cypher_llm must be provided\n            if qa_llm is None or cypher_llm is None:\n                raise ValueError(\n                    \"If `llm` is not provided, both `qa_llm` and `cypher_llm` must be \"\n                    \"provided.\"\n                )\n        if cypher_prompt:\n            if cypher_llm_kwargs:\n                raise ValueError(\n                    \"Specifying cypher_prompt and cypher_llm_kwargs together is\"\n                    \" not allowed. Please pass prompt via cypher_llm_kwargs.\"\n                )\n        else:\n            if cypher_llm_kwargs:\n                cypher_prompt = cypher_llm_kwargs.pop(\n                    \"prompt\", CYPHER_GENERATION_PROMPT\n                )\n                if not isinstance(cypher_prompt, BasePromptTemplate):\n                    raise ValueError(\n                        \"The cypher_llm_kwargs `prompt` must inherit from \"\n                        \"BasePromptTemplate\"\n                    )\n            else:\n                cypher_prompt = CYPHER_GENERATION_PROMPT\n        if qa_prompt:\n            if qa_llm_kwargs:\n                raise ValueError(\n                    \"Specifying qa_prompt and qa_llm_kwargs together is\"\n                    \" not allowed. Please pass prompt via qa_llm_kwargs.\"\n                )\n        else:\n            if qa_llm_kwargs:\n                qa_prompt = qa_llm_kwargs.pop(\"prompt\", CYPHER_QA_PROMPT)\n                if not isinstance(qa_prompt, BasePromptTemplate):\n                    raise ValueError(\n                        \"The qa_llm_kwargs `prompt` must inherit from \"\n                        \"BasePromptTemplate\"\n                    )\n            else:\n                qa_prompt = CYPHER_QA_PROMPT\n        use_qa_llm_kwargs = qa_llm_kwargs if qa_llm_kwargs is not None else {}\n        use_cypher_llm_kwargs = (\n            cypher_llm_kwargs if cypher_llm_kwargs is not None else {}\n        )\n\n        if use_function_response:\n            try:\n                if hasattr(qa_llm, \"bind_tools\"):\n                    qa_llm.bind_tools({})\n                else:\n                    raise AttributeError\n                response_prompt = ChatPromptTemplate.from_messages(\n                    [\n                        SystemMessage(content=function_response_system),\n                        HumanMessagePromptTemplate.from_template(\"{question}\"),\n                        MessagesPlaceholder(variable_name=\"function_response\"),\n                    ]\n                )\n                qa_chain = response_prompt | qa_llm | StrOutputParser()\n            except (NotImplementedError, AttributeError):\n                raise ValueError(\"Provided LLM does not support native tools/functions\")\n        else:\n            qa_chain = qa_prompt | qa_llm.bind(**use_qa_llm_kwargs) | StrOutputParser()\n        cypher_generation_chain = (\n            cypher_prompt | cypher_llm.bind(**use_cypher_llm_kwargs) | StrOutputParser()\n        )\n\n        if exclude_types and include_types:\n            raise ValueError(\n                \"Either `exclude_types` or `include_types` \"\n                \"can be provided, but not both\"\n            )\n        graph = kwargs[\"graph\"]\n        graph_schema = construct_schema(\n            graph.get_structured_schema,\n            include_types,\n            exclude_types,\n            graph._enhanced_schema,\n        )\n\n        cypher_query_corrector = None\n        if validate_cypher:\n            corrector_schema = [\n                Schema(el[\"start\"], el[\"type\"], el[\"end\"])\n                for el in graph.get_structured_schema.get(\"relationships\", [])\n            ]\n            cypher_query_corrector = CypherQueryCorrector(corrector_schema)\n\n        return cls(\n            graph_schema=graph_schema,\n            qa_chain=qa_chain,\n            cypher_generation_chain=cypher_generation_chain,\n            cypher_query_corrector=cypher_query_corrector,\n            use_function_response=use_function_response,\n            **kwargs,\n        )\n\n    def _call(\n        self,\n        inputs: Dict[str, Any],\n        run_manager: Optional[CallbackManagerForChainRun] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"Generate Cypher statement, use it to look up in db and answer question.\"\"\"\n        _run_manager = run_manager or CallbackManagerForChainRun.get_noop_manager()\n        callbacks = _run_manager.get_child()\n        question = inputs[self.input_key]\n        args = {\n            \"question\": question,\n            \"schema\": self.graph_schema,\n        }\n        args.update(inputs)\n\n        intermediate_steps: List = []\n\n        generated_cypher = self.cypher_generation_chain.invoke(\n            args, callbacks=callbacks\n        )\n\n        # Extract Cypher code if it is wrapped in backticks\n        generated_cypher = extract_cypher(generated_cypher)\n\n        # Correct Cypher query if enabled\n        if self.cypher_query_corrector:\n            generated_cypher = self.cypher_query_corrector(generated_cypher)\n\n        _run_manager.on_text(\"Generated Cypher:\", end=\"\\n\", verbose=self.verbose)\n        _run_manager.on_text(\n            generated_cypher, color=\"green\", end=\"\\n\", verbose=self.verbose\n        )\n\n        intermediate_steps.append({\"query\": generated_cypher})\n\n        # Retrieve and limit the number of results\n        # Generated Cypher be null if query corrector identifies invalid schema\n        if generated_cypher:\n            context = self.graph.query(generated_cypher)[: self.top_k]\n        else:\n            context = []\n\n        final_result: Union[List[Dict[str, Any]], str]\n        if self.return_direct:\n            final_result = context\n        else:\n            _run_manager.on_text(\"Full Context:\", end=\"\\n\", verbose=self.verbose)\n            _run_manager.on_text(\n                str(context), color=\"green\", end=\"\\n\", verbose=self.verbose\n            )\n\n            intermediate_steps.append({\"context\": context})\n            if self.use_function_response:\n                function_response = get_function_response(question, context)\n                final_result = self.qa_chain.invoke(\n                    {\"question\": question, \"function_response\": function_response},\n                )\n            else:\n                final_result = self.qa_chain.invoke(\n                    {\"question\": question, \"context\": context},\n                    callbacks=callbacks,\n                )\n\n        chain_result: Dict[str, Any] = {self.output_key: final_result}\n        if self.return_intermediate_steps:\n            chain_result[INTERMEDIATE_STEPS_KEY] = intermediate_steps\n\n        return chain_result","inst_variables":[],"reason_kor":"GraphCypherQAChain 클래스 정의로, 그래프 데이터베이스에 대해 Cypher 쿼리를 생성하여 질의응답을 수행하는 체인입니다. 초기화, 입력/출력 처리, LLM과의 통합을 통해 Cypher 쿼리를 생성하고 실행하며 결과를 처리하는 기능을 포함합니다.","reason":"This is the definition of the GraphCypherQAChain class, which is a chain for question-answering over a graph database using generated Cypher queries. It includes initialization, input/output handling, and integration with LLMs to generate and execute Cypher queries and process the results."},{"_key":"langchain_neo4j_chains_graph_qa_cypher_py___init__","_id":"nodes/langchain_neo4j_chains_graph_qa_cypher_py___init__","_rev":"_jzRpKvm---","type":"function","name":"__init__","defined_in":"langchain_neo4j_chains_graph_qa_cypher_py","lineno":149,"source":"def __init__(self, **kwargs: Any) -> None:\n        \"\"\"Initialize the chain.\"\"\"\n        super().__init__(**kwargs)\n        if self.allow_dangerous_requests is not True:\n            raise ValueError(\n                \"In order to use this chain, you must acknowledge that it can make \"\n                \"dangerous requests by setting `allow_dangerous_requests` to `True`.\"\n                \"You must narrowly scope the permissions of the database connection \"\n                \"to only include necessary permissions. Failure to do so may result \"\n                \"in data corruption or loss or reading sensitive data if such data is \"\n                \"present in the database.\"\n                \"Only use this chain if you understand the risks and have taken the \"\n                \"necessary precautions. \"\n                \"See https://python.langchain.com/docs/security for more information.\"\n            )","docstring":"Initialize the chain.","args":[{"arg":"self","type":null}],"return_type":"None","control_flow":[{"type":"if","lineno":152}],"reason_kor":"클래스 초기화, 슈퍼 클래스 생성자 호출, 그리고 위험한 요청에 대한 보안 검사로, 승인되지 않은 경우 오류를 발생시킴","reason":"it is about class initialization, super class constructor call, and a security check for dangerous requests, raising an error if not acknowledged"},{"_key":"langchain_neo4j_chains_graph_qa_cypher_py__call","_id":"nodes/langchain_neo4j_chains_graph_qa_cypher_py__call","_rev":"_jzRpKvy---","type":"function","name":"_call","defined_in":"langchain_neo4j_chains_graph_qa_cypher_py","lineno":318,"source":"def _call(\n        self,\n        inputs: Dict[str, Any],\n        run_manager: Optional[CallbackManagerForChainRun] = None,\n    ) -> Dict[str, Any]:\n        \"\"\"Generate Cypher statement, use it to look up in db and answer question.\"\"\"\n        _run_manager = run_manager or CallbackManagerForChainRun.get_noop_manager()\n        callbacks = _run_manager.get_child()\n        question = inputs[self.input_key]\n        args = {\n            \"question\": question,\n            \"schema\": self.graph_schema,\n        }\n        args.update(inputs)\n\n        intermediate_steps: List = []\n\n        generated_cypher = self.cypher_generation_chain.invoke(\n            args, callbacks=callbacks\n        )\n\n        # Extract Cypher code if it is wrapped in backticks\n        generated_cypher = extract_cypher(generated_cypher)\n\n        # Correct Cypher query if enabled\n        if self.cypher_query_corrector:\n            generated_cypher = self.cypher_query_corrector(generated_cypher)\n\n        _run_manager.on_text(\"Generated Cypher:\", end=\"\\n\", verbose=self.verbose)\n        _run_manager.on_text(\n            generated_cypher, color=\"green\", end=\"\\n\", verbose=self.verbose\n        )\n\n        intermediate_steps.append({\"query\": generated_cypher})\n\n        # Retrieve and limit the number of results\n        # Generated Cypher be null if query corrector identifies invalid schema\n        if generated_cypher:\n            context = self.graph.query(generated_cypher)[: self.top_k]\n        else:\n            context = []\n\n        final_result: Union[List[Dict[str, Any]], str]\n        if self.return_direct:\n            final_result = context\n        else:\n            _run_manager.on_text(\"Full Context:\", end=\"\\n\", verbose=self.verbose)\n            _run_manager.on_text(\n                str(context), color=\"green\", end=\"\\n\", verbose=self.verbose\n            )\n\n            intermediate_steps.append({\"context\": context})\n            if self.use_function_response:\n                function_response = get_function_response(question, context)\n                final_result = self.qa_chain.invoke(\n                    {\"question\": question, \"function_response\": function_response},\n                )\n            else:\n                final_result = self.qa_chain.invoke(\n                    {\"question\": question, \"context\": context},\n                    callbacks=callbacks,\n                )\n\n        chain_result: Dict[str, Any] = {self.output_key: final_result}\n        if self.return_intermediate_steps:\n            chain_result[INTERMEDIATE_STEPS_KEY] = intermediate_steps\n\n        return chain_result","docstring":"Generate Cypher statement, use it to look up in db and answer question.","args":[{"arg":"self","type":null},{"arg":"inputs","type":"Dict[str, Any]"},{"arg":"run_manager","type":"Optional[CallbackManagerForChainRun]"}],"return_type":"Dict[str, Any]","control_flow":[{"type":"if","lineno":343},{"type":"if","lineno":355},{"type":"if","lineno":361},{"type":"if","lineno":370},{"type":"if","lineno":382}],"reason_kor":"입력 처리, Cypher 쿼리 생성 및 수정, 데이터베이스 쿼리, 로깅, 조건부 응답 형식화, QA 체인 호출을 결합하여 질문을 처리하고 그래프 데이터베이스를 조회하며, 선택적 중간 단계를 포함한 구조화된 답변을 생성합니다.","reason":"it is about input handling, Cypher query generation and correction, database querying, logging, conditional response formatting, and invocation of a QA chain, to process a question, query a graph database, and produce a structured answer with optional intermediate steps."},{"_key":"langchain_neo4j_chains_graph_qa_cypher_py__chain_type","_id":"nodes/langchain_neo4j_chains_graph_qa_cypher_py__chain_type","_rev":"_jzRpKw----","type":"function","name":"_chain_type","defined_in":"langchain_neo4j_chains_graph_qa_cypher_py","lineno":183,"source":"def _chain_type(self) -> str:\n        return \"graph_cypher_chain\"","docstring":null,"args":[{"arg":"self","type":null}],"return_type":"str","control_flow":[],"reason_kor":"GraphCypherQAChain의 내부 체인 타입 식별자를 정의하는 메서드로, 체인 종류를 나타내는 고정 문자열을 반환합니다.","reason":"This method defines the internal chain type identifier for the GraphCypherQAChain, returning a fixed string indicating the chain category."},{"_key":"langchain_neo4j_chains_graph_qa_cypher_py_construct_schema","_id":"nodes/langchain_neo4j_chains_graph_qa_cypher_py_construct_schema","_rev":"_jzRpKwK---","type":"function","name":"construct_schema","defined_in":"langchain_neo4j_chains_graph_qa_cypher_py","lineno":47,"source":"def construct_schema(\n    structured_schema: Dict[str, Any],\n    include_types: List[str],\n    exclude_types: List[str],\n    is_enhanced: bool,\n) -> str:\n    \"\"\"Filter the schema based on included or excluded types\"\"\"\n\n    def filter_func(x: str) -> bool:\n        return x in include_types if include_types else x not in exclude_types\n\n    filtered_schema: Dict[str, Any] = {\n        \"node_props\": {\n            k: v\n            for k, v in structured_schema.get(\"node_props\", {}).items()\n            if filter_func(k)\n        },\n        \"rel_props\": {\n            k: v\n            for k, v in structured_schema.get(\"rel_props\", {}).items()\n            if filter_func(k)\n        },\n        \"relationships\": [\n            r\n            for r in structured_schema.get(\"relationships\", [])\n            if all(filter_func(r[t]) for t in [\"start\", \"end\", \"type\"])\n        ],\n    }\n    return format_schema(filtered_schema, is_enhanced)","docstring":"Filter the schema based on included or excluded types","args":[{"arg":"structured_schema","type":"Dict[str, Any]"},{"arg":"include_types","type":"List[str]"},{"arg":"exclude_types","type":"List[str]"},{"arg":"is_enhanced","type":"bool"}],"return_type":"str","control_flow":[],"reason_kor":"포함 및 제외 타입 목록에 기반하여 스키마 요소를 필터링하고, 필터링된 스키마를 선택적 향상과 함께 형식화합니다.","reason":"it is about filtering of schema elements based on include and exclude type lists and then formatted the filtered schema with optional enhancement"},{"_key":"langchain_neo4j_chains_graph_qa_cypher_py_from_llm","_id":"nodes/langchain_neo4j_chains_graph_qa_cypher_py_from_llm","_rev":"_jzRpKwa---","type":"function","name":"from_llm","defined_in":"langchain_neo4j_chains_graph_qa_cypher_py","lineno":187,"source":"def from_llm(\n        cls,\n        llm: Optional[BaseLanguageModel] = None,\n        *,\n        qa_prompt: Optional[BasePromptTemplate] = None,\n        cypher_prompt: Optional[BasePromptTemplate] = None,\n        cypher_llm: Optional[BaseLanguageModel] = None,\n        qa_llm: Optional[BaseLanguageModel] = None,\n        exclude_types: List[str] = [],\n        include_types: List[str] = [],\n        validate_cypher: bool = False,\n        qa_llm_kwargs: Optional[Dict[str, Any]] = None,\n        cypher_llm_kwargs: Optional[Dict[str, Any]] = None,\n        use_function_response: bool = False,\n        function_response_system: str = FUNCTION_RESPONSE_SYSTEM,\n        **kwargs: Any,\n    ) -> GraphCypherQAChain:\n        \"\"\"Initialize from LLM.\"\"\"\n        # Ensure at least one LLM is provided\n        if llm is None and qa_llm is None and cypher_llm is None:\n            raise ValueError(\"At least one LLM must be provided\")\n\n        # Prevent all three LLMs from being provided simultaneously\n        if llm is not None and qa_llm is not None and cypher_llm is not None:\n            raise ValueError(\n                \"You can specify up to two of 'cypher_llm', 'qa_llm'\"\n                \", and 'llm', but not all three simultaneously.\"\n            )\n\n        # Assign default LLMs if specific ones are not provided\n        if llm is not None:\n            qa_llm = qa_llm or llm\n            cypher_llm = cypher_llm or llm\n        else:\n            # If llm is None, both qa_llm and cypher_llm must be provided\n            if qa_llm is None or cypher_llm is None:\n                raise ValueError(\n                    \"If `llm` is not provided, both `qa_llm` and `cypher_llm` must be \"\n                    \"provided.\"\n                )\n        if cypher_prompt:\n            if cypher_llm_kwargs:\n                raise ValueError(\n                    \"Specifying cypher_prompt and cypher_llm_kwargs together is\"\n                    \" not allowed. Please pass prompt via cypher_llm_kwargs.\"\n                )\n        else:\n            if cypher_llm_kwargs:\n                cypher_prompt = cypher_llm_kwargs.pop(\n                    \"prompt\", CYPHER_GENERATION_PROMPT\n                )\n                if not isinstance(cypher_prompt, BasePromptTemplate):\n                    raise ValueError(\n                        \"The cypher_llm_kwargs `prompt` must inherit from \"\n                        \"BasePromptTemplate\"\n                    )\n            else:\n                cypher_prompt = CYPHER_GENERATION_PROMPT\n        if qa_prompt:\n            if qa_llm_kwargs:\n                raise ValueError(\n                    \"Specifying qa_prompt and qa_llm_kwargs together is\"\n                    \" not allowed. Please pass prompt via qa_llm_kwargs.\"\n                )\n        else:\n            if qa_llm_kwargs:\n                qa_prompt = qa_llm_kwargs.pop(\"prompt\", CYPHER_QA_PROMPT)\n                if not isinstance(qa_prompt, BasePromptTemplate):\n                    raise ValueError(\n                        \"The qa_llm_kwargs `prompt` must inherit from \"\n                        \"BasePromptTemplate\"\n                    )\n            else:\n                qa_prompt = CYPHER_QA_PROMPT\n        use_qa_llm_kwargs = qa_llm_kwargs if qa_llm_kwargs is not None else {}\n        use_cypher_llm_kwargs = (\n            cypher_llm_kwargs if cypher_llm_kwargs is not None else {}\n        )\n\n        if use_function_response:\n            try:\n                if hasattr(qa_llm, \"bind_tools\"):\n                    qa_llm.bind_tools({})\n                else:\n                    raise AttributeError\n                response_prompt = ChatPromptTemplate.from_messages(\n                    [\n                        SystemMessage(content=function_response_system),\n                        HumanMessagePromptTemplate.from_template(\"{question}\"),\n                        MessagesPlaceholder(variable_name=\"function_response\"),\n                    ]\n                )\n                qa_chain = response_prompt | qa_llm | StrOutputParser()\n            except (NotImplementedError, AttributeError):\n                raise ValueError(\"Provided LLM does not support native tools/functions\")\n        else:\n            qa_chain = qa_prompt | qa_llm.bind(**use_qa_llm_kwargs) | StrOutputParser()\n        cypher_generation_chain = (\n            cypher_prompt | cypher_llm.bind(**use_cypher_llm_kwargs) | StrOutputParser()\n        )\n\n        if exclude_types and include_types:\n            raise ValueError(\n                \"Either `exclude_types` or `include_types` \"\n                \"can be provided, but not both\"\n            )\n        graph = kwargs[\"graph\"]\n        graph_schema = construct_schema(\n            graph.get_structured_schema,\n            include_types,\n            exclude_types,\n            graph._enhanced_schema,\n        )\n\n        cypher_query_corrector = None\n        if validate_cypher:\n            corrector_schema = [\n                Schema(el[\"start\"], el[\"type\"], el[\"end\"])\n                for el in graph.get_structured_schema.get(\"relationships\", [])\n            ]\n            cypher_query_corrector = CypherQueryCorrector(corrector_schema)\n\n        return cls(\n            graph_schema=graph_schema,\n            qa_chain=qa_chain,\n            cypher_generation_chain=cypher_generation_chain,\n            cypher_query_corrector=cypher_query_corrector,\n            use_function_response=use_function_response,\n            **kwargs,\n        )","docstring":"Initialize from LLM.","args":[{"arg":"cls","type":null},{"arg":"llm","type":"Optional[BaseLanguageModel]"}],"return_type":"GraphCypherQAChain","control_flow":[{"type":"if","lineno":206},{"type":"if","lineno":210},{"type":"if","lineno":217},{"type":"if","lineno":222},{"type":"if","lineno":227},{"type":"if","lineno":228},{"type":"if","lineno":234},{"type":"if","lineno":238},{"type":"if","lineno":245},{"type":"if","lineno":246},{"type":"if","lineno":252},{"type":"if","lineno":254},{"type":"if","lineno":266},{"type":"try","lineno":267},{"type":"if","lineno":268},{"type":"if","lineno":288},{"type":"if","lineno":302}],"reason_kor":"여러 LLM 소스, 프롬프트 템플릿 및 구성 옵션에 대한 매개변수 유효성 검사를 수행하여 기본 할당, 검증, 함수 응답 처리 등의 선택적 기능을 포함하며, 충돌 방지를 보장하는 유연한 GraphCypherQAChain 객체 초기화를 결합합니다.","reason":"it is about parameter validation for multiple LLM sources, prompt templates, and configuration options to initialize a GraphCypherQAChain object with flexible logic for default assignment, validation, and optional functionalities like function response handling, while ensuring correctness and preventing conflicting parameters."},{"_key":"langchain_neo4j_chains_graph_qa_cypher_py_get_function_response","_id":"nodes/langchain_neo4j_chains_graph_qa_cypher_py_get_function_response","_rev":"_jzRpKwm---","type":"function","name":"get_function_response","defined_in":"langchain_neo4j_chains_graph_qa_cypher_py","lineno":78,"source":"def get_function_response(\n    question: str, context: List[Dict[str, Any]]\n) -> List[BaseMessage]:\n    TOOL_ID = \"call_H7fABDuzEau48T10Qn0Lsh0D\"\n    messages = [\n        AIMessage(\n            content=\"\",\n            additional_kwargs={\n                \"tool_calls\": [\n                    {\n                        \"id\": TOOL_ID,\n                        \"function\": {\n                            \"arguments\": '{\"question\":\"' + question + '\"}',\n                            \"name\": \"GetInformation\",\n                        },\n                        \"type\": \"function\",\n                    }\n                ]\n            },\n        ),\n        ToolMessage(content=str(context), tool_call_id=TOOL_ID),\n    ]\n    return messages","docstring":null,"args":[{"arg":"question","type":"str"},{"arg":"context","type":"List[Dict[str, Any]]"}],"return_type":"List[BaseMessage]","control_flow":[],"reason_kor":"정의된 메시지와 질문을 JSON 문자열로 전달하는 동적 도구 호출을 결합하고, 컨텍스트 정보를 ToolMessage로 추가하여 처리할 메시지 시퀀스를 형성합니다.","reason":"it is about a predefined message with a dynamic tool call that passes a question as a JSON string, appending context information as a ToolMessage to form a sequence of messages for processing"},{"_key":"langchain_neo4j_chains_graph_qa_cypher_py_input_keys","_id":"nodes/langchain_neo4j_chains_graph_qa_cypher_py_input_keys","_rev":"_jzRpKwy---","type":"function","name":"input_keys","defined_in":"langchain_neo4j_chains_graph_qa_cypher_py","lineno":166,"source":"def input_keys(self) -> List[str]:\n        \"\"\"Return the input keys.\n\n        :meta private:\n        \"\"\"\n        return [self.input_key]","docstring":"Return the input keys.\n\n:meta private:","args":[{"arg":"self","type":null}],"return_type":"List[str]","control_flow":[],"reason_kor":"체인이 기대하는 입력 키 목록을 반환하는 메서드로, 보통 처리 시 입력 필드를 식별하는 데 사용됩니다.","reason":"This method returns the list of input keys expected by the chain, typically used for identifying input fields in processing."},{"_key":"langchain_neo4j_chains_graph_qa_cypher_py_output_keys","_id":"nodes/langchain_neo4j_chains_graph_qa_cypher_py_output_keys","_rev":"_jzRpKxC---","type":"function","name":"output_keys","defined_in":"langchain_neo4j_chains_graph_qa_cypher_py","lineno":174,"source":"def output_keys(self) -> List[str]:\n        \"\"\"Return the output keys.\n\n        :meta private:\n        \"\"\"\n        _output_keys = [self.output_key]\n        return _output_keys","docstring":"Return the output keys.\n\n:meta private:","args":[{"arg":"self","type":null}],"return_type":"List[str]","control_flow":[],"reason_kor":"체인이 생성하는 출력 키 목록을 반환하는 메서드로, 처리 후 출력 필드를 식별합니다.","reason":"This method returns the list of output keys that the chain produces, identifying output fields after processing."},{"_key":"langchain_neo4j_chains_graph_qa_cypher_utils_py","_id":"nodes/langchain_neo4j_chains_graph_qa_cypher_utils_py","_rev":"_jzRp_1u---","type":"file","name":"cypher_utils.py","path":"C:\\workspace\\langchain-neo4j\\langchain_neo4j\\chains\\graph_qa\\cypher_utils.py"},{"_key":"langchain_neo4j_chains_graph_qa_cypher_utils_py_CypherQueryCorrector","_id":"nodes/langchain_neo4j_chains_graph_qa_cypher_utils_py_CypherQueryCorrector","_rev":"_jzRpKxO---","type":"class","name":"CypherQueryCorrector","defined_in":"langchain_neo4j_chains_graph_qa_cypher_utils_py","lineno":8,"docstring":"Used to correct relationship direction in generated Cypher statements.\nThis code is copied from the winner's submission to the Cypher competition:\nhttps://github.com/sakusaku-rich/cypher-direction-competition","source":"class CypherQueryCorrector:\n    \"\"\"\n    Used to correct relationship direction in generated Cypher statements.\n    This code is copied from the winner's submission to the Cypher competition:\n    https://github.com/sakusaku-rich/cypher-direction-competition\n    \"\"\"\n\n    property_pattern = re.compile(r\"\\{.+?\\}\")\n    node_pattern = re.compile(r\"\\(.+?\\)\")\n    path_pattern = re.compile(\n        r\"(\\([^\\,\\(\\)]*?(\\{.+\\})?[^\\,\\(\\)]*?\\))(<?-)(\\[.*?\\])?(->?)(\\([^\\,\\(\\)]*?(\\{.+\\})?[^\\,\\(\\)]*?\\))\"\n    )\n    node_relation_node_pattern = re.compile(\n        r\"(\\()+(?P<left_node>[^()]*?)\\)(?P<relation>.*?)\\((?P<right_node>[^()]*?)(\\))+\"\n    )\n    relation_type_pattern = re.compile(r\":(?P<relation_type>.+?)?(\\{.+\\})?]\")\n\n    def __init__(self, schemas: List[Schema]):\n        \"\"\"\n        Args:\n            schemas: list of schemas\n        \"\"\"\n        self.schemas = schemas\n\n    def clean_node(self, node: str) -> str:\n        \"\"\"\n        Args:\n            node: node in string format\n\n        \"\"\"\n        node = re.sub(self.property_pattern, \"\", node)\n        node = node.replace(\"(\", \"\")\n        node = node.replace(\")\", \"\")\n        node = node.strip()\n        return node\n\n    def detect_node_variables(self, query: str) -> Dict[str, List[str]]:\n        \"\"\"\n        Args:\n            query: cypher query\n        \"\"\"\n        nodes = re.findall(self.node_pattern, query)\n        nodes = [self.clean_node(node) for node in nodes]\n        res: Dict[str, Any] = {}\n        for node in nodes:\n            parts = node.split(\":\")\n            if parts == \"\":\n                continue\n            variable = parts[0]\n            if variable not in res:\n                res[variable] = []\n            res[variable] += parts[1:]\n        return res\n\n    def extract_paths(self, query: str) -> \"List[str]\":\n        \"\"\"\n        Args:\n            query: cypher query\n        \"\"\"\n        paths = []\n        idx = 0\n        while matched := self.path_pattern.findall(query[idx:]):\n            matched = matched[0]\n            matched = [\n                m for i, m in enumerate(matched) if i not in [1, len(matched) - 1]\n            ]\n            path = \"\".join(matched)\n            idx = idx + query[idx:].find(path) + len(path) - len(matched[-1])\n            paths.append(path)\n        return paths\n\n    def judge_direction(self, relation: str) -> str:\n        \"\"\"\n        Args:\n            relation: relation in string format\n        \"\"\"\n        direction = \"BIDIRECTIONAL\"\n        if relation[0] == \"<\":\n            direction = \"INCOMING\"\n        if relation[-1] == \">\":\n            direction = \"OUTGOING\"\n        return direction\n\n    def extract_node_variable(self, part: str) -> Optional[str]:\n        \"\"\"\n        Args:\n            part: node in string format\n        \"\"\"\n        part = part.lstrip(\"(\").rstrip(\")\")\n        idx = part.find(\":\")\n        if idx != -1:\n            part = part[:idx]\n        return None if part == \"\" else part\n\n    def detect_labels(\n        self, str_node: str, node_variable_dict: Dict[str, Any]\n    ) -> List[str]:\n        \"\"\"\n        Args:\n            str_node: node in string format\n            node_variable_dict: dictionary of node variables\n        \"\"\"\n        splitted_node = str_node.split(\":\")\n        variable = splitted_node[0]\n        labels = []\n        if variable in node_variable_dict:\n            labels = node_variable_dict[variable]\n        elif variable == \"\" and len(splitted_node) > 1:\n            labels = splitted_node[1:]\n        return labels\n\n    def verify_schema(\n        self,\n        from_node_labels: List[str],\n        relation_types: List[str],\n        to_node_labels: List[str],\n    ) -> bool:\n        \"\"\"\n        Args:\n            from_node_labels: labels of the from node\n            relation_type: type of the relation\n            to_node_labels: labels of the to node\n        \"\"\"\n        valid_schemas = self.schemas\n        if from_node_labels != []:\n            from_node_labels = [label.strip(\"`\") for label in from_node_labels]\n            valid_schemas = [\n                schema for schema in valid_schemas if schema[0] in from_node_labels\n            ]\n        if to_node_labels != []:\n            to_node_labels = [label.strip(\"`\") for label in to_node_labels]\n            valid_schemas = [\n                schema for schema in valid_schemas if schema[2] in to_node_labels\n            ]\n        if relation_types != []:\n            relation_types = [type.strip(\"`\") for type in relation_types]\n            valid_schemas = [\n                schema for schema in valid_schemas if schema[1] in relation_types\n            ]\n        return valid_schemas != []\n\n    def detect_relation_types(self, str_relation: str) -> Tuple[str, List[str]]:\n        \"\"\"\n        Args:\n            str_relation: relation in string format\n        \"\"\"\n        relation_direction = self.judge_direction(str_relation)\n        relation_type = self.relation_type_pattern.search(str_relation)\n        if relation_type is None or relation_type.group(\"relation_type\") is None:\n            return relation_direction, []\n        relation_types = [\n            t.strip().strip(\"!\")\n            for t in relation_type.group(\"relation_type\").split(\"|\")\n        ]\n        return relation_direction, relation_types\n\n    def correct_query(self, query: str) -> str:\n        \"\"\"\n        Args:\n            query: cypher query\n        \"\"\"\n        node_variable_dict = self.detect_node_variables(query)\n        paths = self.extract_paths(query)\n        for path in paths:\n            original_path = path\n            start_idx = 0\n            while start_idx < len(path):\n                match_res = re.match(self.node_relation_node_pattern, path[start_idx:])\n                if match_res is None:\n                    break\n                start_idx += match_res.start()\n                match_dict = match_res.groupdict()\n                left_node_labels = self.detect_labels(\n                    match_dict[\"left_node\"], node_variable_dict\n                )\n                right_node_labels = self.detect_labels(\n                    match_dict[\"right_node\"], node_variable_dict\n                )\n                end_idx = (\n                    start_idx\n                    + 4\n                    + len(match_dict[\"left_node\"])\n                    + len(match_dict[\"relation\"])\n                    + len(match_dict[\"right_node\"])\n                )\n                original_partial_path = original_path[start_idx : end_idx + 1]\n                relation_direction, relation_types = self.detect_relation_types(\n                    match_dict[\"relation\"]\n                )\n\n                if relation_types != [] and \"\".join(relation_types).find(\"*\") != -1:\n                    start_idx += (\n                        len(match_dict[\"left_node\"]) + len(match_dict[\"relation\"]) + 2\n                    )\n                    continue\n\n                if relation_direction == \"OUTGOING\":\n                    is_legal = self.verify_schema(\n                        left_node_labels, relation_types, right_node_labels\n                    )\n                    if not is_legal:\n                        is_legal = self.verify_schema(\n                            right_node_labels, relation_types, left_node_labels\n                        )\n                        if is_legal:\n                            corrected_relation = \"<\" + match_dict[\"relation\"][:-1]\n                            corrected_partial_path = original_partial_path.replace(\n                                match_dict[\"relation\"], corrected_relation\n                            )\n                            query = query.replace(\n                                original_partial_path, corrected_partial_path\n                            )\n                        else:\n                            return \"\"\n                elif relation_direction == \"INCOMING\":\n                    is_legal = self.verify_schema(\n                        right_node_labels, relation_types, left_node_labels\n                    )\n                    if not is_legal:\n                        is_legal = self.verify_schema(\n                            left_node_labels, relation_types, right_node_labels\n                        )\n                        if is_legal:\n                            corrected_relation = match_dict[\"relation\"][1:] + \">\"\n                            corrected_partial_path = original_partial_path.replace(\n                                match_dict[\"relation\"], corrected_relation\n                            )\n                            query = query.replace(\n                                original_partial_path, corrected_partial_path\n                            )\n                        else:\n                            return \"\"\n                else:\n                    is_legal = self.verify_schema(\n                        left_node_labels, relation_types, right_node_labels\n                    )\n                    is_legal |= self.verify_schema(\n                        right_node_labels, relation_types, left_node_labels\n                    )\n                    if not is_legal:\n                        return \"\"\n\n                start_idx += (\n                    len(match_dict[\"left_node\"]) + len(match_dict[\"relation\"]) + 2\n                )\n        return query\n\n    def __call__(self, query: str) -> str:\n        \"\"\"Correct the query to make it valid. If\n        Args:\n            query: cypher query\n        \"\"\"\n        return self.correct_query(query)","inst_variables":[{"var":"schemas","type":null,"value":"schemas","lineno":30}],"reason_kor":"CypherQueryCorrector 클래스는 주어진 스키마 제약 조건에 기반하여 생성된 Cypher 쿼리 내 관계의 방향성과 유효성을 분석하고 수정하는 기능을 제공하여 쿼리가 데이터베이스 스키마에 부합하도록 합니다.","reason":"This class, CypherQueryCorrector, provides functionality to analyze and correct directionality and validity of relationships in generated Cypher queries based on given schema constraints, ensuring that queries conform to the database schema."},{"_key":"langchain_neo4j_chains_graph_qa_cypher_utils_py___call__","_id":"nodes/langchain_neo4j_chains_graph_qa_cypher_utils_py___call__","_rev":"_jzRpKxa---","type":"function","name":"__call__","defined_in":"langchain_neo4j_chains_graph_qa_cypher_utils_py","lineno":255,"source":"def __call__(self, query: str) -> str:\n        \"\"\"Correct the query to make it valid. If\n        Args:\n            query: cypher query\n        \"\"\"\n        return self.correct_query(query)","docstring":"Correct the query to make it valid. If\nArgs:\n    query: cypher query","args":[{"arg":"self","type":null},{"arg":"query","type":"str"}],"return_type":"str","control_flow":[],"reason":"This method enables the CypherQueryCorrector instance to be called as a function, taking a Cypher query string and returning the corrected valid query.","reason_kor":"CypherQueryCorrector 인스턴스를 함수처럼 호출할 수 있게 하는 메서드로, Cypher 쿼리 문자열을 받아 유효하도록 수정된 쿼리를 반환합니다."},{"_key":"langchain_neo4j_chains_graph_qa_cypher_utils_py___init__","_id":"nodes/langchain_neo4j_chains_graph_qa_cypher_utils_py___init__","_rev":"_jzRpKxm---","type":"function","name":"__init__","defined_in":"langchain_neo4j_chains_graph_qa_cypher_utils_py","lineno":25,"source":"def __init__(self, schemas: List[Schema]):\n        \"\"\"\n        Args:\n            schemas: list of schemas\n        \"\"\"\n        self.schemas = schemas","docstring":"Args:\n    schemas: list of schemas","args":[{"arg":"self","type":null},{"arg":"schemas","type":"List[Schema]"}],"return_type":null,"control_flow":[],"reason":"This is the constructor method of the CypherQueryCorrector class, initializing the instance with a list of schema objects representing the graph schema constraints.","reason_kor":"CypherQueryCorrector 클래스의 생성자 메서드로, 그래프 스키마 제약 조건을 나타내는 스키마 객체 리스트로 인스턴스를 초기화합니다."},{"_key":"langchain_neo4j_chains_graph_qa_cypher_utils_py_clean_node","_id":"nodes/langchain_neo4j_chains_graph_qa_cypher_utils_py_clean_node","_rev":"_jzRpKxy---","type":"function","name":"clean_node","defined_in":"langchain_neo4j_chains_graph_qa_cypher_utils_py","lineno":32,"source":"def clean_node(self, node: str) -> str:\n        \"\"\"\n        Args:\n            node: node in string format\n\n        \"\"\"\n        node = re.sub(self.property_pattern, \"\", node)\n        node = node.replace(\"(\", \"\")\n        node = node.replace(\")\", \"\")\n        node = node.strip()\n        return node","docstring":"Args:\n    node: node in string format","args":[{"arg":"self","type":null},{"arg":"node","type":"str"}],"return_type":"str","control_flow":[],"reason":"This method processes a node string by removing property patterns and stripping parentheses and whitespace, returning a cleaned node identifier string.","reason_kor":"노드 문자열에서 프로퍼티 패턴을 제거하고 괄호와 공백을 삭제하여 정리된 노드 식별자 문자열을 반환하는 메서드입니다."},{"_key":"langchain_neo4j_chains_graph_qa_cypher_utils_py_correct_query","_id":"nodes/langchain_neo4j_chains_graph_qa_cypher_utils_py_correct_query","_rev":"_jzRpKyC---","type":"function","name":"correct_query","defined_in":"langchain_neo4j_chains_graph_qa_cypher_utils_py","lineno":164,"source":"def correct_query(self, query: str) -> str:\n        \"\"\"\n        Args:\n            query: cypher query\n        \"\"\"\n        node_variable_dict = self.detect_node_variables(query)\n        paths = self.extract_paths(query)\n        for path in paths:\n            original_path = path\n            start_idx = 0\n            while start_idx < len(path):\n                match_res = re.match(self.node_relation_node_pattern, path[start_idx:])\n                if match_res is None:\n                    break\n                start_idx += match_res.start()\n                match_dict = match_res.groupdict()\n                left_node_labels = self.detect_labels(\n                    match_dict[\"left_node\"], node_variable_dict\n                )\n                right_node_labels = self.detect_labels(\n                    match_dict[\"right_node\"], node_variable_dict\n                )\n                end_idx = (\n                    start_idx\n                    + 4\n                    + len(match_dict[\"left_node\"])\n                    + len(match_dict[\"relation\"])\n                    + len(match_dict[\"right_node\"])\n                )\n                original_partial_path = original_path[start_idx : end_idx + 1]\n                relation_direction, relation_types = self.detect_relation_types(\n                    match_dict[\"relation\"]\n                )\n\n                if relation_types != [] and \"\".join(relation_types).find(\"*\") != -1:\n                    start_idx += (\n                        len(match_dict[\"left_node\"]) + len(match_dict[\"relation\"]) + 2\n                    )\n                    continue\n\n                if relation_direction == \"OUTGOING\":\n                    is_legal = self.verify_schema(\n                        left_node_labels, relation_types, right_node_labels\n                    )\n                    if not is_legal:\n                        is_legal = self.verify_schema(\n                            right_node_labels, relation_types, left_node_labels\n                        )\n                        if is_legal:\n                            corrected_relation = \"<\" + match_dict[\"relation\"][:-1]\n                            corrected_partial_path = original_partial_path.replace(\n                                match_dict[\"relation\"], corrected_relation\n                            )\n                            query = query.replace(\n                                original_partial_path, corrected_partial_path\n                            )\n                        else:\n                            return \"\"\n                elif relation_direction == \"INCOMING\":\n                    is_legal = self.verify_schema(\n                        right_node_labels, relation_types, left_node_labels\n                    )\n                    if not is_legal:\n                        is_legal = self.verify_schema(\n                            left_node_labels, relation_types, right_node_labels\n                        )\n                        if is_legal:\n                            corrected_relation = match_dict[\"relation\"][1:] + \">\"\n                            corrected_partial_path = original_partial_path.replace(\n                                match_dict[\"relation\"], corrected_relation\n                            )\n                            query = query.replace(\n                                original_partial_path, corrected_partial_path\n                            )\n                        else:\n                            return \"\"\n                else:\n                    is_legal = self.verify_schema(\n                        left_node_labels, relation_types, right_node_labels\n                    )\n                    is_legal |= self.verify_schema(\n                        right_node_labels, relation_types, left_node_labels\n                    )\n                    if not is_legal:\n                        return \"\"\n\n                start_idx += (\n                    len(match_dict[\"left_node\"]) + len(match_dict[\"relation\"]) + 2\n                )\n        return query","docstring":"Args:\n    query: cypher query","args":[{"arg":"self","type":null},{"arg":"query","type":"str"}],"return_type":"str","control_flow":[{"type":"for","lineno":171},{"type":"while","lineno":174},{"type":"if","lineno":176},{"type":"if","lineno":198},{"type":"if","lineno":204},{"type":"if","lineno":208},{"type":"if","lineno":212},{"type":"if","lineno":222},{"type":"if","lineno":226},{"type":"if","lineno":230},{"type":"if","lineno":247}],"reason":"It is about detection, validation, and correction of node and relation patterns in a Cypher query by analyzing paths, labels, and relation directions; then it switches relation directions if schemas are incompatible, ultimately returning a corrected or empty query.","reason_kor":"경로, 라벨, 관계 방향을 분석하여 Cypher 쿼리 내 노드 및 관계 패턴을 감지, 검증, 수정하며, 스키마가 호환되지 않을 경우 관계 방향을 전환하여 수정된 쿼리 또는 빈 쿼리를 반환합니다."},{"_key":"langchain_neo4j_chains_graph_qa_cypher_utils_py_detect_labels","_id":"nodes/langchain_neo4j_chains_graph_qa_cypher_utils_py_detect_labels","_rev":"_jzRpKyO---","type":"function","name":"detect_labels","defined_in":"langchain_neo4j_chains_graph_qa_cypher_utils_py","lineno":102,"source":"def detect_labels(\n        self, str_node: str, node_variable_dict: Dict[str, Any]\n    ) -> List[str]:\n        \"\"\"\n        Args:\n            str_node: node in string format\n            node_variable_dict: dictionary of node variables\n        \"\"\"\n        splitted_node = str_node.split(\":\")\n        variable = splitted_node[0]\n        labels = []\n        if variable in node_variable_dict:\n            labels = node_variable_dict[variable]\n        elif variable == \"\" and len(splitted_node) > 1:\n            labels = splitted_node[1:]\n        return labels","docstring":"Args:\n    str_node: node in string format\n    node_variable_dict: dictionary of node variables","args":[{"arg":"self","type":null},{"arg":"str_node","type":"str"},{"arg":"node_variable_dict","type":"Dict[str, Any]"}],"return_type":"List[str]","control_flow":[{"type":"if","lineno":113},{"type":"if","lineno":115}],"reason":"it is about string parsing and conditional logic to extract labels from either a dictionary or a colon-separated string based on the presence of a variable in the dictionary or the structure of the string.","reason_kor":"딕셔너리 내 변수 존재 여부나 문자열 구조에 따라 딕셔너리 또는 콜론으로 구분된 문자열에서 라벨을 추출하는 문자열 파싱 및 조건부 로직을 결합합니다."},{"_key":"langchain_neo4j_chains_graph_qa_cypher_utils_py_detect_node_variables","_id":"nodes/langchain_neo4j_chains_graph_qa_cypher_utils_py_detect_node_variables","_rev":"_jzRpKya---","type":"function","name":"detect_node_variables","defined_in":"langchain_neo4j_chains_graph_qa_cypher_utils_py","lineno":44,"source":"def detect_node_variables(self, query: str) -> Dict[str, List[str]]:\n        \"\"\"\n        Args:\n            query: cypher query\n        \"\"\"\n        nodes = re.findall(self.node_pattern, query)\n        nodes = [self.clean_node(node) for node in nodes]\n        res: Dict[str, Any] = {}\n        for node in nodes:\n            parts = node.split(\":\")\n            if parts == \"\":\n                continue\n            variable = parts[0]\n            if variable not in res:\n                res[variable] = []\n            res[variable] += parts[1:]\n        return res","docstring":"Args:\n    query: cypher query","args":[{"arg":"self","type":null},{"arg":"query","type":"str"}],"return_type":"Dict[str, List[str]]","control_flow":[{"type":"for","lineno":52},{"type":"if","lineno":54},{"type":"if","lineno":57}],"reason":"This method extracts node variables and their associated labels from a Cypher query string, returning a dictionary mapping variable names to lists of labels.","reason_kor":"Cypher 쿼리 문자열에서 노드 변수와 관련 라벨을 추출하여 변수 이름을 라벨 리스트에 매핑한 사전 형태로 반환하는 메서드입니다."},{"_key":"langchain_neo4j_chains_graph_qa_cypher_utils_py_detect_relation_types","_id":"nodes/langchain_neo4j_chains_graph_qa_cypher_utils_py_detect_relation_types","_rev":"_jzRpKym---","type":"function","name":"detect_relation_types","defined_in":"langchain_neo4j_chains_graph_qa_cypher_utils_py","lineno":149,"source":"def detect_relation_types(self, str_relation: str) -> Tuple[str, List[str]]:\n        \"\"\"\n        Args:\n            str_relation: relation in string format\n        \"\"\"\n        relation_direction = self.judge_direction(str_relation)\n        relation_type = self.relation_type_pattern.search(str_relation)\n        if relation_type is None or relation_type.group(\"relation_type\") is None:\n            return relation_direction, []\n        relation_types = [\n            t.strip().strip(\"!\")\n            for t in relation_type.group(\"relation_type\").split(\"|\")\n        ]\n        return relation_direction, relation_types","docstring":"Args:\n    str_relation: relation in string format","args":[{"arg":"self","type":null},{"arg":"str_relation","type":"str"}],"return_type":"Tuple[str, List[str]]","control_flow":[{"type":"if","lineno":156}],"reason":"This method analyzes a string representing a relationship in a Cypher query to determine its direction and extract the types of the relationship as a list.","reason_kor":"Cypher 쿼리 내 관계를 나타내는 문자열을 분석하여 방향을 판단하고, 관계 유형을 리스트 형태로 추출하는 메서드입니다."},{"_key":"langchain_neo4j_chains_graph_qa_cypher_utils_py_extract_node_variable","_id":"nodes/langchain_neo4j_chains_graph_qa_cypher_utils_py_extract_node_variable","_rev":"_jzRpKyy---","type":"function","name":"extract_node_variable","defined_in":"langchain_neo4j_chains_graph_qa_cypher_utils_py","lineno":91,"source":"def extract_node_variable(self, part: str) -> Optional[str]:\n        \"\"\"\n        Args:\n            part: node in string format\n        \"\"\"\n        part = part.lstrip(\"(\").rstrip(\")\")\n        idx = part.find(\":\")\n        if idx != -1:\n            part = part[:idx]\n        return None if part == \"\" else part","docstring":"Args:\n    part: node in string format","args":[{"arg":"self","type":null},{"arg":"part","type":"str"}],"return_type":"Optional[str]","control_flow":[{"type":"if","lineno":98}],"reason":"This method extracts the variable name of a node from its string representation, removing parentheses and any labels after a colon, returning the pure variable name or None if empty.","reason_kor":"노드의 문자열 표현에서 괄호와 콜론 뒤 라벨을 제거하여 변수 이름만 추출하고, 빈 문자열일 경우 None을 반환하는 메서드입니다."},{"_key":"langchain_neo4j_chains_graph_qa_cypher_utils_py_extract_paths","_id":"nodes/langchain_neo4j_chains_graph_qa_cypher_utils_py_extract_paths","_rev":"_jzRpKz----","type":"function","name":"extract_paths","defined_in":"langchain_neo4j_chains_graph_qa_cypher_utils_py","lineno":62,"source":"def extract_paths(self, query: str) -> \"List[str]\":\n        \"\"\"\n        Args:\n            query: cypher query\n        \"\"\"\n        paths = []\n        idx = 0\n        while matched := self.path_pattern.findall(query[idx:]):\n            matched = matched[0]\n            matched = [\n                m for i, m in enumerate(matched) if i not in [1, len(matched) - 1]\n            ]\n            path = \"\".join(matched)\n            idx = idx + query[idx:].find(path) + len(path) - len(matched[-1])\n            paths.append(path)\n        return paths","docstring":"Args:\n    query: cypher query","args":[{"arg":"self","type":null},{"arg":"query","type":"str"}],"return_type":"'List[str]'","control_flow":[{"type":"while","lineno":69}],"reason":"it is about a pattern matching loop with string slicing to extract specific path patterns from a cypher query, iteratively updating the index to find all occurrences while excluding certain matched segments based on their positions.","reason_kor":"패턴 매칭 루프와 문자열 슬라이싱을 결합하여 Cypher 쿼리에서 특정 경로 패턴을 반복적으로 추출하고, 위치에 따라 특정 매칭 세그먼트를 제외합니다."},{"_key":"langchain_neo4j_chains_graph_qa_cypher_utils_py_judge_direction","_id":"nodes/langchain_neo4j_chains_graph_qa_cypher_utils_py_judge_direction","_rev":"_jzRpKzK---","type":"function","name":"judge_direction","defined_in":"langchain_neo4j_chains_graph_qa_cypher_utils_py","lineno":79,"source":"def judge_direction(self, relation: str) -> str:\n        \"\"\"\n        Args:\n            relation: relation in string format\n        \"\"\"\n        direction = \"BIDIRECTIONAL\"\n        if relation[0] == \"<\":\n            direction = \"INCOMING\"\n        if relation[-1] == \">\":\n            direction = \"OUTGOING\"\n        return direction","docstring":"Args:\n    relation: relation in string format","args":[{"arg":"self","type":null},{"arg":"relation","type":"str"}],"return_type":"str","control_flow":[{"type":"if","lineno":85},{"type":"if","lineno":87}],"reason":"This method determines the direction of a relationship in a Cypher query string, returning 'INCOMING', 'OUTGOING', or 'BIDIRECTIONAL' based on the presence of directional arrows.","reason_kor":"Cypher 쿼리 문자열 내 관계의 방향을 판단하여, 방향성 화살표 존재 여부에 따라 'INCOMING', 'OUTGOING', 또는 'BIDIRECTIONAL'을 반환하는 메서드입니다."},{"_key":"langchain_neo4j_chains_graph_qa_cypher_utils_py_verify_schema","_id":"nodes/langchain_neo4j_chains_graph_qa_cypher_utils_py_verify_schema","_rev":"_jzRpKzW---","type":"function","name":"verify_schema","defined_in":"langchain_neo4j_chains_graph_qa_cypher_utils_py","lineno":119,"source":"def verify_schema(\n        self,\n        from_node_labels: List[str],\n        relation_types: List[str],\n        to_node_labels: List[str],\n    ) -> bool:\n        \"\"\"\n        Args:\n            from_node_labels: labels of the from node\n            relation_type: type of the relation\n            to_node_labels: labels of the to node\n        \"\"\"\n        valid_schemas = self.schemas\n        if from_node_labels != []:\n            from_node_labels = [label.strip(\"`\") for label in from_node_labels]\n            valid_schemas = [\n                schema for schema in valid_schemas if schema[0] in from_node_labels\n            ]\n        if to_node_labels != []:\n            to_node_labels = [label.strip(\"`\") for label in to_node_labels]\n            valid_schemas = [\n                schema for schema in valid_schemas if schema[2] in to_node_labels\n            ]\n        if relation_types != []:\n            relation_types = [type.strip(\"`\") for type in relation_types]\n            valid_schemas = [\n                schema for schema in valid_schemas if schema[1] in relation_types\n            ]\n        return valid_schemas != []","docstring":"Args:\n    from_node_labels: labels of the from node\n    relation_type: type of the relation\n    to_node_labels: labels of the to node","args":[{"arg":"self","type":null},{"arg":"from_node_labels","type":"List[str]"},{"arg":"relation_types","type":"List[str]"},{"arg":"to_node_labels","type":"List[str]"}],"return_type":"bool","control_flow":[{"type":"if","lineno":132},{"type":"if","lineno":137},{"type":"if","lineno":142}],"reason":"This method verifies whether a given combination of from-node labels, relation types, and to-node labels matches any valid schema in the stored schema list, returning True if a match exists.","reason_kor":"주어진 출발 노드 라벨, 관계 유형, 도착 노드 라벨의 조합이 저장된 스키마 목록 내 유효한 스키마와 일치하는지 검증하며, 일치하는 경우 True를 반환하는 메서드입니다."},{"_key":"langchain_neo4j_chains_graph_qa_prompts_py","_id":"nodes/langchain_neo4j_chains_graph_qa_prompts_py","_rev":"_jzRpA_a---","type":"file","name":"prompts.py","path":"C:\\workspace\\langchain-neo4j\\langchain_neo4j\\chains\\graph_qa\\prompts.py"},{"_key":"langchain_neo4j_chat_message_histories","_id":"nodes/langchain_neo4j_chat_message_histories","_rev":"_jzRpAAK---","type":"directory","name":"chat_message_histories","path":"C:\\workspace\\langchain-neo4j\\langchain_neo4j\\chat_message_histories"},{"_key":"langchain_neo4j_chat_message_histories___init___py","_id":"nodes/langchain_neo4j_chat_message_histories___init___py","_rev":"_jzRpAHG---","type":"file","name":"__init__.py","path":"C:\\workspace\\langchain-neo4j\\langchain_neo4j\\chat_message_histories\\__init__.py"},{"_key":"langchain_neo4j_chat_message_histories_neo4j_py","_id":"nodes/langchain_neo4j_chat_message_histories_neo4j_py","_rev":"_jzRpAAi---","type":"file","name":"neo4j.py","path":"C:\\workspace\\langchain-neo4j\\langchain_neo4j\\chat_message_histories\\neo4j.py"},{"_key":"langchain_neo4j_chat_message_histories_neo4j_py_Neo4jChatMessageHistory","_id":"nodes/langchain_neo4j_chat_message_histories_neo4j_py_Neo4jChatMessageHistory","_rev":"_jzRpKzm---","type":"class","name":"Neo4jChatMessageHistory","defined_in":"langchain_neo4j_chat_message_histories_neo4j_py","lineno":18,"docstring":"Chat message history stored in a Neo4j database.","source":"class Neo4jChatMessageHistory(BaseChatMessageHistory):\n    \"\"\"Chat message history stored in a Neo4j database.\"\"\"\n\n    def __init__(\n        self,\n        session_id: Union[str, int],\n        url: Optional[str] = None,\n        username: Optional[str] = None,\n        password: Optional[str] = None,\n        database: str = \"neo4j\",\n        node_label: str = \"Session\",\n        window: int = 3,\n        *,\n        graph: Optional[Neo4jGraph] = None,\n    ):\n        # Make sure session id is not null\n        if not session_id:\n            raise ValueError(\"Please ensure that the session_id parameter is provided\")\n\n        # Graph object takes precedent over env or input params\n        if graph:\n            self._driver = graph._driver\n            self._database = graph._database\n        else:\n            # Handle if the credentials are environment variables\n            url = get_from_dict_or_env({\"url\": url}, \"url\", \"NEO4J_URI\")\n            username = get_from_dict_or_env(\n                {\"username\": username}, \"username\", \"NEO4J_USERNAME\"\n            )\n            password = get_from_dict_or_env(\n                {\"password\": password}, \"password\", \"NEO4J_PASSWORD\"\n            )\n            database = get_from_dict_or_env(\n                {\"database\": database}, \"database\", \"NEO4J_DATABASE\", \"neo4j\"\n            )\n\n            self._driver = neo4j.GraphDatabase.driver(url, auth=(username, password))\n            self._database = database\n            # Verify connection\n            try:\n                self._driver.verify_connectivity()\n            except neo4j.exceptions.ServiceUnavailable:\n                raise ValueError(\n                    \"Could not connect to Neo4j database. \"\n                    \"Please ensure that the url is correct\"\n                )\n            except neo4j.exceptions.AuthError:\n                raise ValueError(\n                    \"Could not connect to Neo4j database. \"\n                    \"Please ensure that the username and password are correct\"\n                )\n        self._session_id = session_id\n        self._node_label = node_label\n        self._window = window\n        # Create session node\n        self._driver.execute_query(\n            CREATE_SESSION_NODE_QUERY.format(node_label=self._node_label),\n            {\"session_id\": self._session_id},\n        )\n\n    @property\n    def messages(self) -> List[BaseMessage]:\n        \"\"\"Retrieve the messages from Neo4j\"\"\"\n        records, _, _ = self._driver.execute_query(\n            GET_MESSAGES_QUERY.format(\n                node_label=self._node_label, window=self._window * 2\n            ),\n            {\"session_id\": self._session_id},\n        )\n        messages = [\n            {\n                \"data\": el[\"result\"][\"data\"],\n                \"type\": el[\"result\"][\"role\"],\n            }\n            for el in records\n        ]\n        return messages_from_dict(messages)\n\n    @messages.setter\n    def messages(self, messages: List[BaseMessage]) -> None:\n        raise NotImplementedError(\n            \"Direct assignment to 'messages' is not allowed.\"\n            \" Use the 'add_messages' instead.\"\n        )\n\n    def add_message(self, message: BaseMessage) -> None:\n        \"\"\"Append the message to the record in Neo4j\"\"\"\n        self._driver.execute_query(\n            ADD_MESSAGE_QUERY.format(node_label=self._node_label),\n            {\n                \"role\": message.type,\n                \"content\": message.content,\n                \"session_id\": self._session_id,\n            },\n        )\n\n    def clear(self, delete_session_node: bool = False) -> None:\n        \"\"\"Clear session memory from Neo4j\n\n        Args:\n            delete_session_node (bool): Whether to delete the session node.\n                Defaults to False.\n        \"\"\"\n        if delete_session_node:\n            self._driver.execute_query(\n                query_=DELETE_SESSION_AND_MESSAGES_QUERY.format(\n                    node_label=self._node_label\n                ),\n                parameters_={\"session_id\": self._session_id},\n            )\n        else:\n            self._driver.execute_query(\n                query_=DELETE_MESSAGES_QUERY.format(node_label=self._node_label),\n                parameters_={\"session_id\": self._session_id},\n            )\n\n    def __del__(self) -> None:\n        if self._driver:\n            self._driver.close()","inst_variables":[{"var":"_session_id","type":null,"value":"session_id","lineno":69},{"var":"_node_label","type":null,"value":"node_label","lineno":70},{"var":"_window","type":null,"value":"window","lineno":71},{"var":"_driver","type":null,"value":"graph._driver","lineno":39},{"var":"_database","type":null,"value":"graph._database","lineno":40},{"var":"_driver","type":null,"value":"neo4j.GraphDatabase.driver(url, auth=(username, password))","lineno":54},{"var":"_database","type":null,"value":"database","lineno":55}],"reason":"This class manages chat message history stored in a Neo4j database, providing methods to initialize the session, add messages, retrieve message history, clear messages, and properly close the database connection.","reason_kor":"Neo4j 데이터베이스에 저장된 채팅 메시지 이력을 관리하는 클래스이며, 세션 초기화, 메시지 추가, 메시지 기록 조회, 메시지 삭제, 데이터베이스 연결 종료 기능을 제공합니다."},{"_key":"langchain_neo4j_chat_message_histories_neo4j_py___del__","_id":"nodes/langchain_neo4j_chat_message_histories_neo4j_py___del__","_rev":"_jzRpKzy---","type":"function","name":"__del__","defined_in":"langchain_neo4j_chat_message_histories_neo4j_py","lineno":134,"source":"def __del__(self) -> None:\n        if self._driver:\n            self._driver.close()","docstring":null,"args":[{"arg":"self","type":null}],"return_type":"None","control_flow":[{"type":"if","lineno":135}],"reason":"This destructor method ensures that the Neo4j database driver connection is properly closed when the Neo4jChatMessageHistory instance is deleted.","reason_kor":"Neo4jChatMessageHistory 인스턴스가 삭제될 때 Neo4j 데이터베이스 드라이버 연결이 적절히 종료되도록 하는 소멸자 메서드입니다."},{"_key":"langchain_neo4j_chat_message_histories_neo4j_py___init__","_id":"nodes/langchain_neo4j_chat_message_histories_neo4j_py___init__","_rev":"_jzRpK0C---","type":"function","name":"__init__","defined_in":"langchain_neo4j_chat_message_histories_neo4j_py","lineno":21,"source":"def __init__(\n        self,\n        session_id: Union[str, int],\n        url: Optional[str] = None,\n        username: Optional[str] = None,\n        password: Optional[str] = None,\n        database: str = \"neo4j\",\n        node_label: str = \"Session\",\n        window: int = 3,\n        *,\n        graph: Optional[Neo4jGraph] = None,\n    ):\n        # Make sure session id is not null\n        if not session_id:\n            raise ValueError(\"Please ensure that the session_id parameter is provided\")\n\n        # Graph object takes precedent over env or input params\n        if graph:\n            self._driver = graph._driver\n            self._database = graph._database\n        else:\n            # Handle if the credentials are environment variables\n            url = get_from_dict_or_env({\"url\": url}, \"url\", \"NEO4J_URI\")\n            username = get_from_dict_or_env(\n                {\"username\": username}, \"username\", \"NEO4J_USERNAME\"\n            )\n            password = get_from_dict_or_env(\n                {\"password\": password}, \"password\", \"NEO4J_PASSWORD\"\n            )\n            database = get_from_dict_or_env(\n                {\"database\": database}, \"database\", \"NEO4J_DATABASE\", \"neo4j\"\n            )\n\n            self._driver = neo4j.GraphDatabase.driver(url, auth=(username, password))\n            self._database = database\n            # Verify connection\n            try:\n                self._driver.verify_connectivity()\n            except neo4j.exceptions.ServiceUnavailable:\n                raise ValueError(\n                    \"Could not connect to Neo4j database. \"\n                    \"Please ensure that the url is correct\"\n                )\n            except neo4j.exceptions.AuthError:\n                raise ValueError(\n                    \"Could not connect to Neo4j database. \"\n                    \"Please ensure that the username and password are correct\"\n                )\n        self._session_id = session_id\n        self._node_label = node_label\n        self._window = window\n        # Create session node\n        self._driver.execute_query(\n            CREATE_SESSION_NODE_QUERY.format(node_label=self._node_label),\n            {\"session_id\": self._session_id},\n        )","docstring":null,"args":[{"arg":"self","type":null},{"arg":"session_id","type":"Union[str, int]"},{"arg":"url","type":"Optional[str]"},{"arg":"username","type":"Optional[str]"},{"arg":"password","type":"Optional[str]"},{"arg":"database","type":"str"},{"arg":"node_label","type":"str"},{"arg":"window","type":"int"}],"return_type":null,"control_flow":[{"type":"if","lineno":34},{"type":"if","lineno":38},{"type":"try","lineno":57}],"reason_kor":"파라미터 검증, 환경 변수 처리, 오류 처리와 함께 연결 설정 및 Neo4j 그래프 데이터베이스 세션 내 세션 노드 생성을 생성자 메서드 내에서 수행합니다.","reason":"it is about parameter validation, environment variable handling, connection setup with error handling, and session node creation in a constructor method for managing Neo4j graph database sessions."},{"_key":"langchain_neo4j_chat_message_histories_neo4j_py_add_message","_id":"nodes/langchain_neo4j_chat_message_histories_neo4j_py_add_message","_rev":"_jzRpK0O---","type":"function","name":"add_message","defined_in":"langchain_neo4j_chat_message_histories_neo4j_py","lineno":103,"source":"def add_message(self, message: BaseMessage) -> None:\n        \"\"\"Append the message to the record in Neo4j\"\"\"\n        self._driver.execute_query(\n            ADD_MESSAGE_QUERY.format(node_label=self._node_label),\n            {\n                \"role\": message.type,\n                \"content\": message.content,\n                \"session_id\": self._session_id,\n            },\n        )","docstring":"Append the message to the record in Neo4j","args":[{"arg":"self","type":null},{"arg":"message","type":"BaseMessage"}],"return_type":"None","control_flow":[],"reason_kor":"설정된 노드 라벨 아래 메시지 내용, 역할, 세션 정보를 저장하는 쿼리를 실행하여 Neo4j 데이터베이스에 채팅 메시지를 추가하는 메서드입니다.","reason":"This method appends a chat message to the Neo4j database by executing a query that stores the message content, role, and session information under the configured node label."},{"_key":"langchain_neo4j_chat_message_histories_neo4j_py_clear","_id":"nodes/langchain_neo4j_chat_message_histories_neo4j_py_clear","_rev":"_jzRpK0a---","type":"function","name":"clear","defined_in":"langchain_neo4j_chat_message_histories_neo4j_py","lineno":114,"source":"def clear(self, delete_session_node: bool = False) -> None:\n        \"\"\"Clear session memory from Neo4j\n\n        Args:\n            delete_session_node (bool): Whether to delete the session node.\n                Defaults to False.\n        \"\"\"\n        if delete_session_node:\n            self._driver.execute_query(\n                query_=DELETE_SESSION_AND_MESSAGES_QUERY.format(\n                    node_label=self._node_label\n                ),\n                parameters_={\"session_id\": self._session_id},\n            )\n        else:\n            self._driver.execute_query(\n                query_=DELETE_MESSAGES_QUERY.format(node_label=self._node_label),\n                parameters_={\"session_id\": self._session_id},\n            )","docstring":"Clear session memory from Neo4j\n\nArgs:\n    delete_session_node (bool): Whether to delete the session node.\n        Defaults to False.","args":[{"arg":"self","type":null},{"arg":"delete_session_node","type":"bool"}],"return_type":"None","control_flow":[{"type":"if","lineno":121}],"reason_kor":"Neo4j 데이터베이스에서 채팅 세션 메시지를 삭제하며, 옵션으로 전체 세션 노드까지 삭제할 수 있는 메서드입니다.","reason":"This method clears chat session messages from the Neo4j database, optionally deleting the entire session node if specified."},{"_key":"langchain_neo4j_chat_message_histories_neo4j_py_messages","_id":"nodes/langchain_neo4j_chat_message_histories_neo4j_py_messages","_rev":"_jzRpK0m---","type":"function","name":"messages","defined_in":"langchain_neo4j_chat_message_histories_neo4j_py","lineno":97,"source":"def messages(self, messages: List[BaseMessage]) -> None:\n        raise NotImplementedError(\n            \"Direct assignment to 'messages' is not allowed.\"\n            \" Use the 'add_messages' instead.\"\n        )","docstring":null,"args":[{"arg":"self","type":null},{"arg":"messages","type":"List[BaseMessage]"}],"return_type":"None","control_flow":[],"reason_kor":"'messages' 속성에 직접 할당을 방지하기 위해 NotImplementedError를 발생시키는 메서드 정의를 결합하며, 대신 'add_messages' 사용을 안내합니다.","reason":"it is about a method definition that raises a NotImplementedError to prevent direct assignment to the 'messages' attribute, instructing users to use 'add_messages' instead."},{"_key":"langchain_neo4j_graphs","_id":"nodes/langchain_neo4j_graphs","_rev":"_jzRpAHm---","type":"directory","name":"graphs","path":"C:\\workspace\\langchain-neo4j\\langchain_neo4j\\graphs"},{"_key":"langchain_neo4j_graphs___init___py","_id":"nodes/langchain_neo4j_graphs___init___py","_rev":"_jzRpAbq---","type":"file","name":"__init__.py","path":"C:\\workspace\\langchain-neo4j\\langchain_neo4j\\graphs\\__init__.py"},{"_key":"langchain_neo4j_graphs_graph_document_py","_id":"nodes/langchain_neo4j_graphs_graph_document_py","_rev":"_jzRpAI----","type":"file","name":"graph_document.py","path":"C:\\workspace\\langchain-neo4j\\langchain_neo4j\\graphs\\graph_document.py"},{"_key":"langchain_neo4j_graphs_graph_document_py_GraphDocument","_id":"nodes/langchain_neo4j_graphs_graph_document_py_GraphDocument","_rev":"_jzRpK0y---","type":"class","name":"GraphDocument","defined_in":"langchain_neo4j_graphs_graph_document_py","lineno":40,"docstring":"Represents a graph document consisting of nodes and relationships.\n\nAttributes:\n    nodes (List[Node]): A list of nodes in the graph.\n    relationships (List[Relationship]): A list of relationships in the graph.\n    source (Optional[Document]): The document from which the graph information is\n        derived.","source":"class GraphDocument(Serializable):\n    \"\"\"Represents a graph document consisting of nodes and relationships.\n\n    Attributes:\n        nodes (List[Node]): A list of nodes in the graph.\n        relationships (List[Relationship]): A list of relationships in the graph.\n        source (Optional[Document]): The document from which the graph information is\n            derived.\n    \"\"\"\n\n    nodes: List[Node]\n    relationships: List[Relationship]\n    source: Optional[Document] = None","inst_variables":[],"reason_kor":"노드와 관계로 구성된 그래프 문서를 나타내며, 그래프 데이터의 출처가 되는 문서를 선택적으로 연결할 수 있는 클래스입니다.","reason":"This class represents a graph document comprising nodes and relationships, optionally linked to a source document that provides the origin of the graph data."},{"_key":"langchain_neo4j_graphs_graph_document_py_Node","_id":"nodes/langchain_neo4j_graphs_graph_document_py_Node","_rev":"_jzRpK1C---","type":"class","name":"Node","defined_in":"langchain_neo4j_graphs_graph_document_py","lineno":10,"docstring":"Represents a node in a graph with associated properties.\n\nAttributes:\n    id (Union[str, int]): A unique identifier for the node.\n    type (str): The type or label of the node, default is \"Node\".\n    properties (dict): Additional properties and metadata associated with the node.","source":"class Node(Serializable):\n    \"\"\"Represents a node in a graph with associated properties.\n\n    Attributes:\n        id (Union[str, int]): A unique identifier for the node.\n        type (str): The type or label of the node, default is \"Node\".\n        properties (dict): Additional properties and metadata associated with the node.\n    \"\"\"\n\n    id: Union[str, int]\n    type: str = \"Node\"\n    properties: dict = Field(default_factory=dict)","inst_variables":[],"reason_kor":"그래프 구조 내의 노드를 나타내는 클래스이며, 고유한 ID와 타입 레이블을 가지며, 연관된 속성들을 딕셔너리 형태로 포함합니다.","reason":"This class represents a node within a graph structure, uniquely identified by an ID, having a type label, and containing associated properties in a dictionary."},{"_key":"langchain_neo4j_graphs_graph_document_py_Relationship","_id":"nodes/langchain_neo4j_graphs_graph_document_py_Relationship","_rev":"_jzRpK1O---","type":"class","name":"Relationship","defined_in":"langchain_neo4j_graphs_graph_document_py","lineno":24,"docstring":"Represents a directed relationship between two nodes in a graph.\n\nAttributes:\n    source (Node): The source node of the relationship.\n    target (Node): The target node of the relationship.\n    type (str): The type of the relationship.\n    properties (dict): Additional properties associated with the relationship.","source":"class Relationship(Serializable):\n    \"\"\"Represents a directed relationship between two nodes in a graph.\n\n    Attributes:\n        source (Node): The source node of the relationship.\n        target (Node): The target node of the relationship.\n        type (str): The type of the relationship.\n        properties (dict): Additional properties associated with the relationship.\n    \"\"\"\n\n    source: Node\n    target: Node\n    type: str\n    properties: dict = Field(default_factory=dict)","inst_variables":[],"reason_kor":"그래프 내 두 노드 간의 방향성 있는 관계를 모델링하는 클래스이며, 출발 노드와 도착 노드, 관계 유형 및 추가 속성을 명시합니다.","reason":"This class models a directed relationship between two nodes in a graph, specifying the source and target nodes, the relationship type, and any additional properties."},{"_key":"langchain_neo4j_graphs_graph_store_py","_id":"nodes/langchain_neo4j_graphs_graph_store_py","_rev":"_jzRpAJy---","type":"file","name":"graph_store.py","path":"C:\\workspace\\langchain-neo4j\\langchain_neo4j\\graphs\\graph_store.py"},{"_key":"langchain_neo4j_graphs_graph_store_py_GraphStore","_id":"nodes/langchain_neo4j_graphs_graph_store_py_GraphStore","_rev":"_jzRpK1a---","type":"class","name":"GraphStore","defined_in":"langchain_neo4j_graphs_graph_store_py","lineno":7,"docstring":"Abstract class for graph operations.","source":"class GraphStore(Protocol):\n    \"\"\"Abstract class for graph operations.\"\"\"\n\n    @property\n    def get_schema(self) -> str:\n        \"\"\"Return the schema of the Graph database\"\"\"\n        ...\n\n    @property\n    def get_structured_schema(self) -> Dict[str, Any]:\n        \"\"\"Return the schema of the Graph database\"\"\"\n        ...\n\n    def query(self, query: str, params: dict = {}) -> List[Dict[str, Any]]:\n        \"\"\"Query the graph.\"\"\"\n        ...\n\n    def refresh_schema(self) -> None:\n        \"\"\"Refresh the graph schema information.\"\"\"\n        ...\n\n    def add_graph_documents(\n        self, graph_documents: List[GraphDocument], include_source: bool = False\n    ) -> None:\n        \"\"\"Take GraphDocument as input as uses it to construct a graph.\"\"\"\n        ...","inst_variables":[],"reason_kor":"그래프 연산을 위한 인터페이스를 정의하는 추상 프로토콜 클래스이며, 스키마 조회, 그래프 쿼리, 스키마 갱신, 그래프 문서 추가 등의 기능을 포함합니다.","reason":"An abstract protocol class defining the interface for graph operations such as retrieving schema information, querying the graph, refreshing schema, and adding graph documents."},{"_key":"langchain_neo4j_graphs_graph_store_py_add_graph_documents","_id":"nodes/langchain_neo4j_graphs_graph_store_py_add_graph_documents","_rev":"_jzRpK1m---","type":"function","name":"add_graph_documents","defined_in":"langchain_neo4j_graphs_graph_store_py","lineno":28,"source":"def add_graph_documents(\n        self, graph_documents: List[GraphDocument], include_source: bool = False\n    ) -> None:\n        \"\"\"Take GraphDocument as input as uses it to construct a graph.\"\"\"\n        ...","docstring":"Take GraphDocument as input as uses it to construct a graph.","args":[{"arg":"self","type":null},{"arg":"graph_documents","type":"List[GraphDocument]"},{"arg":"include_source","type":"bool"}],"return_type":"None","control_flow":[],"reason_kor":"GraphDocument 객체 리스트를 받아 이를 사용하여 그래프 구조를 생성하거나 업데이트하는 메서드입니다.","reason":"Method to ingest a list of GraphDocument objects and use them to construct or update the graph structure in the data store."},{"_key":"langchain_neo4j_graphs_graph_store_py_get_schema","_id":"nodes/langchain_neo4j_graphs_graph_store_py_get_schema","_rev":"_jzRpK1y---","type":"function","name":"get_schema","defined_in":"langchain_neo4j_graphs_graph_store_py","lineno":11,"source":"def get_schema(self) -> str:\n        \"\"\"Return the schema of the Graph database\"\"\"\n        ...","docstring":"Return the schema of the Graph database","args":[{"arg":"self","type":null}],"return_type":"str","control_flow":[],"reason_kor":"그래프 데이터베이스의 스키마를 문자열 형태로 반환하는 메서드입니다.","reason":"Method to return the graph database schema as a string representation."},{"_key":"langchain_neo4j_graphs_graph_store_py_get_structured_schema","_id":"nodes/langchain_neo4j_graphs_graph_store_py_get_structured_schema","_rev":"_jzRpK2----","type":"function","name":"get_structured_schema","defined_in":"langchain_neo4j_graphs_graph_store_py","lineno":16,"source":"def get_structured_schema(self) -> Dict[str, Any]:\n        \"\"\"Return the schema of the Graph database\"\"\"\n        ...","docstring":"Return the schema of the Graph database","args":[{"arg":"self","type":null}],"return_type":"Dict[str, Any]","control_flow":[],"reason_kor":"그래프 데이터베이스의 스키마를 구조화된 딕셔너리 형태로 반환하는 메서드입니다.","reason":"Method to return the graph database schema in a structured dictionary format."},{"_key":"langchain_neo4j_graphs_graph_store_py_query","_id":"nodes/langchain_neo4j_graphs_graph_store_py_query","_rev":"_jzRpK2K---","type":"function","name":"query","defined_in":"langchain_neo4j_graphs_graph_store_py","lineno":20,"source":"def query(self, query: str, params: dict = {}) -> List[Dict[str, Any]]:\n        \"\"\"Query the graph.\"\"\"\n        ...","docstring":"Query the graph.","args":[{"arg":"self","type":null},{"arg":"query","type":"str"},{"arg":"params","type":"dict"}],"return_type":"List[Dict[str, Any]]","control_flow":[],"reason_kor":"그래프 데이터베이스에서 Cypher 쿼리를 실행하고 결과를 딕셔너리 리스트로 반환하는 메서드입니다.","reason":"Method to execute a Cypher query on the graph database and return the results as a list of dictionaries."},{"_key":"langchain_neo4j_graphs_graph_store_py_refresh_schema","_id":"nodes/langchain_neo4j_graphs_graph_store_py_refresh_schema","_rev":"_jzRpK2W---","type":"function","name":"refresh_schema","defined_in":"langchain_neo4j_graphs_graph_store_py","lineno":24,"source":"def refresh_schema(self) -> None:\n        \"\"\"Refresh the graph schema information.\"\"\"\n        ...","docstring":"Refresh the graph schema information.","args":[{"arg":"self","type":null}],"return_type":"None","control_flow":[],"reason_kor":"그래프 데이터베이스의 스키마 정보를 갱신하거나 업데이트하는 메서드입니다.","reason":"Method to refresh or update the schema information of the graph database."},{"_key":"langchain_neo4j_graphs_neo4j_graph_py","_id":"nodes/langchain_neo4j_graphs_neo4j_graph_py","_rev":"_jzRpAMu---","type":"file","name":"neo4j_graph.py","path":"C:\\workspace\\langchain-neo4j\\langchain_neo4j\\graphs\\neo4j_graph.py"},{"_key":"langchain_neo4j_graphs_neo4j_graph_py_Neo4jGraph","_id":"nodes/langchain_neo4j_graphs_neo4j_graph_py_Neo4jGraph","_rev":"_jzRpK2i---","type":"class","name":"Neo4jGraph","defined_in":"langchain_neo4j_graphs_neo4j_graph_py","lineno":75,"docstring":"Neo4j database wrapper for various graph operations.\n\nParameters:\nurl (Optional[str]): The URL of the Neo4j database server.\nusername (Optional[str]): The username for database authentication.\npassword (Optional[str]): The password for database authentication.\ndatabase (str): The name of the database to connect to. Default is 'neo4j'.\ntimeout (Optional[float]): The timeout for transactions in seconds.\n        Useful for terminating long-running queries.\n        By default, there is no timeout set.\nsanitize (bool): A flag to indicate whether to remove lists with\n        more than 128 elements from results. Useful for removing\n        embedding-like properties from database responses. Default is False.\nrefresh_schema (bool): A flag whether to refresh schema information\n        at initialization. Default is True.\nenhanced_schema (bool): A flag whether to scan the database for\n        example values and use them in the graph schema. Default is False.\ndriver_config (Dict): Configuration passed to Neo4j Driver.\n\n*Security note*: Make sure that the database connection uses credentials\n    that are narrowly-scoped to only include necessary permissions.\n    Failure to do so may result in data corruption or loss, since the calling\n    code may attempt commands that would result in deletion, mutation\n    of data if appropriately prompted or reading sensitive data if such\n    data is present in the database.\n    The best way to guard against such negative outcomes is to (as appropriate)\n    limit the permissions granted to the credentials used with this tool.\n\n    See https://python.langchain.com/docs/security for more information.","source":"class Neo4jGraph(GraphStore):\n    \"\"\"Neo4j database wrapper for various graph operations.\n\n    Parameters:\n    url (Optional[str]): The URL of the Neo4j database server.\n    username (Optional[str]): The username for database authentication.\n    password (Optional[str]): The password for database authentication.\n    database (str): The name of the database to connect to. Default is 'neo4j'.\n    timeout (Optional[float]): The timeout for transactions in seconds.\n            Useful for terminating long-running queries.\n            By default, there is no timeout set.\n    sanitize (bool): A flag to indicate whether to remove lists with\n            more than 128 elements from results. Useful for removing\n            embedding-like properties from database responses. Default is False.\n    refresh_schema (bool): A flag whether to refresh schema information\n            at initialization. Default is True.\n    enhanced_schema (bool): A flag whether to scan the database for\n            example values and use them in the graph schema. Default is False.\n    driver_config (Dict): Configuration passed to Neo4j Driver.\n\n    *Security note*: Make sure that the database connection uses credentials\n        that are narrowly-scoped to only include necessary permissions.\n        Failure to do so may result in data corruption or loss, since the calling\n        code may attempt commands that would result in deletion, mutation\n        of data if appropriately prompted or reading sensitive data if such\n        data is present in the database.\n        The best way to guard against such negative outcomes is to (as appropriate)\n        limit the permissions granted to the credentials used with this tool.\n\n        See https://python.langchain.com/docs/security for more information.\n    \"\"\"\n\n    def __init__(\n        self,\n        url: Optional[str] = None,\n        username: Optional[str] = None,\n        password: Optional[str] = None,\n        database: Optional[str] = None,\n        timeout: Optional[float] = None,\n        sanitize: bool = False,\n        refresh_schema: bool = True,\n        *,\n        driver_config: Optional[Dict] = None,\n        enhanced_schema: bool = False,\n    ) -> None:\n        \"\"\"Create a new Neo4j graph wrapper instance.\"\"\"\n\n        url = get_from_dict_or_env({\"url\": url}, \"url\", \"NEO4J_URI\")\n        # if username and password are \"\", assume Neo4j auth is disabled\n        if username == \"\" and password == \"\":\n            auth = None\n        else:\n            username = get_from_dict_or_env(\n                {\"username\": username},\n                \"username\",\n                \"NEO4J_USERNAME\",\n            )\n            password = get_from_dict_or_env(\n                {\"password\": password},\n                \"password\",\n                \"NEO4J_PASSWORD\",\n            )\n            auth = (username, password)\n        database = get_from_dict_or_env(\n            {\"database\": database}, \"database\", \"NEO4J_DATABASE\", \"neo4j\"\n        )\n\n        self._driver = neo4j.GraphDatabase.driver(\n            url, auth=auth, **(driver_config or {})\n        )\n        self._database = database\n        self.timeout = timeout\n        self.sanitize = sanitize\n        self._enhanced_schema = enhanced_schema\n        self.schema: str = \"\"\n        self.structured_schema: Dict[str, Any] = {}\n        # Verify connection\n        try:\n            self._driver.verify_connectivity()\n        except neo4j.exceptions.ConfigurationError:\n            raise ValueError(\n                \"Could not connect to Neo4j database. \"\n                \"Please ensure that the driver config is correct\"\n            )\n        except neo4j.exceptions.ServiceUnavailable:\n            raise ValueError(\n                \"Could not connect to Neo4j database. \"\n                \"Please ensure that the url is correct\"\n            )\n        except neo4j.exceptions.AuthError:\n            raise ValueError(\n                \"Could not connect to Neo4j database. \"\n                \"Please ensure that the username and password are correct\"\n            )\n        # Set schema\n        if refresh_schema:\n            try:\n                self.refresh_schema()\n            except neo4j.exceptions.ClientError as e:\n                if e.code == \"Neo.ClientError.Procedure.ProcedureNotFound\":\n                    raise ValueError(\n                        \"Could not use APOC procedures. \"\n                        \"Please ensure the APOC plugin is installed in Neo4j and that \"\n                        \"'apoc.meta.data()' is allowed in Neo4j configuration \"\n                    )\n                raise e\n\n    def _check_driver_state(self) -> None:\n        \"\"\"\n        Check if the driver is available and ready for operations.\n\n        Raises:\n            RuntimeError: If the driver has been closed or is not initialized.\n        \"\"\"\n        if not hasattr(self, \"_driver\"):\n            raise RuntimeError(\n                \"Cannot perform operations - Neo4j connection has been closed\"\n            )\n\n    @property\n    def get_schema(self) -> str:\n        \"\"\"Returns the schema of the Graph\"\"\"\n        return self.schema\n\n    @property\n    def get_structured_schema(self) -> Dict[str, Any]:\n        \"\"\"Returns the structured schema of the Graph\"\"\"\n        return self.structured_schema\n\n    def query(\n        self,\n        query: str,\n        params: dict = {},\n        session_params: dict = {},\n    ) -> List[Dict[str, Any]]:\n        \"\"\"Query Neo4j database.\n\n        Args:\n            query (str): The Cypher query to execute.\n            params (dict): The parameters to pass to the query.\n            session_params (dict): Parameters to pass to the session used for executing\n                the query.\n\n        Returns:\n            List[Dict[str, Any]]: The list of dictionaries containing the query results.\n\n        Raises:\n            RuntimeError: If the connection has been closed.\n        \"\"\"\n        self._check_driver_state()\n        from neo4j import Query\n        from neo4j.exceptions import Neo4jError\n\n        if not session_params:\n            try:\n                data, _, _ = self._driver.execute_query(\n                    Query(text=query, timeout=self.timeout),\n                    database_=self._database,\n                    parameters_=params,\n                )\n                json_data = [r.data() for r in data]\n                if self.sanitize:\n                    json_data = [_value_sanitize(el) for el in json_data]\n                return json_data\n            except Neo4jError as e:\n                if not (\n                    (\n                        (  # isCallInTransactionError\n                            e.code == \"Neo.DatabaseError.Statement.ExecutionFailed\"\n                            or e.code\n                            == \"Neo.DatabaseError.Transaction.TransactionStartFailed\"\n                        )\n                        and e.message is not None\n                        and \"in an implicit transaction\" in e.message\n                    )\n                    or (  # isPeriodicCommitError\n                        e.code == \"Neo.ClientError.Statement.SemanticError\"\n                        and e.message is not None\n                        and (\n                            \"in an open transaction is not possible\" in e.message\n                            or \"tried to execute in an explicit transaction\"\n                            in e.message\n                        )\n                    )\n                ):\n                    raise\n        # fallback to allow implicit transactions\n        session_params.setdefault(\"database\", self._database)\n        with self._driver.session(**session_params) as session:\n            result = session.run(Query(text=query, timeout=self.timeout), params)\n            json_data = [r.data() for r in result]\n            if self.sanitize:\n                json_data = [_value_sanitize(el) for el in json_data]\n            return json_data\n\n    def refresh_schema(self) -> None:\n        \"\"\"\n        Refreshes the Neo4j graph schema information.\n\n        Raises:\n            RuntimeError: If the connection has been closed.\n        \"\"\"\n        self._check_driver_state()\n        self.structured_schema = get_structured_schema(\n            driver=self._driver,\n            is_enhanced=self._enhanced_schema,\n            database=self._database,\n            timeout=self.timeout,\n            sanitize=self.sanitize,\n        )\n        self.schema = format_schema(\n            schema=self.structured_schema, is_enhanced=self._enhanced_schema\n        )\n\n    def add_graph_documents(\n        self,\n        graph_documents: List[GraphDocument],\n        include_source: bool = False,\n        baseEntityLabel: bool = False,\n    ) -> None:\n        \"\"\"\n        This method constructs nodes and relationships in the graph based on the\n        provided GraphDocument objects.\n\n        Parameters:\n        - graph_documents (List[GraphDocument]): A list of GraphDocument objects\n        that contain the nodes and relationships to be added to the graph. Each\n        GraphDocument should encapsulate the structure of part of the graph,\n        including nodes, relationships, and optionally the source document information.\n        - include_source (bool, optional): If True, stores the source document\n        and links it to nodes in the graph using the MENTIONS relationship.\n        This is useful for tracing back the origin of data. Merges source\n        documents based on the `id` property from the source document metadata\n        if available; otherwise it calculates the MD5 hash of `page_content`\n        for merging process. Defaults to False.\n        - baseEntityLabel (bool, optional): If True, each newly created node\n        gets a secondary __Entity__ label, which is indexed and improves import\n        speed and performance. Defaults to False.\n\n        Raises:\n            RuntimeError: If the connection has been closed.\n        \"\"\"\n        self._check_driver_state()\n        if baseEntityLabel:  # Check if constraint already exists\n            constraint_exists = any(\n                [\n                    el[\"labelsOrTypes\"] == [BASE_ENTITY_LABEL]\n                    and el[\"properties\"] == [\"id\"]\n                    for el in self.structured_schema.get(\"metadata\", {}).get(\n                        \"constraint\", []\n                    )\n                ]\n            )\n\n            if not constraint_exists:\n                # Create constraint\n                self.query(\n                    f\"CREATE CONSTRAINT IF NOT EXISTS FOR (b:{BASE_ENTITY_LABEL}) \"\n                    \"REQUIRE b.id IS UNIQUE;\"\n                )\n                self.refresh_schema()  # Refresh constraint information\n\n        # Check each graph_document has a source when include_source is true\n        if include_source:\n            for doc in graph_documents:\n                if doc.source is None:\n                    raise TypeError(\n                        \"include_source is set to True, \"\n                        \"but at least one document has no `source`.\"\n                    )\n\n        node_import_query = _get_node_import_query(baseEntityLabel, include_source)\n        rel_import_query = _get_rel_import_query(baseEntityLabel)\n        for document in graph_documents:\n            node_import_query_params: dict[str, Any] = {\n                \"data\": [el.__dict__ for el in document.nodes]\n            }\n            if include_source and document.source:\n                if not document.source.metadata.get(\"id\"):\n                    document.source.metadata[\"id\"] = md5(\n                        document.source.page_content.encode(\"utf-8\")\n                    ).hexdigest()\n                node_import_query_params[\"document\"] = document.source.__dict__\n\n            # Remove backticks from node types\n            for node in document.nodes:\n                node.type = _remove_backticks(node.type)\n            # Import nodes\n            self.query(node_import_query, node_import_query_params)\n            # Import relationships\n            self.query(\n                rel_import_query,\n                {\n                    \"data\": [\n                        {\n                            \"source\": el.source.id,\n                            \"source_label\": _remove_backticks(el.source.type),\n                            \"target\": el.target.id,\n                            \"target_label\": _remove_backticks(el.target.type),\n                            \"type\": _remove_backticks(\n                                el.type.replace(\" \", \"_\").upper()\n                            ),\n                            \"properties\": el.properties,\n                        }\n                        for el in document.relationships\n                    ]\n                },\n            )\n\n    def close(self) -> None:\n        \"\"\"\n        Explicitly close the Neo4j driver connection.\n\n        Delegates connection management to the Neo4j driver.\n        \"\"\"\n        if hasattr(self, \"_driver\"):\n            self._driver.close()\n            # Remove the driver attribute to indicate closure\n            delattr(self, \"_driver\")\n\n    def __enter__(self) -> \"Neo4jGraph\":\n        \"\"\"\n        Enter the runtime context for the Neo4j graph connection.\n\n        Enables use of the graph connection with the 'with' statement.\n        This method allows for automatic resource management and ensures\n        that the connection is properly handled.\n\n        Returns:\n            Neo4jGraph: The current graph connection instance\n\n        Example:\n            with Neo4jGraph(...) as graph:\n                graph.query(...)  # Connection automatically managed\n        \"\"\"\n        return self\n\n    def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[Any],\n    ) -> None:\n        \"\"\"\n        Exit the runtime context for the Neo4j graph connection.\n\n        This method is automatically called when exiting a 'with' statement.\n        It ensures that the database connection is closed, regardless of\n        whether an exception occurred during the context's execution.\n\n        Args:\n            exc_type: The type of exception that caused the context to exit\n                      (None if no exception occurred)\n            exc_val: The exception instance that caused the context to exit\n                     (None if no exception occurred)\n            exc_tb: The traceback for the exception (None if no exception occurred)\n\n        Note:\n            Any exception is re-raised after the connection is closed.\n        \"\"\"\n        self.close()\n\n    def __del__(self) -> None:\n        \"\"\"\n        Destructor for the Neo4j graph connection.\n\n        This method is called during garbage collection to ensure that\n        database resources are released if not explicitly closed.\n\n        Caution:\n            - Do not rely on this method for deterministic resource cleanup\n            - Always prefer explicit .close() or context manager\n\n        Best practices:\n            1. Use context manager:\n               with Neo4jGraph(...) as graph:\n                   ...\n            2. Explicitly close:\n               graph = Neo4jGraph(...)\n               try:\n                   ...\n               finally:\n                   graph.close()\n        \"\"\"\n        try:\n            self.close()\n        except Exception:\n            # Suppress any exceptions during garbage collection\n            pass","inst_variables":[{"var":"_driver","type":null,"value":"neo4j.GraphDatabase.driver(url, auth=auth, **driver_config or {})","lineno":142},{"var":"_database","type":null,"value":"database","lineno":145},{"var":"timeout","type":null,"value":"timeout","lineno":146},{"var":"sanitize","type":null,"value":"sanitize","lineno":147},{"var":"_enhanced_schema","type":null,"value":"enhanced_schema","lineno":148}],"reason_kor":"Neo4j 데이터베이스 연산을 감싸는 클래스이며, 연결 관리, 쿼리 실행, 스키마 조회 및 갱신, 그래프 문서 삽입, 리소스 정리 기능을 포함합니다. 인증 처리, 타임아웃 지원, 스키마 향상, 컨텍스트 매니저 지원 등의 기능을 제공합니다.","reason":"A class wrapping Neo4j database operations, including connection management, query execution, schema retrieval and refresh, graph document ingestion, and resource cleanup. It provides features such as authentication handling, timeout support, schema enhancement, and context manager support."},{"_key":"langchain_neo4j_graphs_neo4j_graph_py___del__","_id":"nodes/langchain_neo4j_graphs_neo4j_graph_py___del__","_rev":"_jzRpK2u---","type":"function","name":"__del__","defined_in":"langchain_neo4j_graphs_neo4j_graph_py","lineno":437,"source":"def __del__(self) -> None:\n        \"\"\"\n        Destructor for the Neo4j graph connection.\n\n        This method is called during garbage collection to ensure that\n        database resources are released if not explicitly closed.\n\n        Caution:\n            - Do not rely on this method for deterministic resource cleanup\n            - Always prefer explicit .close() or context manager\n\n        Best practices:\n            1. Use context manager:\n               with Neo4jGraph(...) as graph:\n                   ...\n            2. Explicitly close:\n               graph = Neo4jGraph(...)\n               try:\n                   ...\n               finally:\n                   graph.close()\n        \"\"\"\n        try:\n            self.close()\n        except Exception:\n            # Suppress any exceptions during garbage collection\n            pass","docstring":"Destructor for the Neo4j graph connection.\n\nThis method is called during garbage collection to ensure that\ndatabase resources are released if not explicitly closed.\n\nCaution:\n    - Do not rely on this method for deterministic resource cleanup\n    - Always prefer explicit .close() or context manager\n\nBest practices:\n    1. Use context manager:\n       with Neo4jGraph(...) as graph:\n           ...\n    2. Explicitly close:\n       graph = Neo4jGraph(...)\n       try:\n           ...\n       finally:\n           graph.close()","args":[{"arg":"self","type":null}],"return_type":"None","control_flow":[{"type":"try","lineno":459}],"reason_kor":"객체가 가비지 컬렉션 될 때 Neo4j 데이터베이스 연결을 종료하고 리소스를 해제하는 소멸자 메서드입니다.","reason":"Destructor method to ensure the Neo4j database connection is closed and resources are freed when the object is garbage collected."},{"_key":"langchain_neo4j_graphs_neo4j_graph_py___enter__","_id":"nodes/langchain_neo4j_graphs_neo4j_graph_py___enter__","_rev":"_jzRpK26---","type":"function","name":"__enter__","defined_in":"langchain_neo4j_graphs_neo4j_graph_py","lineno":395,"source":"def __enter__(self) -> \"Neo4jGraph\":\n        \"\"\"\n        Enter the runtime context for the Neo4j graph connection.\n\n        Enables use of the graph connection with the 'with' statement.\n        This method allows for automatic resource management and ensures\n        that the connection is properly handled.\n\n        Returns:\n            Neo4jGraph: The current graph connection instance\n\n        Example:\n            with Neo4jGraph(...) as graph:\n                graph.query(...)  # Connection automatically managed\n        \"\"\"\n        return self","docstring":"Enter the runtime context for the Neo4j graph connection.\n\nEnables use of the graph connection with the 'with' statement.\nThis method allows for automatic resource management and ensures\nthat the connection is properly handled.\n\nReturns:\n    Neo4jGraph: The current graph connection instance\n\nExample:\n    with Neo4jGraph(...) as graph:\n        graph.query(...)  # Connection automatically managed","args":[{"arg":"self","type":null}],"return_type":"'Neo4jGraph'","control_flow":[],"reason_kor":"'with' 구문 내에서 자동으로 연결을 관리할 수 있도록 Neo4jGraph를 컨텍스트 매니저로 사용하는 메서드입니다.","reason":"Enables use of Neo4jGraph as a context manager, allowing automatic connection handling within a 'with' statement."},{"_key":"langchain_neo4j_graphs_neo4j_graph_py___exit__","_id":"nodes/langchain_neo4j_graphs_neo4j_graph_py___exit__","_rev":"_jzRpK3G---","type":"function","name":"__exit__","defined_in":"langchain_neo4j_graphs_neo4j_graph_py","lineno":412,"source":"def __exit__(\n        self,\n        exc_type: Optional[Type[BaseException]],\n        exc_val: Optional[BaseException],\n        exc_tb: Optional[Any],\n    ) -> None:\n        \"\"\"\n        Exit the runtime context for the Neo4j graph connection.\n\n        This method is automatically called when exiting a 'with' statement.\n        It ensures that the database connection is closed, regardless of\n        whether an exception occurred during the context's execution.\n\n        Args:\n            exc_type: The type of exception that caused the context to exit\n                      (None if no exception occurred)\n            exc_val: The exception instance that caused the context to exit\n                     (None if no exception occurred)\n            exc_tb: The traceback for the exception (None if no exception occurred)\n\n        Note:\n            Any exception is re-raised after the connection is closed.\n        \"\"\"\n        self.close()","docstring":"Exit the runtime context for the Neo4j graph connection.\n\nThis method is automatically called when exiting a 'with' statement.\nIt ensures that the database connection is closed, regardless of\nwhether an exception occurred during the context's execution.\n\nArgs:\n    exc_type: The type of exception that caused the context to exit\n              (None if no exception occurred)\n    exc_val: The exception instance that caused the context to exit\n             (None if no exception occurred)\n    exc_tb: The traceback for the exception (None if no exception occurred)\n\nNote:\n    Any exception is re-raised after the connection is closed.","args":[{"arg":"self","type":null},{"arg":"exc_type","type":"Optional[Type[BaseException]]"},{"arg":"exc_val","type":"Optional[BaseException]"},{"arg":"exc_tb","type":"Optional[Any]"}],"return_type":"None","control_flow":[],"reason_kor":"'with' 컨텍스트 종료 시, 실행 중 예외가 발생하더라도 Neo4j 데이터베이스 연결이 정상적으로 종료되도록 하는 메서드입니다.","reason":"Ensures the Neo4j database connection is properly closed when exiting a 'with' context, regardless of exceptions during execution."},{"_key":"langchain_neo4j_graphs_neo4j_graph_py___init__","_id":"nodes/langchain_neo4j_graphs_neo4j_graph_py___init__","_rev":"_jzRpK3O---","type":"function","name":"__init__","defined_in":"langchain_neo4j_graphs_neo4j_graph_py","lineno":107,"source":"def __init__(\n        self,\n        url: Optional[str] = None,\n        username: Optional[str] = None,\n        password: Optional[str] = None,\n        database: Optional[str] = None,\n        timeout: Optional[float] = None,\n        sanitize: bool = False,\n        refresh_schema: bool = True,\n        *,\n        driver_config: Optional[Dict] = None,\n        enhanced_schema: bool = False,\n    ) -> None:\n        \"\"\"Create a new Neo4j graph wrapper instance.\"\"\"\n\n        url = get_from_dict_or_env({\"url\": url}, \"url\", \"NEO4J_URI\")\n        # if username and password are \"\", assume Neo4j auth is disabled\n        if username == \"\" and password == \"\":\n            auth = None\n        else:\n            username = get_from_dict_or_env(\n                {\"username\": username},\n                \"username\",\n                \"NEO4J_USERNAME\",\n            )\n            password = get_from_dict_or_env(\n                {\"password\": password},\n                \"password\",\n                \"NEO4J_PASSWORD\",\n            )\n            auth = (username, password)\n        database = get_from_dict_or_env(\n            {\"database\": database}, \"database\", \"NEO4J_DATABASE\", \"neo4j\"\n        )\n\n        self._driver = neo4j.GraphDatabase.driver(\n            url, auth=auth, **(driver_config or {})\n        )\n        self._database = database\n        self.timeout = timeout\n        self.sanitize = sanitize\n        self._enhanced_schema = enhanced_schema\n        self.schema: str = \"\"\n        self.structured_schema: Dict[str, Any] = {}\n        # Verify connection\n        try:\n            self._driver.verify_connectivity()\n        except neo4j.exceptions.ConfigurationError:\n            raise ValueError(\n                \"Could not connect to Neo4j database. \"\n                \"Please ensure that the driver config is correct\"\n            )\n        except neo4j.exceptions.ServiceUnavailable:\n            raise ValueError(\n                \"Could not connect to Neo4j database. \"\n                \"Please ensure that the url is correct\"\n            )\n        except neo4j.exceptions.AuthError:\n            raise ValueError(\n                \"Could not connect to Neo4j database. \"\n                \"Please ensure that the username and password are correct\"\n            )\n        # Set schema\n        if refresh_schema:\n            try:\n                self.refresh_schema()\n            except neo4j.exceptions.ClientError as e:\n                if e.code == \"Neo.ClientError.Procedure.ProcedureNotFound\":\n                    raise ValueError(\n                        \"Could not use APOC procedures. \"\n                        \"Please ensure the APOC plugin is installed in Neo4j and that \"\n                        \"'apoc.meta.data()' is allowed in Neo4j configuration \"\n                    )\n                raise e","docstring":"Create a new Neo4j graph wrapper instance.","args":[{"arg":"self","type":null},{"arg":"url","type":"Optional[str]"},{"arg":"username","type":"Optional[str]"},{"arg":"password","type":"Optional[str]"},{"arg":"database","type":"Optional[str]"},{"arg":"timeout","type":"Optional[float]"},{"arg":"sanitize","type":"bool"},{"arg":"refresh_schema","type":"bool"}],"return_type":"None","control_flow":[{"type":"if","lineno":124},{"type":"try","lineno":152},{"type":"if","lineno":170},{"type":"try","lineno":171},{"type":"if","lineno":174}],"reason_kor":"설정 매개변수를 지정하고 데이터베이스 연결을 설정하며 연결 검증, 인증, 오류 처리 및 선택적 스키마 갱신을 포함하는 Neo4j 그래프 래퍼 인스턴스 초기화를 생성자 내에서 수행합니다.","reason":"it is about the initialization of a Neo4j graph wrapper instance by setting configuration parameters, establishing a database connection, verifying connectivity, handling authentication, handling errors, and optionally refreshing the schema, all within a constructor method."},{"_key":"langchain_neo4j_graphs_neo4j_graph_py__check_driver_state","_id":"nodes/langchain_neo4j_graphs_neo4j_graph_py__check_driver_state","_rev":"_jzRpK3a---","type":"function","name":"_check_driver_state","defined_in":"langchain_neo4j_graphs_neo4j_graph_py","lineno":182,"source":"def _check_driver_state(self) -> None:\n        \"\"\"\n        Check if the driver is available and ready for operations.\n\n        Raises:\n            RuntimeError: If the driver has been closed or is not initialized.\n        \"\"\"\n        if not hasattr(self, \"_driver\"):\n            raise RuntimeError(\n                \"Cannot perform operations - Neo4j connection has been closed\"\n            )","docstring":"Check if the driver is available and ready for operations.\n\nRaises:\n    RuntimeError: If the driver has been closed or is not initialized.","args":[{"arg":"self","type":null}],"return_type":"None","control_flow":[{"type":"if","lineno":189}],"reason_kor":"메서드 정의 및 목적과 예외 처리를 설명하는 docstring을 포함하며, '_driver' 속성 존재를 확인하고 없을 경우 드라이버가 닫혔거나 초기화되지 않았음을 나타내는 RuntimeError를 발생시킴","reason":"it is about the method definition, docstring explaining its purpose and exception handling, with a check for the '_driver' attribute, raising a RuntimeError if the attribute does not exist, indicating the driver has been closed or is not initialized."},{"_key":"langchain_neo4j_graphs_neo4j_graph_py__get_node_import_query","_id":"nodes/langchain_neo4j_graphs_neo4j_graph_py__get_node_import_query","_rev":"_jzRpK3m---","type":"function","name":"_get_node_import_query","defined_in":"langchain_neo4j_graphs_neo4j_graph_py","lineno":24,"source":"def _get_node_import_query(baseEntityLabel: bool, include_source: bool) -> str:\n    if baseEntityLabel:\n        return (\n            f\"{include_docs_query if include_source else ''}\"\n            \"UNWIND $data AS row \"\n            f\"MERGE (source:`{BASE_ENTITY_LABEL}` {{id: row.id}}) \"\n            \"SET source += row.properties \"\n            f\"{'MERGE (d)-[:MENTIONS]->(source) ' if include_source else ''}\"\n            \"WITH source, row \"\n            \"CALL apoc.create.addLabels( source, [row.type] ) YIELD node \"\n            \"RETURN distinct 'done' AS result\"\n        )\n    else:\n        return (\n            f\"{include_docs_query if include_source else ''}\"\n            \"UNWIND $data AS row \"\n            \"CALL apoc.merge.node([row.type], {id: row.id}, \"\n            \"row.properties, {}) YIELD node \"\n            f\"{'MERGE (d)-[:MENTIONS]->(node) ' if include_source else ''}\"\n            \"RETURN distinct 'done' AS result\"\n        )","docstring":null,"args":[{"arg":"baseEntityLabel","type":"bool"},{"arg":"include_source","type":"bool"}],"return_type":"str","control_flow":[{"type":"if","lineno":25}],"reason_kor":"노드를 Neo4j 그래프에 삽입하기 위한 Cypher 쿼리 문자열을 생성하는 헬퍼 함수이며, 소스 문서 연결 및 기본 엔티티 라벨링 옵션을 포함할 수 있습니다.","reason":"Helper function to generate a Cypher query string for importing nodes into the Neo4j graph, optionally including source document linking and base entity labeling for indexing."},{"_key":"langchain_neo4j_graphs_neo4j_graph_py__get_rel_import_query","_id":"nodes/langchain_neo4j_graphs_neo4j_graph_py__get_rel_import_query","_rev":"_jzRpK3u---","type":"function","name":"_get_rel_import_query","defined_in":"langchain_neo4j_graphs_neo4j_graph_py","lineno":47,"source":"def _get_rel_import_query(baseEntityLabel: bool) -> str:\n    if baseEntityLabel:\n        return (\n            \"UNWIND $data AS row \"\n            f\"MERGE (source:`{BASE_ENTITY_LABEL}` {{id: row.source}}) \"\n            f\"MERGE (target:`{BASE_ENTITY_LABEL}` {{id: row.target}}) \"\n            \"WITH source, target, row \"\n            \"CALL apoc.merge.relationship(source, row.type, \"\n            \"{}, row.properties, target) YIELD rel \"\n            \"RETURN distinct 'done'\"\n        )\n    else:\n        return (\n            \"UNWIND $data AS row \"\n            \"CALL apoc.merge.node([row.source_label], {id: row.source},\"\n            \"{}, {}) YIELD node as source \"\n            \"CALL apoc.merge.node([row.target_label], {id: row.target},\"\n            \"{}, {}) YIELD node as target \"\n            \"CALL apoc.merge.relationship(source, row.type, \"\n            \"{}, row.properties, target) YIELD rel \"\n            \"RETURN distinct 'done'\"\n        )","docstring":null,"args":[{"arg":"baseEntityLabel","type":"bool"}],"return_type":"str","control_flow":[{"type":"if","lineno":48}],"reason_kor":"관계 데이터를 Neo4j 그래프에 삽입하기 위한 Cypher 쿼리 문자열을 생성하는 헬퍼 함수이며, 기본 엔티티 라벨링을 지원합니다.","reason":"Helper function to generate a Cypher query string for importing relationships into the Neo4j graph, supporting base entity labeling."},{"_key":"langchain_neo4j_graphs_neo4j_graph_py__remove_backticks","_id":"nodes/langchain_neo4j_graphs_neo4j_graph_py__remove_backticks","_rev":"_jzRpK36---","type":"function","name":"_remove_backticks","defined_in":"langchain_neo4j_graphs_neo4j_graph_py","lineno":71,"source":"def _remove_backticks(text: str) -> str:\n    return text.replace(\"`\", \"\")","docstring":null,"args":[{"arg":"text","type":"str"}],"return_type":"str","control_flow":[],"reason_kor":"주어진 문자열에서 백틱(`) 문자를 제거하는 유틸리티 함수로, 노드나 관계 라벨을 정제할 때 사용됩니다.","reason":"Utility function to remove backtick characters from a given string, often used to sanitize node or relationship labels."},{"_key":"langchain_neo4j_graphs_neo4j_graph_py_add_graph_documents","_id":"nodes/langchain_neo4j_graphs_neo4j_graph_py_add_graph_documents","_rev":"_jzRpK4C---","type":"function","name":"add_graph_documents","defined_in":"langchain_neo4j_graphs_neo4j_graph_py","lineno":289,"source":"def add_graph_documents(\n        self,\n        graph_documents: List[GraphDocument],\n        include_source: bool = False,\n        baseEntityLabel: bool = False,\n    ) -> None:\n        \"\"\"\n        This method constructs nodes and relationships in the graph based on the\n        provided GraphDocument objects.\n\n        Parameters:\n        - graph_documents (List[GraphDocument]): A list of GraphDocument objects\n        that contain the nodes and relationships to be added to the graph. Each\n        GraphDocument should encapsulate the structure of part of the graph,\n        including nodes, relationships, and optionally the source document information.\n        - include_source (bool, optional): If True, stores the source document\n        and links it to nodes in the graph using the MENTIONS relationship.\n        This is useful for tracing back the origin of data. Merges source\n        documents based on the `id` property from the source document metadata\n        if available; otherwise it calculates the MD5 hash of `page_content`\n        for merging process. Defaults to False.\n        - baseEntityLabel (bool, optional): If True, each newly created node\n        gets a secondary __Entity__ label, which is indexed and improves import\n        speed and performance. Defaults to False.\n\n        Raises:\n            RuntimeError: If the connection has been closed.\n        \"\"\"\n        self._check_driver_state()\n        if baseEntityLabel:  # Check if constraint already exists\n            constraint_exists = any(\n                [\n                    el[\"labelsOrTypes\"] == [BASE_ENTITY_LABEL]\n                    and el[\"properties\"] == [\"id\"]\n                    for el in self.structured_schema.get(\"metadata\", {}).get(\n                        \"constraint\", []\n                    )\n                ]\n            )\n\n            if not constraint_exists:\n                # Create constraint\n                self.query(\n                    f\"CREATE CONSTRAINT IF NOT EXISTS FOR (b:{BASE_ENTITY_LABEL}) \"\n                    \"REQUIRE b.id IS UNIQUE;\"\n                )\n                self.refresh_schema()  # Refresh constraint information\n\n        # Check each graph_document has a source when include_source is true\n        if include_source:\n            for doc in graph_documents:\n                if doc.source is None:\n                    raise TypeError(\n                        \"include_source is set to True, \"\n                        \"but at least one document has no `source`.\"\n                    )\n\n        node_import_query = _get_node_import_query(baseEntityLabel, include_source)\n        rel_import_query = _get_rel_import_query(baseEntityLabel)\n        for document in graph_documents:\n            node_import_query_params: dict[str, Any] = {\n                \"data\": [el.__dict__ for el in document.nodes]\n            }\n            if include_source and document.source:\n                if not document.source.metadata.get(\"id\"):\n                    document.source.metadata[\"id\"] = md5(\n                        document.source.page_content.encode(\"utf-8\")\n                    ).hexdigest()\n                node_import_query_params[\"document\"] = document.source.__dict__\n\n            # Remove backticks from node types\n            for node in document.nodes:\n                node.type = _remove_backticks(node.type)\n            # Import nodes\n            self.query(node_import_query, node_import_query_params)\n            # Import relationships\n            self.query(\n                rel_import_query,\n                {\n                    \"data\": [\n                        {\n                            \"source\": el.source.id,\n                            \"source_label\": _remove_backticks(el.source.type),\n                            \"target\": el.target.id,\n                            \"target_label\": _remove_backticks(el.target.type),\n                            \"type\": _remove_backticks(\n                                el.type.replace(\" \", \"_\").upper()\n                            ),\n                            \"properties\": el.properties,\n                        }\n                        for el in document.relationships\n                    ]\n                },\n            )","docstring":"This method constructs nodes and relationships in the graph based on the\nprovided GraphDocument objects.\n\nParameters:\n- graph_documents (List[GraphDocument]): A list of GraphDocument objects\nthat contain the nodes and relationships to be added to the graph. Each\nGraphDocument should encapsulate the structure of part of the graph,\nincluding nodes, relationships, and optionally the source document information.\n- include_source (bool, optional): If True, stores the source document\nand links it to nodes in the graph using the MENTIONS relationship.\nThis is useful for tracing back the origin of data. Merges source\ndocuments based on the `id` property from the source document metadata\nif available; otherwise it calculates the MD5 hash of `page_content`\nfor merging process. Defaults to False.\n- baseEntityLabel (bool, optional): If True, each newly created node\ngets a secondary __Entity__ label, which is indexed and improves import\nspeed and performance. Defaults to False.\n\nRaises:\n    RuntimeError: If the connection has been closed.","args":[{"arg":"self","type":null},{"arg":"graph_documents","type":"List[GraphDocument]"},{"arg":"include_source","type":"bool"},{"arg":"baseEntityLabel","type":"bool"}],"return_type":"None","control_flow":[{"type":"if","lineno":318},{"type":"if","lineno":329},{"type":"if","lineno":338},{"type":"for","lineno":339},{"type":"if","lineno":340},{"type":"for","lineno":348},{"type":"if","lineno":352},{"type":"if","lineno":353},{"type":"for","lineno":360}],"reason_kor":"제약 조건 생성, 소스 메타데이터 검증, GraphDocument 객체로부터 노드 및 관계를 그래프 데이터베이스로 가져오는 쿼리를 결합하며, 소스 링크 및 라벨 향상 기능을 선택적으로 생성합니다.","reason":"it is about the creation of constraints, validation of source metadata, and querying to import nodes and relationships from GraphDocument objects into a graph database, with optional source linking and label enhancements."},{"_key":"langchain_neo4j_graphs_neo4j_graph_py_close","_id":"nodes/langchain_neo4j_graphs_neo4j_graph_py_close","_rev":"_jzRpK4O---","type":"function","name":"close","defined_in":"langchain_neo4j_graphs_neo4j_graph_py","lineno":384,"source":"def close(self) -> None:\n        \"\"\"\n        Explicitly close the Neo4j driver connection.\n\n        Delegates connection management to the Neo4j driver.\n        \"\"\"\n        if hasattr(self, \"_driver\"):\n            self._driver.close()\n            # Remove the driver attribute to indicate closure\n            delattr(self, \"_driver\")","docstring":"Explicitly close the Neo4j driver connection.\n\nDelegates connection management to the Neo4j driver.","args":[{"arg":"self","type":null}],"return_type":"None","control_flow":[{"type":"if","lineno":390}],"reason_kor":"명시적으로 Neo4j 드라이버 연결을 종료하는 메서드를 결합하며, '_driver' 속성 존재 확인 후 닫고 속성을 제거하여 연결 종료를 표시합니다.","reason":"it is about a method to explicitly close the Neo4j driver connection by checking for the '_driver' attribute, closing it if present, and then removing the attribute to indicate that the connection has been closed."},{"_key":"langchain_neo4j_graphs_neo4j_graph_py_get_schema","_id":"nodes/langchain_neo4j_graphs_neo4j_graph_py_get_schema","_rev":"_jzRpK4a---","type":"function","name":"get_schema","defined_in":"langchain_neo4j_graphs_neo4j_graph_py","lineno":195,"source":"def get_schema(self) -> str:\n        \"\"\"Returns the schema of the Graph\"\"\"\n        return self.schema","docstring":"Returns the schema of the Graph","args":[{"arg":"self","type":null}],"return_type":"str","control_flow":[],"reason_kor":"현재 그래프 스키마를 문자열로 반환하는 프로퍼티 메서드입니다.","reason":"Property method to return the current graph schema as a string."},{"_key":"langchain_neo4j_graphs_neo4j_graph_py_get_structured_schema","_id":"nodes/langchain_neo4j_graphs_neo4j_graph_py_get_structured_schema","_rev":"_jzRpK4m---","type":"function","name":"get_structured_schema","defined_in":"langchain_neo4j_graphs_neo4j_graph_py","lineno":200,"source":"def get_structured_schema(self) -> Dict[str, Any]:\n        \"\"\"Returns the structured schema of the Graph\"\"\"\n        return self.structured_schema","docstring":"Returns the structured schema of the Graph","args":[{"arg":"self","type":null}],"return_type":"Dict[str, Any]","control_flow":[],"reason_kor":"현재 그래프 스키마를 구조화된 딕셔너리 형식으로 반환하는 프로퍼티 메서드입니다.","reason":"Property method to return the current graph schema in a structured dictionary format."},{"_key":"langchain_neo4j_graphs_neo4j_graph_py_query","_id":"nodes/langchain_neo4j_graphs_neo4j_graph_py_query","_rev":"_jzRpK42---","type":"function","name":"query","defined_in":"langchain_neo4j_graphs_neo4j_graph_py","lineno":204,"source":"def query(\n        self,\n        query: str,\n        params: dict = {},\n        session_params: dict = {},\n    ) -> List[Dict[str, Any]]:\n        \"\"\"Query Neo4j database.\n\n        Args:\n            query (str): The Cypher query to execute.\n            params (dict): The parameters to pass to the query.\n            session_params (dict): Parameters to pass to the session used for executing\n                the query.\n\n        Returns:\n            List[Dict[str, Any]]: The list of dictionaries containing the query results.\n\n        Raises:\n            RuntimeError: If the connection has been closed.\n        \"\"\"\n        self._check_driver_state()\n        from neo4j import Query\n        from neo4j.exceptions import Neo4jError\n\n        if not session_params:\n            try:\n                data, _, _ = self._driver.execute_query(\n                    Query(text=query, timeout=self.timeout),\n                    database_=self._database,\n                    parameters_=params,\n                )\n                json_data = [r.data() for r in data]\n                if self.sanitize:\n                    json_data = [_value_sanitize(el) for el in json_data]\n                return json_data\n            except Neo4jError as e:\n                if not (\n                    (\n                        (  # isCallInTransactionError\n                            e.code == \"Neo.DatabaseError.Statement.ExecutionFailed\"\n                            or e.code\n                            == \"Neo.DatabaseError.Transaction.TransactionStartFailed\"\n                        )\n                        and e.message is not None\n                        and \"in an implicit transaction\" in e.message\n                    )\n                    or (  # isPeriodicCommitError\n                        e.code == \"Neo.ClientError.Statement.SemanticError\"\n                        and e.message is not None\n                        and (\n                            \"in an open transaction is not possible\" in e.message\n                            or \"tried to execute in an explicit transaction\"\n                            in e.message\n                        )\n                    )\n                ):\n                    raise\n        # fallback to allow implicit transactions\n        session_params.setdefault(\"database\", self._database)\n        with self._driver.session(**session_params) as session:\n            result = session.run(Query(text=query, timeout=self.timeout), params)\n            json_data = [r.data() for r in result]\n            if self.sanitize:\n                json_data = [_value_sanitize(el) for el in json_data]\n            return json_data","docstring":"Query Neo4j database.\n\nArgs:\n    query (str): The Cypher query to execute.\n    params (dict): The parameters to pass to the query.\n    session_params (dict): Parameters to pass to the session used for executing\n        the query.\n\nReturns:\n    List[Dict[str, Any]]: The list of dictionaries containing the query results.\n\nRaises:\n    RuntimeError: If the connection has been closed.","args":[{"arg":"self","type":null},{"arg":"query","type":"str"},{"arg":"params","type":"dict"},{"arg":"session_params","type":"dict"}],"return_type":"List[Dict[str, Any]]","control_flow":[{"type":"if","lineno":228},{"type":"try","lineno":229},{"type":"if","lineno":236},{"type":"if","lineno":240},{"type":"if","lineno":266}],"reason_kor":"직접 쿼리 실행과 암묵적 트랜잭션 실행을 처리하는 예외 처리 기능을 결합하여 Neo4j 데이터베이스 쿼리의 견고성을 보장하고 필요 시 결과를 정제합니다.","reason":"it is about direct query execution with a fallback to implicit transaction execution, handling exceptions to ensure robustness in querying a Neo4j database, and sanitizing results if needed."},{"_key":"langchain_neo4j_graphs_neo4j_graph_py_refresh_schema","_id":"nodes/langchain_neo4j_graphs_neo4j_graph_py_refresh_schema","_rev":"_jzRpK5C---","type":"function","name":"refresh_schema","defined_in":"langchain_neo4j_graphs_neo4j_graph_py","lineno":270,"source":"def refresh_schema(self) -> None:\n        \"\"\"\n        Refreshes the Neo4j graph schema information.\n\n        Raises:\n            RuntimeError: If the connection has been closed.\n        \"\"\"\n        self._check_driver_state()\n        self.structured_schema = get_structured_schema(\n            driver=self._driver,\n            is_enhanced=self._enhanced_schema,\n            database=self._database,\n            timeout=self.timeout,\n            sanitize=self.sanitize,\n        )\n        self.schema = format_schema(\n            schema=self.structured_schema, is_enhanced=self._enhanced_schema\n        )","docstring":"Refreshes the Neo4j graph schema information.\n\nRaises:\n    RuntimeError: If the connection has been closed.","args":[{"arg":"self","type":null}],"return_type":"None","control_flow":[],"reason_kor":"드라이버 상태 점검, 지정된 매개변수로 구조화된 스키마를 검색하고 이후 사용을 위해 스키마를 형식화하는 과정을 결합합니다.","reason":"it is about the process of checking the driver state, retrieving the structured schema with given parameters, and formatting this schema for further use."},{"_key":"langchain_neo4j_py_typed","_id":"nodes/langchain_neo4j_py_typed","_rev":"_jzRp_l2---","type":"file","name":"py.typed","path":"C:\\workspace\\langchain-neo4j\\langchain_neo4j\\py.typed"},{"_key":"langchain_neo4j_query_constructors","_id":"nodes/langchain_neo4j_query_constructors","_rev":"_jzRpAcK---","type":"directory","name":"query_constructors","path":"C:\\workspace\\langchain-neo4j\\langchain_neo4j\\query_constructors"},{"_key":"langchain_neo4j_query_constructors___init___py","_id":"nodes/langchain_neo4j_query_constructors___init___py","_rev":"_jzRpAfK---","type":"file","name":"__init__.py","path":"C:\\workspace\\langchain-neo4j\\langchain_neo4j\\query_constructors\\__init__.py"},{"_key":"langchain_neo4j_query_constructors_neo4j_py","_id":"nodes/langchain_neo4j_query_constructors_neo4j_py","_rev":"_jzRpAci---","type":"file","name":"neo4j.py","path":"C:\\workspace\\langchain-neo4j\\langchain_neo4j\\query_constructors\\neo4j.py"},{"_key":"langchain_neo4j_query_constructors_neo4j_py_Neo4jTranslator","_id":"nodes/langchain_neo4j_query_constructors_neo4j_py_Neo4jTranslator","_rev":"_jzRpK5O---","type":"class","name":"Neo4jTranslator","defined_in":"langchain_neo4j_query_constructors_neo4j_py","lineno":13,"docstring":"Translate `Neo4j` internal query language elements to valid filters.","source":"class Neo4jTranslator(Visitor):\n    \"\"\"Translate `Neo4j` internal query language elements to valid filters.\"\"\"\n\n    allowed_operators = [Operator.AND, Operator.OR]\n    \"\"\"Subset of allowed logical operators.\"\"\"\n\n    allowed_comparators = [\n        Comparator.EQ,\n        Comparator.NE,\n        Comparator.GTE,\n        Comparator.LTE,\n        Comparator.LT,\n        Comparator.GT,\n    ]\n\n    def _format_func(self, func: Union[Operator, Comparator]) -> str:\n        self._validate_func(func)\n        map_dict = {\n            Operator.AND: \"$and\",\n            Operator.OR: \"$or\",\n            Comparator.EQ: \"$eq\",\n            Comparator.NE: \"$ne\",\n            Comparator.GTE: \"$gte\",\n            Comparator.LTE: \"$lte\",\n            Comparator.LT: \"$lt\",\n            Comparator.GT: \"$gt\",\n        }\n        return map_dict[func]\n\n    def visit_operation(self, operation: Operation) -> Dict:\n        args = [arg.accept(self) for arg in operation.arguments]\n        return {self._format_func(operation.operator): args}\n\n    def visit_comparison(self, comparison: Comparison) -> Dict:\n        return {\n            comparison.attribute: {\n                self._format_func(comparison.comparator): comparison.value\n            }\n        }\n\n    def visit_structured_query(\n        self, structured_query: StructuredQuery\n    ) -> Tuple[str, dict]:\n        if structured_query.filter is None:\n            kwargs = {}\n        else:\n            kwargs = {\"filter\": structured_query.filter.accept(self)}\n        return structured_query.query, kwargs","inst_variables":[],"reason_kor":"Neo4j 내부 쿼리 언어 요소를 유효한 필터 딕셔너리로 변환하는 클래스입니다. 논리 연산자와 비교 연산자 매핑을 지원합니다.","reason":"Class that translates Neo4j internal query language elements into valid filter dictionaries for querying, supporting logical operators and comparison operators mapping."},{"_key":"langchain_neo4j_query_constructors_neo4j_py__format_func","_id":"nodes/langchain_neo4j_query_constructors_neo4j_py__format_func","_rev":"_jzRpK5a---","type":"function","name":"_format_func","defined_in":"langchain_neo4j_query_constructors_neo4j_py","lineno":28,"source":"def _format_func(self, func: Union[Operator, Comparator]) -> str:\n        self._validate_func(func)\n        map_dict = {\n            Operator.AND: \"$and\",\n            Operator.OR: \"$or\",\n            Comparator.EQ: \"$eq\",\n            Comparator.NE: \"$ne\",\n            Comparator.GTE: \"$gte\",\n            Comparator.LTE: \"$lte\",\n            Comparator.LT: \"$lt\",\n            Comparator.GT: \"$gt\",\n        }\n        return map_dict[func]","docstring":null,"args":[{"arg":"self","type":null},{"arg":"func","type":"Union[Operator, Comparator]"}],"return_type":"str","control_flow":[],"reason_kor":"논리 및 비교 연산자를 쿼리 필터 내 문자열 표현으로 매핑하는 헬퍼 메서드입니다.","reason":"Helper method to map logical and comparison operators to their string representations in query filters."},{"_key":"langchain_neo4j_query_constructors_neo4j_py_visit_comparison","_id":"nodes/langchain_neo4j_query_constructors_neo4j_py_visit_comparison","_rev":"_jzRpK5m---","type":"function","name":"visit_comparison","defined_in":"langchain_neo4j_query_constructors_neo4j_py","lineno":46,"source":"def visit_comparison(self, comparison: Comparison) -> Dict:\n        return {\n            comparison.attribute: {\n                self._format_func(comparison.comparator): comparison.value\n            }\n        }","docstring":null,"args":[{"arg":"self","type":null},{"arg":"comparison","type":"Comparison"}],"return_type":"Dict","control_flow":[],"reason_kor":"비교 연산을 처리하여 필터 딕셔너리로 변환하는 방문자 메서드입니다.","reason":"Visitor method to process a comparison operation and convert it into a filter dictionary."},{"_key":"langchain_neo4j_query_constructors_neo4j_py_visit_operation","_id":"nodes/langchain_neo4j_query_constructors_neo4j_py_visit_operation","_rev":"_jzRpK5y---","type":"function","name":"visit_operation","defined_in":"langchain_neo4j_query_constructors_neo4j_py","lineno":42,"source":"def visit_operation(self, operation: Operation) -> Dict:\n        args = [arg.accept(self) for arg in operation.arguments]\n        return {self._format_func(operation.operator): args}","docstring":null,"args":[{"arg":"self","type":null},{"arg":"operation","type":"Operation"}],"return_type":"Dict","control_flow":[],"reason":"Visitor method to process a logical operation (AND, OR) and convert it into a combined filter dictionary.","reason_kor":"논리 연산자(AND, OR)를 처리하여 결합된 필터 딕셔너리로 변환하는 방문자 메서드입니다."},{"_key":"langchain_neo4j_query_constructors_neo4j_py_visit_structured_query","_id":"nodes/langchain_neo4j_query_constructors_neo4j_py_visit_structured_query","_rev":"_jzRpK6----","type":"function","name":"visit_structured_query","defined_in":"langchain_neo4j_query_constructors_neo4j_py","lineno":53,"source":"def visit_structured_query(\n        self, structured_query: StructuredQuery\n    ) -> Tuple[str, dict]:\n        if structured_query.filter is None:\n            kwargs = {}\n        else:\n            kwargs = {\"filter\": structured_query.filter.accept(self)}\n        return structured_query.query, kwargs","docstring":null,"args":[{"arg":"self","type":null},{"arg":"structured_query","type":"StructuredQuery"}],"return_type":"Tuple[str, dict]","control_flow":[{"type":"if","lineno":56}],"reason":"Visitor method to process a structured query, returning the Cypher query string along with any filter parameters translated from the filter tree.","reason_kor":"구조화된 쿼리를 처리하여 Cypher 쿼리 문자열과 필터 트리에서 변환된 필터 매개변수를 반환하는 방문자 메서드입니다."},{"_key":"langchain_neo4j_vectorstores","_id":"nodes/langchain_neo4j_vectorstores","_rev":"_jzRpAfq---","type":"directory","name":"vectorstores","path":"C:\\workspace\\langchain-neo4j\\langchain_neo4j\\vectorstores"},{"_key":"langchain_neo4j_vectorstores___init___py","_id":"nodes/langchain_neo4j_vectorstores___init___py","_rev":"_jzRpBPe---","type":"file","name":"__init__.py","path":"C:\\workspace\\langchain-neo4j\\langchain_neo4j\\vectorstores\\__init__.py"},{"_key":"langchain_neo4j_vectorstores_neo4j_vector_py","_id":"nodes/langchain_neo4j_vectorstores_neo4j_vector_py","_rev":"_jzRpAgG---","type":"file","name":"neo4j_vector.py","path":"C:\\workspace\\langchain-neo4j\\langchain_neo4j\\vectorstores\\neo4j_vector.py"},{"_key":"langchain_neo4j_vectorstores_neo4j_vector_py_Neo4jVector","_id":"nodes/langchain_neo4j_vectorstores_neo4j_vector_py_Neo4jVector","_rev":"_jzRpK6K---","type":"class","name":"Neo4jVector","defined_in":"langchain_neo4j_vectorstores_neo4j_vector_py","lineno":115,"docstring":"`Neo4j` vector index.\n\nTo use, you should have the ``neo4j`` python package installed.\n\nArgs:\n    url: Neo4j connection url\n    username: Neo4j username.\n    password: Neo4j password\n    database: Optionally provide Neo4j database\n              Defaults to \"neo4j\"\n    embedding: Any embedding function implementing\n        `langchain.embeddings.base.Embeddings` interface.\n    distance_strategy: The distance strategy to use. (default: COSINE)\n    search_type: The type of search to be performed, either\n        'vector' or 'hybrid'\n    node_label: The label used for nodes in the Neo4j database.\n        (default: \"Chunk\")\n    embedding_node_property: The property name in Neo4j to store embeddings.\n        (default: \"embedding\")\n    text_node_property: The property name in Neo4j to store the text.\n        (default: \"text\")\n    retrieval_query: The Cypher query to be used for customizing retrieval.\n        If empty, a default query will be used.\n    index_type: The type of index to be used, either\n        'NODE' or 'RELATIONSHIP'\n    pre_delete_collection: If True, will delete existing data if it exists.\n        (default: False). Useful for testing.\n    effective_search_ratio: Controls the candidate pool size by multiplying $k\n        to balance query accuracy and performance.\n    embedding_dimension: The dimension of the embeddings. If not provided,\n        will query the embedding model to calculate the dimension.\n\nExample:\n    .. code-block:: python\n\n        from langchain_neo4j import Neo4jVector\n        from langchain_openai import OpenAIEmbeddings\n\n        url=\"bolt://localhost:7687\"\n        username=\"neo4j\"\n        password=\"pleaseletmein\"\n        embeddings = OpenAIEmbeddings()\n        vectorestore = Neo4jVector.from_documents(\n            embedding=embeddings,\n            documents=docs,\n            url=url\n            username=username,\n            password=password,\n        )","source":"class Neo4jVector(VectorStore):\n    \"\"\"`Neo4j` vector index.\n\n    To use, you should have the ``neo4j`` python package installed.\n\n    Args:\n        url: Neo4j connection url\n        username: Neo4j username.\n        password: Neo4j password\n        database: Optionally provide Neo4j database\n                  Defaults to \"neo4j\"\n        embedding: Any embedding function implementing\n            `langchain.embeddings.base.Embeddings` interface.\n        distance_strategy: The distance strategy to use. (default: COSINE)\n        search_type: The type of search to be performed, either\n            'vector' or 'hybrid'\n        node_label: The label used for nodes in the Neo4j database.\n            (default: \"Chunk\")\n        embedding_node_property: The property name in Neo4j to store embeddings.\n            (default: \"embedding\")\n        text_node_property: The property name in Neo4j to store the text.\n            (default: \"text\")\n        retrieval_query: The Cypher query to be used for customizing retrieval.\n            If empty, a default query will be used.\n        index_type: The type of index to be used, either\n            'NODE' or 'RELATIONSHIP'\n        pre_delete_collection: If True, will delete existing data if it exists.\n            (default: False). Useful for testing.\n        effective_search_ratio: Controls the candidate pool size by multiplying $k\n            to balance query accuracy and performance.\n        embedding_dimension: The dimension of the embeddings. If not provided,\n            will query the embedding model to calculate the dimension.\n\n    Example:\n        .. code-block:: python\n\n            from langchain_neo4j import Neo4jVector\n            from langchain_openai import OpenAIEmbeddings\n\n            url=\"bolt://localhost:7687\"\n            username=\"neo4j\"\n            password=\"pleaseletmein\"\n            embeddings = OpenAIEmbeddings()\n            vectorestore = Neo4jVector.from_documents(\n                embedding=embeddings,\n                documents=docs,\n                url=url\n                username=username,\n                password=password,\n            )\n\n\n    \"\"\"\n\n    def __init__(\n        self,\n        embedding: Embeddings,\n        *,\n        search_type: SearchType = SearchType.VECTOR,\n        username: Optional[str] = None,\n        password: Optional[str] = None,\n        url: Optional[str] = None,\n        keyword_index_name: Optional[str] = \"keyword\",\n        database: Optional[str] = None,\n        index_name: str = \"vector\",\n        node_label: str = \"Chunk\",\n        embedding_node_property: str = \"embedding\",\n        text_node_property: str = \"text\",\n        distance_strategy: DistanceStrategy = DEFAULT_DISTANCE_STRATEGY,\n        logger: Optional[logging.Logger] = None,\n        pre_delete_collection: bool = False,\n        retrieval_query: str = \"\",\n        relevance_score_fn: Optional[Callable[[float], float]] = None,\n        index_type: IndexType = DEFAULT_INDEX_TYPE,\n        graph: Optional[Neo4jGraph] = None,\n        embedding_dimension: Optional[int] = None,\n    ) -> None:\n        # Allow only cosine and euclidean distance strategies\n        if distance_strategy not in [\n            DistanceStrategy.EUCLIDEAN_DISTANCE,\n            DistanceStrategy.COSINE,\n        ]:\n            raise ValueError(\n                \"distance_strategy must be either 'EUCLIDEAN_DISTANCE' or 'COSINE'\"\n            )\n\n        # Graph object takes precedent over env or input params\n        if graph:\n            self._driver = graph._driver\n            self._database = graph._database\n        else:\n            # Handle if the credentials are environment variables\n            # Support URL for backwards compatibility\n            if not url:\n                url = os.environ.get(\"NEO4J_URL\")\n\n            url = get_from_dict_or_env({\"url\": url}, \"url\", \"NEO4J_URI\")\n            username = get_from_dict_or_env(\n                {\"username\": username}, \"username\", \"NEO4J_USERNAME\"\n            )\n            password = get_from_dict_or_env(\n                {\"password\": password}, \"password\", \"NEO4J_PASSWORD\"\n            )\n            database = get_from_dict_or_env(\n                {\"database\": database}, \"database\", \"NEO4J_DATABASE\", \"neo4j\"\n            )\n\n            self._driver = neo4j.GraphDatabase.driver(url, auth=(username, password))\n            self._database = database\n            # Verify connection\n            try:\n                self._driver.verify_connectivity()\n            except neo4j.exceptions.ServiceUnavailable:\n                raise ValueError(\n                    \"Could not connect to Neo4j database. \"\n                    \"Please ensure that the url is correct\"\n                )\n            except neo4j.exceptions.AuthError:\n                raise ValueError(\n                    \"Could not connect to Neo4j database. \"\n                    \"Please ensure that the username and password are correct\"\n                )\n\n        self.schema = \"\"\n        # Verify if the version support vector index\n        self._is_enterprise = False\n        self.verify_version()\n\n        # Verify that required values are not null\n        check_if_not_null(\n            [\n                \"index_name\",\n                \"node_label\",\n                \"embedding_node_property\",\n                \"text_node_property\",\n            ],\n            [index_name, node_label, embedding_node_property, text_node_property],\n        )\n\n        self.embedding = embedding\n        self._distance_strategy = distance_strategy\n        self.index_name = index_name\n        self.keyword_index_name = keyword_index_name\n        self.node_label = node_label\n        self.embedding_node_property = embedding_node_property\n        self.text_node_property = text_node_property\n        self.logger = logger or logging.getLogger(__name__)\n        self.override_relevance_score_fn = relevance_score_fn\n        self.retrieval_query = retrieval_query\n        self.search_type = search_type\n        self._index_type = index_type\n\n        if embedding_dimension:\n            self.embedding_dimension = embedding_dimension\n        else:\n            # Calculate embedding dimension\n            self.embedding_dimension = len(embedding.embed_query(\"foo\"))\n\n        # Delete existing data if flagged\n        if pre_delete_collection:\n            from neo4j.exceptions import DatabaseError\n\n            delete_query = self._build_delete_query()\n            self.query(delete_query)\n            # Delete index\n            try:\n                self.query(f\"DROP INDEX {self.index_name}\")\n            except DatabaseError:  # Index didn't exist yet\n                pass\n\n    def _build_delete_query(self) -> str:\n        if self.neo4j_version_is_5_23_or_above:\n            call_prefix = \"CALL (n) {\"\n        else:\n            call_prefix = \"CALL { WITH n\"\n        return (\n            f\"MATCH (n:`{self.node_label}`) \"\n            f\"{call_prefix} DETACH DELETE n \"\n            \"} IN TRANSACTIONS OF 10000 ROWS;\"\n        )\n\n    def query(\n        self,\n        query: str,\n        *,\n        params: Optional[dict] = None,\n    ) -> List[Dict[str, Any]]:\n        \"\"\"Query Neo4j database with retries and exponential backoff.\n\n        Args:\n            query (str): The Cypher query to execute.\n            params (dict, optional): Dictionary of query parameters. Defaults to {}.\n\n        Returns:\n            List[Dict[str, Any]]: List of dictionaries containing the query results.\n        \"\"\"\n        from neo4j import Query\n        from neo4j.exceptions import Neo4jError\n\n        params = params or {}\n        try:\n            data, _, _ = self._driver.execute_query(\n                query, database_=self._database, parameters_=params\n            )\n            return [r.data() for r in data]\n        except Neo4jError as e:\n            if not (\n                (\n                    (  # isCallInTransactionError\n                        e.code == \"Neo.DatabaseError.Statement.ExecutionFailed\"\n                        or e.code\n                        == \"Neo.DatabaseError.Transaction.TransactionStartFailed\"\n                    )\n                    and e.message is not None\n                    and \"in an implicit transaction\" in e.message\n                )\n                or (  # isPeriodicCommitError\n                    e.code == \"Neo.ClientError.Statement.SemanticError\"\n                    and e.message is not None\n                    and (\n                        \"in an open transaction is not possible\" in e.message\n                        or \"tried to execute in an explicit transaction\" in e.message\n                    )\n                )\n            ):\n                raise\n        # Fallback to allow implicit transactions\n        with self._driver.session(database=self._database) as session:\n            result = session.run(Query(text=query), params)\n            return [r.data() for r in result]\n\n    def verify_version(self) -> None:\n        \"\"\"\n        Check if the connected Neo4j database version supports vector indexing.\n\n        Queries the Neo4j database to retrieve its version and compares it\n        against a target version (5.11.0) that is known to support vector\n        indexing. Raises a ValueError if the connected Neo4j version is\n        not supported.\n        \"\"\"\n        version_tuple, is_aura, is_enterprise = get_version(\n            self._driver, self._database\n        )\n        self._is_enterprise = is_enterprise\n        self.neo4j_version_is_5_23_or_above = is_version_5_23_or_above(version_tuple)\n        if not has_vector_index_support(version_tuple):\n            raise ValueError(\n                \"Vector index is only supported in Neo4j version 5.11 or greater\"\n            )\n        self.support_metadata_filter = has_metadata_filtering_support(\n            version_tuple, is_aura\n        )\n\n    def retrieve_existing_index(self) -> Optional[Tuple[Optional[int], str]]:\n        \"\"\"\n        Check if the vector index exists in the Neo4j database\n        and returns its embedding dimension.\n\n        This method queries the Neo4j database for existing indexes\n        and attempts to retrieve the dimension of the vector index\n        with the specified name. If the index exists, its dimension is returned.\n        If the index doesn't exist, `None` is returned.\n\n        Returns:\n            int or None: The embedding dimension of the existing index if found.\n        \"\"\"\n        index_information = retrieve_vector_index_info(\n            driver=self._driver,\n            index_name=self.index_name,\n            label_or_type=self.node_label,\n            embedding_property=self.embedding_node_property,\n        )\n        if index_information:\n            try:\n                self.index_name = index_information[\"name\"]\n                self.node_label = index_information[\"labelsOrTypes\"][0]\n                self.embedding_node_property = index_information[\"properties\"][0]\n                self._index_type = index_information[\"entityType\"]\n                embedding_dimension = None\n                index_config = index_information[\"options\"][\"indexConfig\"]\n                if \"vector.dimensions\" in index_config:\n                    embedding_dimension = index_config[\"vector.dimensions\"]\n                return embedding_dimension, index_information[\"entityType\"]\n            except IndexError:\n                return None\n        else:\n            return None\n\n    def retrieve_existing_fts_index(\n        self, text_node_properties: List[str] = []\n    ) -> Optional[str]:\n        \"\"\"\n        Check if the fulltext index exists in the Neo4j database\n\n        This method queries the Neo4j database for existing fts indexes\n        with the specified name.\n\n        Returns:\n            (Tuple): keyword index information\n        \"\"\"\n        if self.keyword_index_name:\n            index_information = retrieve_fulltext_index_info(\n                driver=self._driver,\n                index_name=self.keyword_index_name,\n                label_or_type=self.node_label,\n                text_properties=text_node_properties or [self.text_node_property],\n            )\n        else:\n            raise ValueError(\"keyword_index_name is not set.\")\n        if index_information:\n            try:\n                self.keyword_index_name = index_information[\"name\"]\n                self.text_node_property = index_information[\"properties\"][0]\n                node_label = index_information[\"labelsOrTypes\"][0]\n                return node_label\n            except IndexError:\n                return None\n        else:\n            return None\n\n    def create_new_index(self) -> None:\n        \"\"\"\n        This method constructs a Cypher query and executes it\n        to create a new vector index in Neo4j.\n        \"\"\"\n        similarity_fn = DISTANCE_MAPPING[self._distance_strategy]\n        create_vector_index(\n            driver=self._driver,\n            name=self.index_name,\n            label=self.node_label,\n            embedding_property=self.embedding_node_property,\n            dimensions=self.embedding_dimension,\n            similarity_fn=similarity_fn,\n            fail_if_exists=False,\n            neo4j_database=self._database,\n        )\n\n    def create_new_keyword_index(self, text_node_properties: List[str] = []) -> None:\n        \"\"\"\n        This method constructs a Cypher query and executes it\n        to create a new full text index in Neo4j.\n        \"\"\"\n        if self.keyword_index_name:\n            create_fulltext_index(\n                driver=self._driver,\n                name=self.keyword_index_name,\n                label=self.node_label,\n                node_properties=text_node_properties or [self.text_node_property],\n                fail_if_exists=False,\n                neo4j_database=self._database,\n            )\n        else:\n            raise ValueError(\"keyword_index_name is not set.\")\n\n    @property\n    def embeddings(self) -> Embeddings:\n        return self.embedding\n\n    @classmethod\n    def __from(\n        cls,\n        texts: List[str],\n        embeddings: List[List[float]],\n        embedding: Embeddings,\n        metadatas: Optional[List[dict]] = None,\n        ids: Optional[List[str]] = None,\n        create_id_index: bool = True,\n        search_type: SearchType = SearchType.VECTOR,\n        **kwargs: Any,\n    ) -> Neo4jVector:\n        if ids is None:\n            ids = [md5(text.encode(\"utf-8\")).hexdigest() for text in texts]\n\n        if not metadatas:\n            metadatas = [{} for _ in texts]\n\n        store = cls(\n            embedding=embedding,\n            search_type=search_type,\n            **kwargs,\n        )\n\n        # Check if the vector index already exists\n        existing_index_info = store.retrieve_existing_index()\n        if existing_index_info:\n            embedding_dimension, index_type = existing_index_info\n        else:\n            embedding_dimension = None\n            index_type = None\n\n        # Raise error if relationship index type\n        if index_type == \"RELATIONSHIP\":\n            raise ValueError(\n                \"Data ingestion is not supported with relationship vector index.\"\n            )\n\n        # If the vector index doesn't exist yet\n        if not index_type:\n            store.create_new_index()\n        # If the index already exists, check if embedding dimensions match\n        elif (\n            embedding_dimension and not store.embedding_dimension == embedding_dimension\n        ):\n            raise ValueError(\n                f\"Index with name {store.index_name} already exists. \"\n                \"The provided embedding function and vector index \"\n                \"dimensions do not match.\\n\"\n                f\"Embedding function dimension: {store.embedding_dimension}\\n\"\n                f\"Vector index dimension: {embedding_dimension}\"\n            )\n\n        if search_type == SearchType.HYBRID:\n            fts_node_label = store.retrieve_existing_fts_index()\n            # If the FTS index doesn't exist yet\n            if not fts_node_label:\n                store.create_new_keyword_index()\n            else:  # Validate that FTS and Vector index use the same information\n                if not fts_node_label == store.node_label:\n                    raise ValueError(\n                        \"Vector and keyword index don't index the same node label\"\n                    )\n\n        # Create unique constraint for faster import\n        if create_id_index:\n            store.query(\n                \"CREATE CONSTRAINT IF NOT EXISTS \"\n                f\"FOR (n:`{store.node_label}`) REQUIRE n.id IS UNIQUE;\"\n            )\n\n        store.add_embeddings(\n            texts=texts, embeddings=embeddings, metadatas=metadatas, ids=ids, **kwargs\n        )\n\n        return store\n\n    def add_embeddings(\n        self,\n        texts: Iterable[str],\n        embeddings: List[List[float]],\n        metadatas: Optional[List[dict]] = None,\n        ids: Optional[List[str]] = None,\n        **kwargs: Any,\n    ) -> List[str]:\n        \"\"\"Add embeddings to the vectorstore.\n\n        Args:\n            texts: Iterable of strings to add to the vectorstore.\n            embeddings: List of list of embedding vectors.\n            metadatas: List of metadatas associated with the texts.\n            kwargs: vectorstore specific parameters\n        \"\"\"\n        if ids is None:\n            ids = [md5(text.encode(\"utf-8\")).hexdigest() for text in texts]\n\n        if not metadatas:\n            metadatas = [{} for _ in texts]\n\n        import_query = self._build_import_query()\n\n        parameters = {\n            \"data\": [\n                {\"text\": text, \"metadata\": metadata, \"embedding\": embedding, \"id\": id}\n                for text, metadata, embedding, id in zip(\n                    texts, metadatas, embeddings, ids\n                )\n            ]\n        }\n\n        self.query(import_query, params=parameters)\n\n        return ids\n\n    def _build_import_query(self) -> str:\n        \"\"\"\n        Build the Cypher import query string based on the Neo4j version.\n\n        Returns:\n            str: The constructed Cypher query string.\n        \"\"\"\n        if self.neo4j_version_is_5_23_or_above:\n            call_prefix = \"CALL (row) { \"\n        else:\n            call_prefix = \"CALL { WITH row \"\n\n        import_query = (\n            \"UNWIND $data AS row \"\n            f\"{call_prefix}\"\n            f\"MERGE (c:`{self.node_label}` {{id: row.id}}) \"\n            \"WITH c, row \"\n            f\"CALL db.create.setNodeVectorProperty(c, \"\n            f\"'{self.embedding_node_property}', row.embedding) \"\n            f\"SET c.`{self.text_node_property}` = row.text \"\n            \"SET c += row.metadata \"\n            \"} IN TRANSACTIONS OF 1000 ROWS \"\n        )\n\n        return import_query\n\n    def add_texts(\n        self,\n        texts: Iterable[str],\n        metadatas: Optional[List[dict]] = None,\n        ids: Optional[List[str]] = None,\n        **kwargs: Any,\n    ) -> List[str]:\n        \"\"\"Run more texts through the embeddings and add to the vectorstore.\n\n        Args:\n            texts: Iterable of strings to add to the vectorstore.\n            metadatas: Optional list of metadatas associated with the texts.\n            kwargs: vectorstore specific parameters\n\n        Returns:\n            List of ids from adding the texts into the vectorstore.\n        \"\"\"\n        embeddings = self.embedding.embed_documents(list(texts))\n        return self.add_embeddings(\n            texts=texts, embeddings=embeddings, metadatas=metadatas, ids=ids, **kwargs\n        )\n\n    def similarity_search(\n        self,\n        query: str,\n        k: int = 4,\n        params: Dict[str, Any] = {},\n        filter: Optional[Dict[str, Any]] = None,\n        effective_search_ratio: int = 1,\n        **kwargs: Any,\n    ) -> List[Document]:\n        \"\"\"Run similarity search with Neo4jVector.\n\n        Args:\n            query (str): Query text to search for.\n            k (int): Number of results to return. Defaults to 4.\n            params (Dict[str, Any]): The search params for the index type.\n                Defaults to empty dict.\n            filter (Optional[Dict[str, Any]]): Dictionary of argument(s) to\n                    filter on metadata.\n                Defaults to None.\n            effective_search_ratio (int): Controls the candidate pool size\n               by multiplying $k to balance query accuracy and performance.\n               Defaults to 1.\n        Returns:\n            List of Documents most similar to the query.\n        \"\"\"\n        embedding = self.embedding.embed_query(text=query)\n        return self.similarity_search_by_vector(\n            embedding=embedding,\n            k=k,\n            query=query,\n            params=params,\n            filter=filter,\n            effective_search_ratio=effective_search_ratio,\n            **kwargs,\n        )\n\n    def similarity_search_with_score(\n        self,\n        query: str,\n        k: int = 4,\n        params: Dict[str, Any] = {},\n        filter: Optional[Dict[str, Any]] = None,\n        effective_search_ratio: int = 1,\n        **kwargs: Any,\n    ) -> List[Tuple[Document, float]]:\n        \"\"\"Return docs most similar to query.\n\n        Args:\n            query: Text to look up documents similar to.\n            k: Number of Documents to return. Defaults to 4.\n            params (Dict[str, Any]): The search params for the index type.\n                Defaults to empty dict.\n            filter (Optional[Dict[str, Any]]): Dictionary of argument(s) to\n                    filter on metadata.\n                Defaults to None.\n            effective_search_ratio (int): Controls the candidate pool size\n               by multiplying $k to balance query accuracy and performance.\n               Defaults to 1.\n\n        Returns:\n            List of Documents most similar to the query and score for each\n        \"\"\"\n        embedding = self.embedding.embed_query(query)\n        docs = self.similarity_search_with_score_by_vector(\n            embedding=embedding,\n            k=k,\n            query=query,\n            params=params,\n            filter=filter,\n            effective_search_ratio=effective_search_ratio,\n            **kwargs,\n        )\n        return docs\n\n    def similarity_search_with_score_by_vector(\n        self,\n        embedding: List[float],\n        k: int = 4,\n        filter: Optional[Dict[str, Any]] = None,\n        params: Dict[str, Any] = {},\n        effective_search_ratio: int = 1,\n        **kwargs: Any,\n    ) -> List[Tuple[Document, float]]:\n        \"\"\"\n        Perform a similarity search in the Neo4j database using a\n        given vector and return the top k similar documents with their scores.\n\n        This method uses a Cypher query to find the top k documents that\n        are most similar to a given embedding. The similarity is measured\n        using a vector index in the Neo4j database. The results are returned\n        as a list of tuples, each containing a Document object and\n        its similarity score.\n\n        Args:\n            embedding (List[float]): The embedding vector to compare against.\n            k (int, optional): The number of top similar documents to retrieve.\n            filter (Optional[Dict[str, Any]]): Dictionary of argument(s) to\n                    filter on metadata.\n                Defaults to None.\n            params (Dict[str, Any]): The search params for the index type.\n                Defaults to empty dict.\n            effective_search_ratio (int): Controls the candidate pool size\n               by multiplying $k to balance query accuracy and performance.\n               Defaults to 1.\n\n        Returns:\n            List[Tuple[Document, float]]: A list of tuples, each containing\n                                a Document object and its similarity score.\n        \"\"\"\n        if filter and not self.support_metadata_filter:\n            raise ValueError(\n                \"Metadata filtering is only supported in \"\n                \"Neo4j version 5.18 or greater\"\n            )\n        entity_prefix = (\n            \"relationship\" if self._index_type == IndexType.RELATIONSHIP else \"node\"\n        )\n        default_retrieval = (\n            f\"RETURN {entity_prefix}.`{self.text_node_property}` AS text, score, \"\n            f\"{entity_prefix} \"\n            \"{.*, \"\n            f\"`{self.text_node_property}`: Null, \"\n            f\"`{self.embedding_node_property}`: Null, id: Null \"\n        )\n        if kwargs.get(\"return_embeddings\"):\n            default_retrieval += (\n                f\", _embedding_: {entity_prefix}.`{self.embedding_node_property}` \"\n            )\n        default_retrieval += \"} AS metadata\"\n        retrieval_query = (\n            self.retrieval_query if self.retrieval_query else default_retrieval\n        )\n\n        read_query, filter_params = get_search_query(\n            search_type=self.search_type,\n            entity_type=self._index_type,\n            retrieval_query=retrieval_query,\n            node_label=self.node_label,\n            embedding_node_property=self.embedding_node_property,\n            embedding_dimension=self.embedding_dimension,\n            filters=filter,\n            neo4j_version_is_5_23_or_above=self.neo4j_version_is_5_23_or_above,\n            use_parallel_runtime=self._is_enterprise,\n        )\n        parameters = {\n            \"vector_index_name\": self.index_name,\n            \"top_k\": k,\n            \"query_vector\": embedding,\n            \"fulltext_index_name\": self.keyword_index_name,\n            \"query_text\": remove_lucene_chars(kwargs[\"query\"]),\n            \"effective_search_ratio\": effective_search_ratio,\n            **params,\n            **filter_params,\n        }\n\n        results = self.query(read_query, params=parameters)\n\n        if any(result[\"text\"] is None for result in results):\n            if not self.retrieval_query:\n                raise ValueError(\n                    f\"Make sure that none of the `{self.text_node_property}` \"\n                    f\"properties on nodes with label `{self.node_label}` \"\n                    \"are missing or empty\"\n                )\n            else:\n                raise ValueError(\n                    \"Inspect the `retrieval_query` and ensure it doesn't \"\n                    \"return None for the `text` column\"\n                )\n        if kwargs.get(\"return_embeddings\") and any(\n            result[\"metadata\"][\"_embedding_\"] is None for result in results\n        ):\n            if not self.retrieval_query:\n                raise ValueError(\n                    f\"Make sure that none of the `{self.embedding_node_property}` \"\n                    f\"properties on nodes with label `{self.node_label}` \"\n                    \"are missing or empty\"\n                )\n            else:\n                raise ValueError(\n                    \"Inspect the `retrieval_query` and ensure it doesn't \"\n                    \"return None for the `_embedding_` metadata column\"\n                )\n\n        docs = [\n            (\n                Document(\n                    page_content=dict_to_yaml_str(result[\"text\"])\n                    if isinstance(result[\"text\"], dict)\n                    else result[\"text\"],\n                    metadata={\n                        k: v for k, v in result[\"metadata\"].items() if v is not None\n                    },\n                ),\n                result[\"score\"],\n            )\n            for result in results\n        ]\n        return docs\n\n    def similarity_search_by_vector(\n        self,\n        embedding: List[float],\n        k: int = 4,\n        filter: Optional[Dict[str, Any]] = None,\n        params: Dict[str, Any] = {},\n        effective_search_ratio: int = 1,\n        **kwargs: Any,\n    ) -> List[Document]:\n        \"\"\"Return docs most similar to embedding vector.\n\n        Args:\n            embedding: Embedding to look up documents similar to.\n            k: Number of Documents to return. Defaults to 4.\n            filter (Optional[Dict[str, Any]]): Dictionary of argument(s) to\n                    filter on metadata.\n                Defaults to None.\n            params (Dict[str, Any]): The search params for the index type.\n                Defaults to empty dict.\n\n        Returns:\n            List of Documents most similar to the query vector.\n        \"\"\"\n        docs_and_scores = self.similarity_search_with_score_by_vector(\n            embedding=embedding,\n            k=k,\n            filter=filter,\n            params=params,\n            effective_search_ratio=effective_search_ratio,\n            **kwargs,\n        )\n        return [doc for doc, _ in docs_and_scores]\n\n    @classmethod\n    def from_texts(\n        cls: Type[Neo4jVector],\n        texts: List[str],\n        embedding: Embeddings,\n        metadatas: Optional[List[dict]] = None,\n        distance_strategy: DistanceStrategy = DEFAULT_DISTANCE_STRATEGY,\n        ids: Optional[List[str]] = None,\n        **kwargs: Any,\n    ) -> Neo4jVector:\n        \"\"\"\n        Return Neo4jVector initialized from texts and embeddings.\n        Neo4j credentials are required in the form of `url`, `username`,\n        and `password` and optional `database` parameters.\n        \"\"\"\n        embeddings = embedding.embed_documents(list(texts))\n\n        return cls.__from(\n            texts,\n            embeddings,\n            embedding,\n            metadatas=metadatas,\n            ids=ids,\n            distance_strategy=distance_strategy,\n            **kwargs,\n        )\n\n    @classmethod\n    def from_embeddings(\n        cls,\n        text_embeddings: List[Tuple[str, List[float]]],\n        embedding: Embeddings,\n        metadatas: Optional[List[dict]] = None,\n        distance_strategy: DistanceStrategy = DEFAULT_DISTANCE_STRATEGY,\n        ids: Optional[List[str]] = None,\n        pre_delete_collection: bool = False,\n        **kwargs: Any,\n    ) -> Neo4jVector:\n        \"\"\"Construct Neo4jVector wrapper from raw documents and pre-\n        generated embeddings.\n\n        Return Neo4jVector initialized from documents and embeddings.\n        Neo4j credentials are required in the form of `url`, `username`,\n        and `password` and optional `database` parameters.\n\n        Example:\n            .. code-block:: python\n\n                from langchain_neo4j import Neo4jVector\n                from langchain_openai import OpenAIEmbeddings\n\n                embeddings = OpenAIEmbeddings()\n                text_embeddings = embeddings.embed_documents(texts)\n                text_embedding_pairs = list(zip(texts, text_embeddings))\n                vectorstore = Neo4jVector.from_embeddings(\n                    text_embedding_pairs, embeddings)\n        \"\"\"\n        texts = [t[0] for t in text_embeddings]\n        embeddings = [t[1] for t in text_embeddings]\n\n        return cls.__from(\n            texts,\n            embeddings,\n            embedding,\n            metadatas=metadatas,\n            ids=ids,\n            distance_strategy=distance_strategy,\n            pre_delete_collection=pre_delete_collection,\n            **kwargs,\n        )\n\n    @classmethod\n    def from_existing_index(\n        cls: Type[Neo4jVector],\n        embedding: Embeddings,\n        index_name: str,\n        search_type: SearchType = DEFAULT_SEARCH_TYPE,\n        keyword_index_name: Optional[str] = None,\n        embedding_dimension: Optional[int] = None,\n        **kwargs: Any,\n    ) -> Neo4jVector:\n        \"\"\"\n        Get instance of an existing Neo4j vector index. This method will\n        return the instance of the store without inserting any new\n        embeddings.\n        Neo4j credentials are required in the form of `url`, `username`,\n        and `password` and optional `database` parameters along with\n        the `index_name` definition.\n        \"\"\"\n\n        if search_type == SearchType.HYBRID and not keyword_index_name:\n            raise ValueError(\n                \"keyword_index name has to be specified \"\n                \"when using hybrid search option\"\n            )\n\n        store = cls(\n            embedding=embedding,\n            index_name=index_name,\n            keyword_index_name=keyword_index_name,\n            search_type=search_type,\n            embedding_dimension=embedding_dimension,\n            **kwargs,\n        )\n\n        # Check if the vector index already exists\n        existing_index_info = store.retrieve_existing_index()\n        if existing_index_info:\n            embedding_dimension_from_existing, index_type = existing_index_info\n        else:\n            embedding_dimension_from_existing = None\n            index_type = None\n\n        if embedding_dimension:\n            if embedding_dimension_from_existing != embedding_dimension:\n                raise ValueError(\n                    \"The provided embedding function and vector index \"\n                    \"dimensions do not match.\\n\"\n                    f\"Embedding function dimension: {embedding_dimension}\\n\"\n                    f\"Vector index dimension: {embedding_dimension_from_existing}\"\n                )\n        else:\n            embedding_dimension = embedding_dimension_from_existing\n\n        # Raise error if relationship index type\n        if index_type == \"RELATIONSHIP\":\n            raise ValueError(\n                \"Relationship vector index is not supported with \"\n                \"`from_existing_index` method. Please use the \"\n                \"`from_existing_relationship_index` method.\"\n            )\n\n        if not index_type:\n            raise ValueError(\n                \"The specified vector index name does not exist. \"\n                \"Make sure to check if you spelled it correctly\"\n            )\n\n        # Check if embedding function and vector index dimensions match\n        if embedding_dimension and not store.embedding_dimension == embedding_dimension:\n            raise ValueError(\n                \"The provided embedding function and vector index \"\n                \"dimensions do not match.\\n\"\n                f\"Embedding function dimension: {store.embedding_dimension}\\n\"\n                f\"Vector index dimension: {embedding_dimension}\"\n            )\n\n        if search_type == SearchType.HYBRID:\n            fts_node_label = store.retrieve_existing_fts_index()\n            # If the FTS index doesn't exist yet\n            if not fts_node_label:\n                raise ValueError(\n                    \"The specified keyword index name does not exist. \"\n                    \"Make sure to check if you spelled it correctly\"\n                )\n            else:  # Validate that FTS and Vector index use the same information\n                if not fts_node_label == store.node_label:\n                    raise ValueError(\n                        \"Vector and keyword index don't index the same node label\"\n                    )\n\n        return store\n\n    @classmethod\n    def from_existing_relationship_index(\n        cls: Type[Neo4jVector],\n        embedding: Embeddings,\n        index_name: str,\n        search_type: SearchType = DEFAULT_SEARCH_TYPE,\n        embedding_dimension: Optional[int] = None,\n        **kwargs: Any,\n    ) -> Neo4jVector:\n        \"\"\"\n        Get instance of an existing Neo4j relationship vector index.\n        This method will return the instance of the store without\n        inserting any new embeddings.\n        Neo4j credentials are required in the form of `url`, `username`,\n        and `password` and optional `database` parameters along with\n        the `index_name` definition.\n        \"\"\"\n\n        if search_type == SearchType.HYBRID:\n            raise ValueError(\n                \"Hybrid search is not supported in combination \"\n                \"with relationship vector index\"\n            )\n\n        store = cls(\n            embedding=embedding,\n            index_name=index_name,\n            embedding_dimension=embedding_dimension,\n            **kwargs,\n        )\n\n        # Check if the vector index already exists\n        existing_index_info = store.retrieve_existing_index()\n        if existing_index_info:\n            embedding_dimension_from_existing, index_type = existing_index_info\n        else:\n            embedding_dimension_from_existing = None\n            index_type = None\n\n        if embedding_dimension:\n            if embedding_dimension_from_existing != embedding_dimension:\n                raise ValueError(\n                    \"The provided embedding function and vector index \"\n                    \"dimensions do not match.\\n\"\n                    f\"Embedding function dimension: {embedding_dimension}\\n\"\n                    f\"Vector index dimension: {embedding_dimension_from_existing}\"\n                )\n        else:\n            embedding_dimension = embedding_dimension_from_existing\n\n        if not index_type:\n            raise ValueError(\n                \"The specified vector index name does not exist. \"\n                \"Make sure to check if you spelled it correctly\"\n            )\n        # Raise error if relationship index type\n        if index_type == \"NODE\":\n            raise ValueError(\n                \"Node vector index is not supported with \"\n                \"`from_existing_relationship_index` method. Please use the \"\n                \"`from_existing_index` method.\"\n            )\n\n        # Check if embedding function and vector index dimensions match\n        if embedding_dimension and not store.embedding_dimension == embedding_dimension:\n            raise ValueError(\n                \"The provided embedding function and vector index \"\n                \"dimensions do not match.\\n\"\n                f\"Embedding function dimension: {store.embedding_dimension}\\n\"\n                f\"Vector index dimension: {embedding_dimension}\"\n            )\n\n        return store\n\n    @classmethod\n    def from_documents(\n        cls: Type[Neo4jVector],\n        documents: List[Document],\n        embedding: Embeddings,\n        distance_strategy: DistanceStrategy = DEFAULT_DISTANCE_STRATEGY,\n        ids: Optional[List[str]] = None,\n        **kwargs: Any,\n    ) -> Neo4jVector:\n        \"\"\"\n        Return Neo4jVector initialized from documents and embeddings.\n        Neo4j credentials are required in the form of `url`, `username`,\n        and `password` and optional `database` parameters.\n        \"\"\"\n\n        texts = [d.page_content for d in documents]\n        metadatas = [d.metadata for d in documents]\n\n        return cls.from_texts(\n            texts=texts,\n            embedding=embedding,\n            distance_strategy=distance_strategy,\n            metadatas=metadatas,\n            ids=ids,\n            **kwargs,\n        )\n\n    @classmethod\n    def from_existing_graph(\n        cls: Type[Neo4jVector],\n        embedding: Embeddings,\n        node_label: str,\n        embedding_node_property: str,\n        text_node_properties: List[str],\n        *,\n        keyword_index_name: Optional[str] = \"keyword\",\n        index_name: str = \"vector\",\n        search_type: SearchType = DEFAULT_SEARCH_TYPE,\n        retrieval_query: str = \"\",\n        **kwargs: Any,\n    ) -> Neo4jVector:\n        \"\"\"\n        Initialize and return a Neo4jVector instance from an existing graph.\n\n        This method initializes a Neo4jVector instance using the provided\n        parameters and the existing graph. It validates the existence of\n        the indices and creates new ones if they don't exist.\n\n        Returns:\n        Neo4jVector: An instance of Neo4jVector initialized with the provided parameters\n                    and existing graph.\n\n        Example:\n        >>> neo4j_vector = Neo4jVector.from_existing_graph(\n        ...     embedding=my_embedding,\n        ...     node_label=\"Document\",\n        ...     embedding_node_property=\"embedding\",\n        ...     text_node_properties=[\"title\", \"content\"]\n        ... )\n\n        Note:\n        Neo4j credentials are required in the form of `url`, `username`, and `password`,\n        and optional `database` parameters passed as additional keyword arguments.\n        \"\"\"\n        # Validate the list is not empty\n        if not text_node_properties:\n            raise ValueError(\n                \"Parameter `text_node_properties` must not be an empty list\"\n            )\n        # Prefer retrieval query from params, otherwise construct it\n        if not retrieval_query:\n            retrieval_query = (\n                f\"RETURN reduce(str='', k IN {text_node_properties} |\"\n                \" str + '\\\\n' + k + ': ' + coalesce(node[k], '')) AS text, \"\n                \"node {.*, `\"\n                + embedding_node_property\n                + \"`: Null, id: Null, \"\n                + \", \".join([f\"`{prop}`: Null\" for prop in text_node_properties])\n                + \"} AS metadata, score\"\n            )\n        store = cls(\n            embedding=embedding,\n            index_name=index_name,\n            keyword_index_name=keyword_index_name,\n            search_type=search_type,\n            retrieval_query=retrieval_query,\n            node_label=node_label,\n            embedding_node_property=embedding_node_property,\n            **kwargs,\n        )\n\n        # Check if the vector index already exists\n        existing_index_info = store.retrieve_existing_index()\n        if existing_index_info:\n            embedding_dimension, index_type = existing_index_info\n        else:\n            embedding_dimension = None\n            index_type = None\n\n        # Raise error if relationship index type\n        if index_type == \"RELATIONSHIP\":\n            raise ValueError(\n                \"`from_existing_graph` method does not support \"\n                \" existing relationship vector index. \"\n                \"Please use `from_existing_relationship_index` method\"\n            )\n\n        # If the vector index doesn't exist yet\n        if not index_type:\n            store.create_new_index()\n        # If the index already exists, check if embedding dimensions match\n        elif (\n            embedding_dimension and not store.embedding_dimension == embedding_dimension\n        ):\n            raise ValueError(\n                f\"Index with name {store.index_name} already exists. \"\n                \"The provided embedding function and vector index \"\n                \"dimensions do not match.\\n\"\n                f\"Embedding function dimension: {store.embedding_dimension}\\n\"\n                f\"Vector index dimension: {embedding_dimension}\"\n            )\n        # FTS index for Hybrid search\n        if search_type == SearchType.HYBRID:\n            fts_node_label = store.retrieve_existing_fts_index(text_node_properties)\n            # If the FTS index doesn't exist yet\n            if not fts_node_label:\n                store.create_new_keyword_index(text_node_properties)\n            else:  # Validate that FTS and Vector index use the same information\n                if not fts_node_label == store.node_label:\n                    raise ValueError(\n                        \"Vector and keyword index don't index the same node label\"\n                    )\n\n        # Populate embeddings\n        while True:\n            fetch_query = (\n                f\"MATCH (n:`{node_label}`) \"\n                f\"WHERE n.{embedding_node_property} IS null \"\n                \"AND any(k in $props WHERE n[k] IS NOT null) \"\n                f\"RETURN elementId(n) AS id, reduce(str='',\"\n                \"k IN $props | str + '\\\\n' + k + ':' + coalesce(n[k], '')) AS text \"\n                \"LIMIT 1000\"\n            )\n            data = store.query(fetch_query, params={\"props\": text_node_properties})\n            if not data:\n                break\n            text_embeddings = embedding.embed_documents([el[\"text\"] for el in data])\n\n            params = {\n                \"data\": [\n                    {\"id\": el[\"id\"], \"embedding\": embedding}\n                    for el, embedding in zip(data, text_embeddings)\n                ]\n            }\n\n            store.query(\n                \"UNWIND $data AS row \"\n                f\"MATCH (n:`{node_label}`) \"\n                \"WHERE elementId(n) = row.id \"\n                f\"CALL db.create.setNodeVectorProperty(n, \"\n                f\"'{embedding_node_property}', row.embedding) \"\n                \"RETURN count(*)\",\n                params=params,\n            )\n            # If embedding calculation should be stopped\n            if len(data) < 1000:\n                break\n        return store\n\n    def max_marginal_relevance_search(\n        self,\n        query: str,\n        k: int = 4,\n        fetch_k: int = 20,\n        lambda_mult: float = 0.5,\n        filter: Optional[dict] = None,\n        **kwargs: Any,\n    ) -> List[Document]:\n        \"\"\"Return docs selected using the maximal marginal relevance.\n\n        Maximal marginal relevance optimizes for similarity to query AND diversity\n        among selected documents.\n\n        Args:\n            query: search query text.\n            k: Number of Documents to return. Defaults to 4.\n            fetch_k: Number of Documents to fetch to pass to MMR algorithm.\n            lambda_mult: Number between 0 and 1 that determines the degree\n                        of diversity among the results with 0 corresponding\n                        to maximum diversity and 1 to minimum diversity.\n                        Defaults to 0.5.\n            filter: Filter on metadata properties, e.g.\n                            {\n                                \"str_property\": \"foo\",\n                                \"int_property\": 123\n                            }\n        Returns:\n            List of Documents selected by maximal marginal relevance.\n        \"\"\"\n        # Embed the query\n        query_embedding = self.embedding.embed_query(query)\n\n        # Fetch the initial documents\n        got_docs = self.similarity_search_with_score_by_vector(\n            embedding=query_embedding,\n            query=query,\n            k=fetch_k,\n            return_embeddings=True,\n            filter=filter,\n            **kwargs,\n        )\n\n        # Get the embeddings for the fetched documents\n        got_embeddings = [doc.metadata[\"_embedding_\"] for doc, _ in got_docs]\n\n        # Select documents using maximal marginal relevance\n        selected_indices = maximal_marginal_relevance(\n            np.array(query_embedding), got_embeddings, lambda_mult=lambda_mult, k=k\n        )\n        selected_docs = [got_docs[i][0] for i in selected_indices]\n\n        # Remove embedding values from metadata\n        for doc in selected_docs:\n            del doc.metadata[\"_embedding_\"]\n\n        return selected_docs\n\n    def _select_relevance_score_fn(self) -> Callable[[float], float]:\n        \"\"\"\n        The 'correct' relevance function\n        may differ depending on a few things, including:\n        - the distance / similarity metric used by the VectorStore\n        - the scale of your embeddings (OpenAI's are unit normed. Many others are not!)\n        - embedding dimensionality\n        - etc.\n        \"\"\"\n        if self.override_relevance_score_fn is not None:\n            return self.override_relevance_score_fn\n\n        # Default strategy is to rely on distance strategy provided\n        # in vectorstore constructor\n        if self._distance_strategy == DistanceStrategy.COSINE:\n            return lambda x: x\n        elif self._distance_strategy == DistanceStrategy.EUCLIDEAN_DISTANCE:\n            return lambda x: x\n        else:\n            raise ValueError(\n                \"No supported normalization function\"\n                f\" for distance_strategy of {self._distance_strategy}.\"\n                \"Consider providing relevance_score_fn to PGVector constructor.\"\n            )","inst_variables":[{"var":"schema","type":null,"value":"''","lineno":238},{"var":"_is_enterprise","type":null,"value":"False","lineno":240},{"var":"embedding","type":null,"value":"embedding","lineno":254},{"var":"_distance_strategy","type":null,"value":"distance_strategy","lineno":255},{"var":"index_name","type":null,"value":"index_name","lineno":256},{"var":"keyword_index_name","type":null,"value":"keyword_index_name","lineno":257},{"var":"node_label","type":null,"value":"node_label","lineno":258},{"var":"embedding_node_property","type":null,"value":"embedding_node_property","lineno":259},{"var":"text_node_property","type":null,"value":"text_node_property","lineno":260},{"var":"logger","type":null,"value":"logger or logging.getLogger(__name__)","lineno":261},{"var":"override_relevance_score_fn","type":null,"value":"relevance_score_fn","lineno":262},{"var":"retrieval_query","type":null,"value":"retrieval_query","lineno":263},{"var":"search_type","type":null,"value":"search_type","lineno":264},{"var":"_index_type","type":null,"value":"index_type","lineno":265},{"var":"_driver","type":null,"value":"graph._driver","lineno":203},{"var":"_database","type":null,"value":"graph._database","lineno":204},{"var":"_driver","type":null,"value":"neo4j.GraphDatabase.driver(url, auth=(username, password))","lineno":222},{"var":"_database","type":null,"value":"database","lineno":223},{"var":"embedding_dimension","type":null,"value":"embedding_dimension","lineno":268},{"var":"embedding_dimension","type":null,"value":"len(embedding.embed_query('foo'))","lineno":271}],"reason":"Vector store implementation using Neo4j, providing embedding storage, similarity search (including hybrid search), index management, and utility methods for ingestion and retrieval of vectorized documents.","reason_kor":"Neo4j를 사용하는 벡터 저장소 구현체로, 임베딩 저장, 유사도 검색(하이브리드 검색 포함), 인덱스 관리, 벡터화된 문서의 삽입 및 검색을 위한 유틸리티 메서드를 제공합니다."},{"_key":"langchain_neo4j_vectorstores_neo4j_vector_py___from","_id":"nodes/langchain_neo4j_vectorstores_neo4j_vector_py___from","_rev":"_jzRpK6W---","type":"function","name":"__from","defined_in":"langchain_neo4j_vectorstores_neo4j_vector_py","lineno":474,"source":"def __from(\n        cls,\n        texts: List[str],\n        embeddings: List[List[float]],\n        embedding: Embeddings,\n        metadatas: Optional[List[dict]] = None,\n        ids: Optional[List[str]] = None,\n        create_id_index: bool = True,\n        search_type: SearchType = SearchType.VECTOR,\n        **kwargs: Any,\n    ) -> Neo4jVector:\n        if ids is None:\n            ids = [md5(text.encode(\"utf-8\")).hexdigest() for text in texts]\n\n        if not metadatas:\n            metadatas = [{} for _ in texts]\n\n        store = cls(\n            embedding=embedding,\n            search_type=search_type,\n            **kwargs,\n        )\n\n        # Check if the vector index already exists\n        existing_index_info = store.retrieve_existing_index()\n        if existing_index_info:\n            embedding_dimension, index_type = existing_index_info\n        else:\n            embedding_dimension = None\n            index_type = None\n\n        # Raise error if relationship index type\n        if index_type == \"RELATIONSHIP\":\n            raise ValueError(\n                \"Data ingestion is not supported with relationship vector index.\"\n            )\n\n        # If the vector index doesn't exist yet\n        if not index_type:\n            store.create_new_index()\n        # If the index already exists, check if embedding dimensions match\n        elif (\n            embedding_dimension and not store.embedding_dimension == embedding_dimension\n        ):\n            raise ValueError(\n                f\"Index with name {store.index_name} already exists. \"\n                \"The provided embedding function and vector index \"\n                \"dimensions do not match.\\n\"\n                f\"Embedding function dimension: {store.embedding_dimension}\\n\"\n                f\"Vector index dimension: {embedding_dimension}\"\n            )\n\n        if search_type == SearchType.HYBRID:\n            fts_node_label = store.retrieve_existing_fts_index()\n            # If the FTS index doesn't exist yet\n            if not fts_node_label:\n                store.create_new_keyword_index()\n            else:  # Validate that FTS and Vector index use the same information\n                if not fts_node_label == store.node_label:\n                    raise ValueError(\n                        \"Vector and keyword index don't index the same node label\"\n                    )\n\n        # Create unique constraint for faster import\n        if create_id_index:\n            store.query(\n                \"CREATE CONSTRAINT IF NOT EXISTS \"\n                f\"FOR (n:`{store.node_label}`) REQUIRE n.id IS UNIQUE;\"\n            )\n\n        store.add_embeddings(\n            texts=texts, embeddings=embeddings, metadatas=metadatas, ids=ids, **kwargs\n        )\n\n        return store","docstring":null,"args":[{"arg":"cls","type":null},{"arg":"texts","type":"List[str]"},{"arg":"embeddings","type":"List[List[float]]"},{"arg":"embedding","type":"Embeddings"},{"arg":"metadatas","type":"Optional[List[dict]]"},{"arg":"ids","type":"Optional[List[str]]"},{"arg":"create_id_index","type":"bool"},{"arg":"search_type","type":"SearchType"}],"return_type":"Neo4jVector","control_flow":[{"type":"if","lineno":485},{"type":"if","lineno":488},{"type":"if","lineno":499},{"type":"if","lineno":506},{"type":"if","lineno":512},{"type":"if","lineno":515},{"type":"if","lineno":526},{"type":"if","lineno":529},{"type":"if","lineno":532},{"type":"if","lineno":538}],"reason":"it is about initialization, validation, index management, and embedding addition for a Neo4j vector store class. The method checks for existing indices, matches embedding dimensions, handles different search types including hybrid, creates constraints, and finally adds the embedding data to the store.","reason_kor":"Neo4j 벡터 스토어 클래스 초기화, 검증, 인덱스 관리, 임베딩 추가 과정을 포함하며, 기존 인덱스 확인, 임베딩 차원 일치, 하이브리드 검색 처리, 제약 조건 생성 및 임베딩 데이터 추가를 수행합니다."},{"_key":"langchain_neo4j_vectorstores_neo4j_vector_py___init__","_id":"nodes/langchain_neo4j_vectorstores_neo4j_vector_py___init__","_rev":"_jzRpK6i---","type":"function","name":"__init__","defined_in":"langchain_neo4j_vectorstores_neo4j_vector_py","lineno":169,"source":"def __init__(\n        self,\n        embedding: Embeddings,\n        *,\n        search_type: SearchType = SearchType.VECTOR,\n        username: Optional[str] = None,\n        password: Optional[str] = None,\n        url: Optional[str] = None,\n        keyword_index_name: Optional[str] = \"keyword\",\n        database: Optional[str] = None,\n        index_name: str = \"vector\",\n        node_label: str = \"Chunk\",\n        embedding_node_property: str = \"embedding\",\n        text_node_property: str = \"text\",\n        distance_strategy: DistanceStrategy = DEFAULT_DISTANCE_STRATEGY,\n        logger: Optional[logging.Logger] = None,\n        pre_delete_collection: bool = False,\n        retrieval_query: str = \"\",\n        relevance_score_fn: Optional[Callable[[float], float]] = None,\n        index_type: IndexType = DEFAULT_INDEX_TYPE,\n        graph: Optional[Neo4jGraph] = None,\n        embedding_dimension: Optional[int] = None,\n    ) -> None:\n        # Allow only cosine and euclidean distance strategies\n        if distance_strategy not in [\n            DistanceStrategy.EUCLIDEAN_DISTANCE,\n            DistanceStrategy.COSINE,\n        ]:\n            raise ValueError(\n                \"distance_strategy must be either 'EUCLIDEAN_DISTANCE' or 'COSINE'\"\n            )\n\n        # Graph object takes precedent over env or input params\n        if graph:\n            self._driver = graph._driver\n            self._database = graph._database\n        else:\n            # Handle if the credentials are environment variables\n            # Support URL for backwards compatibility\n            if not url:\n                url = os.environ.get(\"NEO4J_URL\")\n\n            url = get_from_dict_or_env({\"url\": url}, \"url\", \"NEO4J_URI\")\n            username = get_from_dict_or_env(\n                {\"username\": username}, \"username\", \"NEO4J_USERNAME\"\n            )\n            password = get_from_dict_or_env(\n                {\"password\": password}, \"password\", \"NEO4J_PASSWORD\"\n            )\n            database = get_from_dict_or_env(\n                {\"database\": database}, \"database\", \"NEO4J_DATABASE\", \"neo4j\"\n            )\n\n            self._driver = neo4j.GraphDatabase.driver(url, auth=(username, password))\n            self._database = database\n            # Verify connection\n            try:\n                self._driver.verify_connectivity()\n            except neo4j.exceptions.ServiceUnavailable:\n                raise ValueError(\n                    \"Could not connect to Neo4j database. \"\n                    \"Please ensure that the url is correct\"\n                )\n            except neo4j.exceptions.AuthError:\n                raise ValueError(\n                    \"Could not connect to Neo4j database. \"\n                    \"Please ensure that the username and password are correct\"\n                )\n\n        self.schema = \"\"\n        # Verify if the version support vector index\n        self._is_enterprise = False\n        self.verify_version()\n\n        # Verify that required values are not null\n        check_if_not_null(\n            [\n                \"index_name\",\n                \"node_label\",\n                \"embedding_node_property\",\n                \"text_node_property\",\n            ],\n            [index_name, node_label, embedding_node_property, text_node_property],\n        )\n\n        self.embedding = embedding\n        self._distance_strategy = distance_strategy\n        self.index_name = index_name\n        self.keyword_index_name = keyword_index_name\n        self.node_label = node_label\n        self.embedding_node_property = embedding_node_property\n        self.text_node_property = text_node_property\n        self.logger = logger or logging.getLogger(__name__)\n        self.override_relevance_score_fn = relevance_score_fn\n        self.retrieval_query = retrieval_query\n        self.search_type = search_type\n        self._index_type = index_type\n\n        if embedding_dimension:\n            self.embedding_dimension = embedding_dimension\n        else:\n            # Calculate embedding dimension\n            self.embedding_dimension = len(embedding.embed_query(\"foo\"))\n\n        # Delete existing data if flagged\n        if pre_delete_collection:\n            from neo4j.exceptions import DatabaseError\n\n            delete_query = self._build_delete_query()\n            self.query(delete_query)\n            # Delete index\n            try:\n                self.query(f\"DROP INDEX {self.index_name}\")\n            except DatabaseError:  # Index didn't exist yet\n                pass","docstring":null,"args":[{"arg":"self","type":null},{"arg":"embedding","type":"Embeddings"}],"return_type":"None","control_flow":[{"type":"if","lineno":193},{"type":"if","lineno":202},{"type":"if","lineno":208},{"type":"try","lineno":225},{"type":"if","lineno":267},{"type":"if","lineno":274},{"type":"try","lineno":280}],"reason":"it is about a class constructor (__init__) that initializes a Neo4j graph client, validates connection and version compatibility, sets up various parameters for vector and keyword search, handles environment variables and optional graph object, checks distance strategy, and deletes pre-existing data if specified.","reason_kor":"Neo4j 그래프 클라이언트를 초기화하고 연결 및 버전 호환성을 검증하며 벡터 및 키워드 검색을 위한 다양한 매개변수를 설정, 환경 변수와 선택적 그래프 객체를 처리하고 거리 전략을 점검하며, 지정 시 기존 데이터를 삭제하는 클래스 생성자 메서드를 결합합니다."},{"_key":"langchain_neo4j_vectorstores_neo4j_vector_py__build_delete_query","_id":"nodes/langchain_neo4j_vectorstores_neo4j_vector_py__build_delete_query","_rev":"_jzRpK6y---","type":"function","name":"_build_delete_query","defined_in":"langchain_neo4j_vectorstores_neo4j_vector_py","lineno":285,"source":"def _build_delete_query(self) -> str:\n        if self.neo4j_version_is_5_23_or_above:\n            call_prefix = \"CALL (n) {\"\n        else:\n            call_prefix = \"CALL { WITH n\"\n        return (\n            f\"MATCH (n:`{self.node_label}`) \"\n            f\"{call_prefix} DETACH DELETE n \"\n            \"} IN TRANSACTIONS OF 10000 ROWS;\"\n        )","docstring":null,"args":[{"arg":"self","type":null}],"return_type":"str","control_flow":[{"type":"if","lineno":286}],"reason":"Helper method to build the Cypher query string for deleting nodes in batches, adapted for Neo4j version differences.","reason_kor":"Neo4j 버전 차이에 맞게 노드를 일괄 삭제하는 Cypher 쿼리 문자열을 생성하는 헬퍼 메서드입니다."},{"_key":"langchain_neo4j_vectorstores_neo4j_vector_py__build_import_query","_id":"nodes/langchain_neo4j_vectorstores_neo4j_vector_py__build_import_query","_rev":"_jzRpK7----","type":"function","name":"_build_import_query","defined_in":"langchain_neo4j_vectorstores_neo4j_vector_py","lineno":587,"source":"def _build_import_query(self) -> str:\n        \"\"\"\n        Build the Cypher import query string based on the Neo4j version.\n\n        Returns:\n            str: The constructed Cypher query string.\n        \"\"\"\n        if self.neo4j_version_is_5_23_or_above:\n            call_prefix = \"CALL (row) { \"\n        else:\n            call_prefix = \"CALL { WITH row \"\n\n        import_query = (\n            \"UNWIND $data AS row \"\n            f\"{call_prefix}\"\n            f\"MERGE (c:`{self.node_label}` {{id: row.id}}) \"\n            \"WITH c, row \"\n            f\"CALL db.create.setNodeVectorProperty(c, \"\n            f\"'{self.embedding_node_property}', row.embedding) \"\n            f\"SET c.`{self.text_node_property}` = row.text \"\n            \"SET c += row.metadata \"\n            \"} IN TRANSACTIONS OF 1000 ROWS \"\n        )\n\n        return import_query","docstring":"Build the Cypher import query string based on the Neo4j version.\n\nReturns:\n    str: The constructed Cypher query string.","args":[{"arg":"self","type":null}],"return_type":"str","control_flow":[{"type":"if","lineno":594}],"reason":"Helper method to build the Cypher query string for importing nodes with embeddings, including version compatibility and transactional batching.","reason_kor":"임베딩이 포함된 노드를 삽입하는 Cypher 쿼리 문자열을 버전 호환성과 트랜잭션 배칭을 고려하여 생성하는 헬퍼 메서드입니다."},{"_key":"langchain_neo4j_vectorstores_neo4j_vector_py__select_relevance_score_fn","_id":"nodes/langchain_neo4j_vectorstores_neo4j_vector_py__select_relevance_score_fn","_rev":"_jzRpK7K---","type":"function","name":"_select_relevance_score_fn","defined_in":"langchain_neo4j_vectorstores_neo4j_vector_py","lineno":1332,"source":"def _select_relevance_score_fn(self) -> Callable[[float], float]:\n        \"\"\"\n        The 'correct' relevance function\n        may differ depending on a few things, including:\n        - the distance / similarity metric used by the VectorStore\n        - the scale of your embeddings (OpenAI's are unit normed. Many others are not!)\n        - embedding dimensionality\n        - etc.\n        \"\"\"\n        if self.override_relevance_score_fn is not None:\n            return self.override_relevance_score_fn\n\n        # Default strategy is to rely on distance strategy provided\n        # in vectorstore constructor\n        if self._distance_strategy == DistanceStrategy.COSINE:\n            return lambda x: x\n        elif self._distance_strategy == DistanceStrategy.EUCLIDEAN_DISTANCE:\n            return lambda x: x\n        else:\n            raise ValueError(\n                \"No supported normalization function\"\n                f\" for distance_strategy of {self._distance_strategy}.\"\n                \"Consider providing relevance_score_fn to PGVector constructor.\"\n            )","docstring":"The 'correct' relevance function\nmay differ depending on a few things, including:\n- the distance / similarity metric used by the VectorStore\n- the scale of your embeddings (OpenAI's are unit normed. Many others are not!)\n- embedding dimensionality\n- etc.","args":[{"arg":"self","type":null}],"return_type":"Callable[[float], float]","control_flow":[{"type":"if","lineno":1341},{"type":"if","lineno":1346},{"type":"if","lineno":1348}],"reason":"it is about the default behavior of selecting a relevance scoring function based on a user-provided override or the distance strategy (COSINE or EUCLIDEAN_DISTANCE), and raises an error if the distance strategy is unsupported.","reason_kor":"사용자 지정 재정의 함수 또는 거리 전략(COSINE, EUCLIDEAN_DISTANCE)에 따라 기본 관련성 점수 함수를 선택하고, 지원되지 않는 거리 전략일 경우 오류를 발생시킴"},{"_key":"langchain_neo4j_vectorstores_neo4j_vector_py_add_embeddings","_id":"nodes/langchain_neo4j_vectorstores_neo4j_vector_py_add_embeddings","_rev":"_jzRpK7W---","type":"function","name":"add_embeddings","defined_in":"langchain_neo4j_vectorstores_neo4j_vector_py","lineno":550,"source":"def add_embeddings(\n        self,\n        texts: Iterable[str],\n        embeddings: List[List[float]],\n        metadatas: Optional[List[dict]] = None,\n        ids: Optional[List[str]] = None,\n        **kwargs: Any,\n    ) -> List[str]:\n        \"\"\"Add embeddings to the vectorstore.\n\n        Args:\n            texts: Iterable of strings to add to the vectorstore.\n            embeddings: List of list of embedding vectors.\n            metadatas: List of metadatas associated with the texts.\n            kwargs: vectorstore specific parameters\n        \"\"\"\n        if ids is None:\n            ids = [md5(text.encode(\"utf-8\")).hexdigest() for text in texts]\n\n        if not metadatas:\n            metadatas = [{} for _ in texts]\n\n        import_query = self._build_import_query()\n\n        parameters = {\n            \"data\": [\n                {\"text\": text, \"metadata\": metadata, \"embedding\": embedding, \"id\": id}\n                for text, metadata, embedding, id in zip(\n                    texts, metadatas, embeddings, ids\n                )\n            ]\n        }\n\n        self.query(import_query, params=parameters)\n\n        return ids","docstring":"Add embeddings to the vectorstore.\n\nArgs:\n    texts: Iterable of strings to add to the vectorstore.\n    embeddings: List of list of embedding vectors.\n    metadatas: List of metadatas associated with the texts.\n    kwargs: vectorstore specific parameters","args":[{"arg":"self","type":null},{"arg":"texts","type":"Iterable[str]"},{"arg":"embeddings","type":"List[List[float]]"},{"arg":"metadatas","type":"Optional[List[dict]]"},{"arg":"ids","type":"Optional[List[str]]"}],"return_type":"List[str]","control_flow":[{"type":"if","lineno":566},{"type":"if","lineno":569}],"reason":"it is about multiple optional parameters (ids, metadatas) with default handling, then built a structured data dictionary containing texts, metadata, embeddings, and ids, and finally sent an import query to add these embeddings to the vectorstore, returning the generated or provided ids.","reason_kor":"여러 선택적 매개변수(ids, 메타데이터 포함)를 처리하며, 텍스트, 메타데이터, 임베딩, id를 포함하는 구조화된 데이터 사전을 생성하고 임베딩을 벡터 스토어에 추가하기 위한 가져오기 쿼리를 전송하며 생성되거나 제공된 id를 반환합니다."},{"_key":"langchain_neo4j_vectorstores_neo4j_vector_py_add_texts","_id":"nodes/langchain_neo4j_vectorstores_neo4j_vector_py_add_texts","_rev":"_jzRpK7i---","type":"function","name":"add_texts","defined_in":"langchain_neo4j_vectorstores_neo4j_vector_py","lineno":613,"source":"def add_texts(\n        self,\n        texts: Iterable[str],\n        metadatas: Optional[List[dict]] = None,\n        ids: Optional[List[str]] = None,\n        **kwargs: Any,\n    ) -> List[str]:\n        \"\"\"Run more texts through the embeddings and add to the vectorstore.\n\n        Args:\n            texts: Iterable of strings to add to the vectorstore.\n            metadatas: Optional list of metadatas associated with the texts.\n            kwargs: vectorstore specific parameters\n\n        Returns:\n            List of ids from adding the texts into the vectorstore.\n        \"\"\"\n        embeddings = self.embedding.embed_documents(list(texts))\n        return self.add_embeddings(\n            texts=texts, embeddings=embeddings, metadatas=metadatas, ids=ids, **kwargs\n        )","docstring":"Run more texts through the embeddings and add to the vectorstore.\n\nArgs:\n    texts: Iterable of strings to add to the vectorstore.\n    metadatas: Optional list of metadatas associated with the texts.\n    kwargs: vectorstore specific parameters\n\nReturns:\n    List of ids from adding the texts into the vectorstore.","args":[{"arg":"self","type":null},{"arg":"texts","type":"Iterable[str]"},{"arg":"metadatas","type":"Optional[List[dict]]"},{"arg":"ids","type":"Optional[List[str]]"}],"return_type":"List[str]","control_flow":[],"reason":"it is about inputs such as texts, optional metadatas, and ids with additional keyword arguments, then computed embeddings for the texts using 'embed_documents'. It subsequently added these texts and their embeddings to the vectorstore using 'add_embeddings', returning a list of assigned ids.","reason_kor":"텍스트, 선택적 메타데이터, ids 및 추가 키워드 인자를 입력으로 받아 'embed_documents'를 사용해 텍스트 임베딩을 계산하고, 이후 'add_embeddings'를 사용해 텍스트와 임베딩을 벡터 스토어에 추가하여 할당된 id 목록을 반환합니다."},{"_key":"langchain_neo4j_vectorstores_neo4j_vector_py_check_if_not_null","_id":"nodes/langchain_neo4j_vectorstores_neo4j_vector_py_check_if_not_null","_rev":"_jzRpK7u---","type":"function","name":"check_if_not_null","defined_in":"langchain_neo4j_vectorstores_neo4j_vector_py","lineno":54,"source":"def check_if_not_null(props: List[str], values: List[Any]) -> None:\n    \"\"\"Check if the values are not None or empty string\"\"\"\n    for prop, value in zip(props, values):\n        if not value:\n            raise ValueError(f\"Parameter `{prop}` must not be None or empty string\")","docstring":"Check if the values are not None or empty string","args":[{"arg":"props","type":"List[str]"},{"arg":"values","type":"List[Any]"}],"return_type":"None","control_flow":[{"type":"for","lineno":56},{"type":"if","lineno":57}],"reason":"it is about the properties and values lists, then iterates through each pair to check if the value is None or an empty string, raising a ValueError if any such case is found.","reason_kor":"속성 목록과 값 목록을 결합하여 각 쌍을 순회하며 값이 None이거나 빈 문자열인 경우 ValueError를 발생시키는 검사를 수행합니다."},{"_key":"langchain_neo4j_vectorstores_neo4j_vector_py_create_new_index","_id":"nodes/langchain_neo4j_vectorstores_neo4j_vector_py_create_new_index","_rev":"_jzRpK76---","type":"function","name":"create_new_index","defined_in":"langchain_neo4j_vectorstores_neo4j_vector_py","lineno":435,"source":"def create_new_index(self) -> None:\n        \"\"\"\n        This method constructs a Cypher query and executes it\n        to create a new vector index in Neo4j.\n        \"\"\"\n        similarity_fn = DISTANCE_MAPPING[self._distance_strategy]\n        create_vector_index(\n            driver=self._driver,\n            name=self.index_name,\n            label=self.node_label,\n            embedding_property=self.embedding_node_property,\n            dimensions=self.embedding_dimension,\n            similarity_fn=similarity_fn,\n            fail_if_exists=False,\n            neo4j_database=self._database,\n        )","docstring":"This method constructs a Cypher query and executes it\nto create a new vector index in Neo4j.","args":[{"arg":"self","type":null}],"return_type":"None","control_flow":[],"reason":"it is about the construction of a Cypher query with the execution of a function to create a new vector index in Neo4j, using class attributes for configuration and a similarity function based on the specified distance strategy","reason_kor":"클래스 속성을 사용하여 Neo4j에서 새로운 벡터 인덱스를 생성하는 Cypher 쿼리 구성과 실행을 결합하며, 지정된 거리 전략에 기반한 유사성 함수 사용"},{"_key":"langchain_neo4j_vectorstores_neo4j_vector_py_create_new_keyword_index","_id":"nodes/langchain_neo4j_vectorstores_neo4j_vector_py_create_new_keyword_index","_rev":"_jzRpK8G---","type":"function","name":"create_new_keyword_index","defined_in":"langchain_neo4j_vectorstores_neo4j_vector_py","lineno":452,"source":"def create_new_keyword_index(self, text_node_properties: List[str] = []) -> None:\n        \"\"\"\n        This method constructs a Cypher query and executes it\n        to create a new full text index in Neo4j.\n        \"\"\"\n        if self.keyword_index_name:\n            create_fulltext_index(\n                driver=self._driver,\n                name=self.keyword_index_name,\n                label=self.node_label,\n                node_properties=text_node_properties or [self.text_node_property],\n                fail_if_exists=False,\n                neo4j_database=self._database,\n            )\n        else:\n            raise ValueError(\"keyword_index_name is not set.\")","docstring":"This method constructs a Cypher query and executes it\nto create a new full text index in Neo4j.","args":[{"arg":"self","type":null},{"arg":"text_node_properties","type":"List[str]"}],"return_type":"None","control_flow":[{"type":"if","lineno":457}],"reason":"it is about method definition, parameters, docstring, conditional logic, and function call to create a full-text index in Neo4j, raising an error if the index name is not set.","reason_kor":"인덱스 이름이 설정되지 않은 경우 오류를 발생시키며, Neo4j에서 전체 텍스트 인덱스를 생성하는 메서드 정의, 매개변수, docstring, 조건문, 함수 호출을 결합합니다."},{"_key":"langchain_neo4j_vectorstores_neo4j_vector_py_dict_to_yaml_str","_id":"nodes/langchain_neo4j_vectorstores_neo4j_vector_py_dict_to_yaml_str","_rev":"_jzRpK8S---","type":"function","name":"dict_to_yaml_str","defined_in":"langchain_neo4j_vectorstores_neo4j_vector_py","lineno":90,"source":"def dict_to_yaml_str(input_dict: Dict, indent: int = 0) -> str:\n    \"\"\"\n    Convert a dictionary to a YAML-like string without using external libraries.\n\n    Parameters:\n    - input_dict (dict): The dictionary to convert.\n    - indent (int): The current indentation level.\n\n    Returns:\n    - str: The YAML-like string representation of the input dictionary.\n    \"\"\"\n    yaml_str = \"\"\n    for key, value in input_dict.items():\n        padding = \"  \" * indent\n        if isinstance(value, dict):\n            yaml_str += f\"{padding}{key}:\\n{dict_to_yaml_str(value, indent + 1)}\"\n        elif isinstance(value, list):\n            yaml_str += f\"{padding}{key}:\\n\"\n            for item in value:\n                yaml_str += f\"{padding}- {item}\\n\"\n        else:\n            yaml_str += f\"{padding}{key}: {value}\\n\"\n    return yaml_str","docstring":"Convert a dictionary to a YAML-like string without using external libraries.\n\nParameters:\n- input_dict (dict): The dictionary to convert.\n- indent (int): The current indentation level.\n\nReturns:\n- str: The YAML-like string representation of the input dictionary.","args":[{"arg":"input_dict","type":"Dict"},{"arg":"indent","type":"int"}],"return_type":"str","control_flow":[{"type":"for","lineno":102},{"type":"if","lineno":104},{"type":"if","lineno":106},{"type":"for","lineno":108}],"reason":"it is about recursive processing of dictionaries and lists to produce a YAML-like string, handling nested structures with indentation and formatting keys and values appropriately.","reason_kor":"딕셔너리와 리스트를 재귀적으로 처리하여 YAML과 유사한 문자열을 생성하며, 중첩 구조에 대해 들여쓰기와 키-값 포맷팅을 적절히 처리합니다."},{"_key":"langchain_neo4j_vectorstores_neo4j_vector_py_embeddings","_id":"nodes/langchain_neo4j_vectorstores_neo4j_vector_py_embeddings","_rev":"_jzRpK8i---","type":"function","name":"embeddings","defined_in":"langchain_neo4j_vectorstores_neo4j_vector_py","lineno":470,"source":"def embeddings(self) -> Embeddings:\n        return self.embedding","docstring":null,"args":[{"arg":"self","type":null}],"return_type":"Embeddings","control_flow":[],"reason":"Property method to access the embedding interface used by the vector store.","reason_kor":"벡터 저장소에서 사용하는 임베딩 인터페이스에 접근하는 프로퍼티 메서드입니다."},{"_key":"langchain_neo4j_vectorstores_neo4j_vector_py_from_documents","_id":"nodes/langchain_neo4j_vectorstores_neo4j_vector_py_from_documents","_rev":"_jzRpK8u---","type":"function","name":"from_documents","defined_in":"langchain_neo4j_vectorstores_neo4j_vector_py","lineno":1106,"source":"def from_documents(\n        cls: Type[Neo4jVector],\n        documents: List[Document],\n        embedding: Embeddings,\n        distance_strategy: DistanceStrategy = DEFAULT_DISTANCE_STRATEGY,\n        ids: Optional[List[str]] = None,\n        **kwargs: Any,\n    ) -> Neo4jVector:\n        \"\"\"\n        Return Neo4jVector initialized from documents and embeddings.\n        Neo4j credentials are required in the form of `url`, `username`,\n        and `password` and optional `database` parameters.\n        \"\"\"\n\n        texts = [d.page_content for d in documents]\n        metadatas = [d.metadata for d in documents]\n\n        return cls.from_texts(\n            texts=texts,\n            embedding=embedding,\n            distance_strategy=distance_strategy,\n            metadatas=metadatas,\n            ids=ids,\n            **kwargs,\n        )","docstring":"Return Neo4jVector initialized from documents and embeddings.\nNeo4j credentials are required in the form of `url`, `username`,\nand `password` and optional `database` parameters.","args":[{"arg":"cls","type":"Type[Neo4jVector]"},{"arg":"documents","type":"List[Document]"},{"arg":"embedding","type":"Embeddings"},{"arg":"distance_strategy","type":"DistanceStrategy"},{"arg":"ids","type":"Optional[List[str]]"}],"return_type":"Neo4jVector","control_flow":[],"reason":"Class method to create a Neo4jVector instance from a list of Document objects by extracting text content and metadata and delegating to from_texts method.","reason_kor":"Document 리스트에서 텍스트와 메타데이터를 추출해 from_texts 메서드로 위임하여 Neo4jVector 인스턴스를 생성하는 클래스 메서드입니다."},{"_key":"langchain_neo4j_vectorstores_neo4j_vector_py_from_embeddings","_id":"nodes/langchain_neo4j_vectorstores_neo4j_vector_py_from_embeddings","_rev":"_jzRpK86---","type":"function","name":"from_embeddings","defined_in":"langchain_neo4j_vectorstores_neo4j_vector_py","lineno":896,"source":"def from_embeddings(\n        cls,\n        text_embeddings: List[Tuple[str, List[float]]],\n        embedding: Embeddings,\n        metadatas: Optional[List[dict]] = None,\n        distance_strategy: DistanceStrategy = DEFAULT_DISTANCE_STRATEGY,\n        ids: Optional[List[str]] = None,\n        pre_delete_collection: bool = False,\n        **kwargs: Any,\n    ) -> Neo4jVector:\n        \"\"\"Construct Neo4jVector wrapper from raw documents and pre-\n        generated embeddings.\n\n        Return Neo4jVector initialized from documents and embeddings.\n        Neo4j credentials are required in the form of `url`, `username`,\n        and `password` and optional `database` parameters.\n\n        Example:\n            .. code-block:: python\n\n                from langchain_neo4j import Neo4jVector\n                from langchain_openai import OpenAIEmbeddings\n\n                embeddings = OpenAIEmbeddings()\n                text_embeddings = embeddings.embed_documents(texts)\n                text_embedding_pairs = list(zip(texts, text_embeddings))\n                vectorstore = Neo4jVector.from_embeddings(\n                    text_embedding_pairs, embeddings)\n        \"\"\"\n        texts = [t[0] for t in text_embeddings]\n        embeddings = [t[1] for t in text_embeddings]\n\n        return cls.__from(\n            texts,\n            embeddings,\n            embedding,\n            metadatas=metadatas,\n            ids=ids,\n            distance_strategy=distance_strategy,\n            pre_delete_collection=pre_delete_collection,\n            **kwargs,\n        )","docstring":"Construct Neo4jVector wrapper from raw documents and pre-\ngenerated embeddings.\n\nReturn Neo4jVector initialized from documents and embeddings.\nNeo4j credentials are required in the form of `url`, `username`,\nand `password` and optional `database` parameters.\n\nExample:\n    .. code-block:: python\n\n        from langchain_neo4j import Neo4jVector\n        from langchain_openai import OpenAIEmbeddings\n\n        embeddings = OpenAIEmbeddings()\n        text_embeddings = embeddings.embed_documents(texts)\n        text_embedding_pairs = list(zip(texts, text_embeddings))\n        vectorstore = Neo4jVector.from_embeddings(\n            text_embedding_pairs, embeddings)","args":[{"arg":"cls","type":null},{"arg":"text_embeddings","type":"List[Tuple[str, List[float]]]"},{"arg":"embedding","type":"Embeddings"},{"arg":"metadatas","type":"Optional[List[dict]]"},{"arg":"distance_strategy","type":"DistanceStrategy"},{"arg":"ids","type":"Optional[List[str]]"},{"arg":"pre_delete_collection","type":"bool"}],"return_type":"Neo4jVector","control_flow":[],"reason":"Class method to create a Neo4jVector instance from pre-generated text embeddings and optional metadata, handling vector index initialization and optionally clearing previous data.","reason_kor":"사전 생성된 텍스트 임베딩과 선택적 메타데이터로부터 Neo4jVector 인스턴스를 생성하고, 벡터 인덱스 초기화 및 이전 데이터 삭제 옵션을 처리하는 클래스 메서드입니다."},{"_key":"langchain_neo4j_vectorstores_neo4j_vector_py_from_existing_graph","_id":"nodes/langchain_neo4j_vectorstores_neo4j_vector_py_from_existing_graph","_rev":"_jzRpK9G---","type":"function","name":"from_existing_graph","defined_in":"langchain_neo4j_vectorstores_neo4j_vector_py","lineno":1133,"source":"def from_existing_graph(\n        cls: Type[Neo4jVector],\n        embedding: Embeddings,\n        node_label: str,\n        embedding_node_property: str,\n        text_node_properties: List[str],\n        *,\n        keyword_index_name: Optional[str] = \"keyword\",\n        index_name: str = \"vector\",\n        search_type: SearchType = DEFAULT_SEARCH_TYPE,\n        retrieval_query: str = \"\",\n        **kwargs: Any,\n    ) -> Neo4jVector:\n        \"\"\"\n        Initialize and return a Neo4jVector instance from an existing graph.\n\n        This method initializes a Neo4jVector instance using the provided\n        parameters and the existing graph. It validates the existence of\n        the indices and creates new ones if they don't exist.\n\n        Returns:\n        Neo4jVector: An instance of Neo4jVector initialized with the provided parameters\n                    and existing graph.\n\n        Example:\n        >>> neo4j_vector = Neo4jVector.from_existing_graph(\n        ...     embedding=my_embedding,\n        ...     node_label=\"Document\",\n        ...     embedding_node_property=\"embedding\",\n        ...     text_node_properties=[\"title\", \"content\"]\n        ... )\n\n        Note:\n        Neo4j credentials are required in the form of `url`, `username`, and `password`,\n        and optional `database` parameters passed as additional keyword arguments.\n        \"\"\"\n        # Validate the list is not empty\n        if not text_node_properties:\n            raise ValueError(\n                \"Parameter `text_node_properties` must not be an empty list\"\n            )\n        # Prefer retrieval query from params, otherwise construct it\n        if not retrieval_query:\n            retrieval_query = (\n                f\"RETURN reduce(str='', k IN {text_node_properties} |\"\n                \" str + '\\\\n' + k + ': ' + coalesce(node[k], '')) AS text, \"\n                \"node {.*, `\"\n                + embedding_node_property\n                + \"`: Null, id: Null, \"\n                + \", \".join([f\"`{prop}`: Null\" for prop in text_node_properties])\n                + \"} AS metadata, score\"\n            )\n        store = cls(\n            embedding=embedding,\n            index_name=index_name,\n            keyword_index_name=keyword_index_name,\n            search_type=search_type,\n            retrieval_query=retrieval_query,\n            node_label=node_label,\n            embedding_node_property=embedding_node_property,\n            **kwargs,\n        )\n\n        # Check if the vector index already exists\n        existing_index_info = store.retrieve_existing_index()\n        if existing_index_info:\n            embedding_dimension, index_type = existing_index_info\n        else:\n            embedding_dimension = None\n            index_type = None\n\n        # Raise error if relationship index type\n        if index_type == \"RELATIONSHIP\":\n            raise ValueError(\n                \"`from_existing_graph` method does not support \"\n                \" existing relationship vector index. \"\n                \"Please use `from_existing_relationship_index` method\"\n            )\n\n        # If the vector index doesn't exist yet\n        if not index_type:\n            store.create_new_index()\n        # If the index already exists, check if embedding dimensions match\n        elif (\n            embedding_dimension and not store.embedding_dimension == embedding_dimension\n        ):\n            raise ValueError(\n                f\"Index with name {store.index_name} already exists. \"\n                \"The provided embedding function and vector index \"\n                \"dimensions do not match.\\n\"\n                f\"Embedding function dimension: {store.embedding_dimension}\\n\"\n                f\"Vector index dimension: {embedding_dimension}\"\n            )\n        # FTS index for Hybrid search\n        if search_type == SearchType.HYBRID:\n            fts_node_label = store.retrieve_existing_fts_index(text_node_properties)\n            # If the FTS index doesn't exist yet\n            if not fts_node_label:\n                store.create_new_keyword_index(text_node_properties)\n            else:  # Validate that FTS and Vector index use the same information\n                if not fts_node_label == store.node_label:\n                    raise ValueError(\n                        \"Vector and keyword index don't index the same node label\"\n                    )\n\n        # Populate embeddings\n        while True:\n            fetch_query = (\n                f\"MATCH (n:`{node_label}`) \"\n                f\"WHERE n.{embedding_node_property} IS null \"\n                \"AND any(k in $props WHERE n[k] IS NOT null) \"\n                f\"RETURN elementId(n) AS id, reduce(str='',\"\n                \"k IN $props | str + '\\\\n' + k + ':' + coalesce(n[k], '')) AS text \"\n                \"LIMIT 1000\"\n            )\n            data = store.query(fetch_query, params={\"props\": text_node_properties})\n            if not data:\n                break\n            text_embeddings = embedding.embed_documents([el[\"text\"] for el in data])\n\n            params = {\n                \"data\": [\n                    {\"id\": el[\"id\"], \"embedding\": embedding}\n                    for el, embedding in zip(data, text_embeddings)\n                ]\n            }\n\n            store.query(\n                \"UNWIND $data AS row \"\n                f\"MATCH (n:`{node_label}`) \"\n                \"WHERE elementId(n) = row.id \"\n                f\"CALL db.create.setNodeVectorProperty(n, \"\n                f\"'{embedding_node_property}', row.embedding) \"\n                \"RETURN count(*)\",\n                params=params,\n            )\n            # If embedding calculation should be stopped\n            if len(data) < 1000:\n                break\n        return store","docstring":"Initialize and return a Neo4jVector instance from an existing graph.\n\nThis method initializes a Neo4jVector instance using the provided\nparameters and the existing graph. It validates the existence of\nthe indices and creates new ones if they don't exist.\n\nReturns:\nNeo4jVector: An instance of Neo4jVector initialized with the provided parameters\n            and existing graph.\n\nExample:\n>>> neo4j_vector = Neo4jVector.from_existing_graph(\n...     embedding=my_embedding,\n...     node_label=\"Document\",\n...     embedding_node_property=\"embedding\",\n...     text_node_properties=[\"title\", \"content\"]\n... )\n\nNote:\nNeo4j credentials are required in the form of `url`, `username`, and `password`,\nand optional `database` parameters passed as additional keyword arguments.","args":[{"arg":"cls","type":"Type[Neo4jVector]"},{"arg":"embedding","type":"Embeddings"},{"arg":"node_label","type":"str"},{"arg":"embedding_node_property","type":"str"},{"arg":"text_node_properties","type":"List[str]"}],"return_type":"Neo4jVector","control_flow":[{"type":"if","lineno":1170},{"type":"if","lineno":1175},{"type":"if","lineno":1198},{"type":"if","lineno":1205},{"type":"if","lineno":1213},{"type":"if","lineno":1216},{"type":"if","lineno":1227},{"type":"if","lineno":1230},{"type":"if","lineno":1233},{"type":"while","lineno":1239},{"type":"if","lineno":1249},{"type":"if","lineno":1270}],"reason":"it is about parameter validation, index existence checks, index creation, consistency validation, and embedding population processes into a single method that initializes a Neo4jVector instance from an existing graph, ensuring proper setup and data consistency.","reason_kor":"기존 그래프에서 Neo4jVector 인스턴스를 초기화하기 위해 매개변수 검증, 인덱스 존재 여부 확인, 인덱스 생성, 일관성 검증, 임베딩 채우기 과정을 단일 메서드에 통합합니다."},{"_key":"langchain_neo4j_vectorstores_neo4j_vector_py_from_existing_index","_id":"nodes/langchain_neo4j_vectorstores_neo4j_vector_py_from_existing_index","_rev":"_jzRpK9S---","type":"function","name":"from_existing_index","defined_in":"langchain_neo4j_vectorstores_neo4j_vector_py","lineno":940,"source":"def from_existing_index(\n        cls: Type[Neo4jVector],\n        embedding: Embeddings,\n        index_name: str,\n        search_type: SearchType = DEFAULT_SEARCH_TYPE,\n        keyword_index_name: Optional[str] = None,\n        embedding_dimension: Optional[int] = None,\n        **kwargs: Any,\n    ) -> Neo4jVector:\n        \"\"\"\n        Get instance of an existing Neo4j vector index. This method will\n        return the instance of the store without inserting any new\n        embeddings.\n        Neo4j credentials are required in the form of `url`, `username`,\n        and `password` and optional `database` parameters along with\n        the `index_name` definition.\n        \"\"\"\n\n        if search_type == SearchType.HYBRID and not keyword_index_name:\n            raise ValueError(\n                \"keyword_index name has to be specified \"\n                \"when using hybrid search option\"\n            )\n\n        store = cls(\n            embedding=embedding,\n            index_name=index_name,\n            keyword_index_name=keyword_index_name,\n            search_type=search_type,\n            embedding_dimension=embedding_dimension,\n            **kwargs,\n        )\n\n        # Check if the vector index already exists\n        existing_index_info = store.retrieve_existing_index()\n        if existing_index_info:\n            embedding_dimension_from_existing, index_type = existing_index_info\n        else:\n            embedding_dimension_from_existing = None\n            index_type = None\n\n        if embedding_dimension:\n            if embedding_dimension_from_existing != embedding_dimension:\n                raise ValueError(\n                    \"The provided embedding function and vector index \"\n                    \"dimensions do not match.\\n\"\n                    f\"Embedding function dimension: {embedding_dimension}\\n\"\n                    f\"Vector index dimension: {embedding_dimension_from_existing}\"\n                )\n        else:\n            embedding_dimension = embedding_dimension_from_existing\n\n        # Raise error if relationship index type\n        if index_type == \"RELATIONSHIP\":\n            raise ValueError(\n                \"Relationship vector index is not supported with \"\n                \"`from_existing_index` method. Please use the \"\n                \"`from_existing_relationship_index` method.\"\n            )\n\n        if not index_type:\n            raise ValueError(\n                \"The specified vector index name does not exist. \"\n                \"Make sure to check if you spelled it correctly\"\n            )\n\n        # Check if embedding function and vector index dimensions match\n        if embedding_dimension and not store.embedding_dimension == embedding_dimension:\n            raise ValueError(\n                \"The provided embedding function and vector index \"\n                \"dimensions do not match.\\n\"\n                f\"Embedding function dimension: {store.embedding_dimension}\\n\"\n                f\"Vector index dimension: {embedding_dimension}\"\n            )\n\n        if search_type == SearchType.HYBRID:\n            fts_node_label = store.retrieve_existing_fts_index()\n            # If the FTS index doesn't exist yet\n            if not fts_node_label:\n                raise ValueError(\n                    \"The specified keyword index name does not exist. \"\n                    \"Make sure to check if you spelled it correctly\"\n                )\n            else:  # Validate that FTS and Vector index use the same information\n                if not fts_node_label == store.node_label:\n                    raise ValueError(\n                        \"Vector and keyword index don't index the same node label\"\n                    )\n\n        return store","docstring":"Get instance of an existing Neo4j vector index. This method will\nreturn the instance of the store without inserting any new\nembeddings.\nNeo4j credentials are required in the form of `url`, `username`,\nand `password` and optional `database` parameters along with\nthe `index_name` definition.","args":[{"arg":"cls","type":"Type[Neo4jVector]"},{"arg":"embedding","type":"Embeddings"},{"arg":"index_name","type":"str"},{"arg":"search_type","type":"SearchType"},{"arg":"keyword_index_name","type":"Optional[str]"},{"arg":"embedding_dimension","type":"Optional[int]"}],"return_type":"Neo4jVector","control_flow":[{"type":"if","lineno":958},{"type":"if","lineno":975},{"type":"if","lineno":981},{"type":"if","lineno":982},{"type":"if","lineno":993},{"type":"if","lineno":1000},{"type":"if","lineno":1007},{"type":"if","lineno":1015},{"type":"if","lineno":1018},{"type":"if","lineno":1024}],"reason":"it is about the validation of existing index information, index type, embedding dimensions, and compatibility with search type to ensure proper retrieval and usage of an existing Neo4j vector index without inserting new embeddings","reason_kor":"기존 Neo4j 벡터 인덱스의 정보, 인덱스 유형, 임베딩 차원 및 검색 유형 호환성을 검증하여 새로운 임베딩 삽입 없이 기존 인덱스를 올바르게 조회 및 사용하도록 보장합니다."},{"_key":"langchain_neo4j_vectorstores_neo4j_vector_py_from_existing_relationship_index","_id":"nodes/langchain_neo4j_vectorstores_neo4j_vector_py_from_existing_relationship_index","_rev":"_jzRpK9a---","type":"function","name":"from_existing_relationship_index","defined_in":"langchain_neo4j_vectorstores_neo4j_vector_py","lineno":1032,"source":"def from_existing_relationship_index(\n        cls: Type[Neo4jVector],\n        embedding: Embeddings,\n        index_name: str,\n        search_type: SearchType = DEFAULT_SEARCH_TYPE,\n        embedding_dimension: Optional[int] = None,\n        **kwargs: Any,\n    ) -> Neo4jVector:\n        \"\"\"\n        Get instance of an existing Neo4j relationship vector index.\n        This method will return the instance of the store without\n        inserting any new embeddings.\n        Neo4j credentials are required in the form of `url`, `username`,\n        and `password` and optional `database` parameters along with\n        the `index_name` definition.\n        \"\"\"\n\n        if search_type == SearchType.HYBRID:\n            raise ValueError(\n                \"Hybrid search is not supported in combination \"\n                \"with relationship vector index\"\n            )\n\n        store = cls(\n            embedding=embedding,\n            index_name=index_name,\n            embedding_dimension=embedding_dimension,\n            **kwargs,\n        )\n\n        # Check if the vector index already exists\n        existing_index_info = store.retrieve_existing_index()\n        if existing_index_info:\n            embedding_dimension_from_existing, index_type = existing_index_info\n        else:\n            embedding_dimension_from_existing = None\n            index_type = None\n\n        if embedding_dimension:\n            if embedding_dimension_from_existing != embedding_dimension:\n                raise ValueError(\n                    \"The provided embedding function and vector index \"\n                    \"dimensions do not match.\\n\"\n                    f\"Embedding function dimension: {embedding_dimension}\\n\"\n                    f\"Vector index dimension: {embedding_dimension_from_existing}\"\n                )\n        else:\n            embedding_dimension = embedding_dimension_from_existing\n\n        if not index_type:\n            raise ValueError(\n                \"The specified vector index name does not exist. \"\n                \"Make sure to check if you spelled it correctly\"\n            )\n        # Raise error if relationship index type\n        if index_type == \"NODE\":\n            raise ValueError(\n                \"Node vector index is not supported with \"\n                \"`from_existing_relationship_index` method. Please use the \"\n                \"`from_existing_index` method.\"\n            )\n\n        # Check if embedding function and vector index dimensions match\n        if embedding_dimension and not store.embedding_dimension == embedding_dimension:\n            raise ValueError(\n                \"The provided embedding function and vector index \"\n                \"dimensions do not match.\\n\"\n                f\"Embedding function dimension: {store.embedding_dimension}\\n\"\n                f\"Vector index dimension: {embedding_dimension}\"\n            )\n\n        return store","docstring":"Get instance of an existing Neo4j relationship vector index.\nThis method will return the instance of the store without\ninserting any new embeddings.\nNeo4j credentials are required in the form of `url`, `username`,\nand `password` and optional `database` parameters along with\nthe `index_name` definition.","args":[{"arg":"cls","type":"Type[Neo4jVector]"},{"arg":"embedding","type":"Embeddings"},{"arg":"index_name","type":"str"},{"arg":"search_type","type":"SearchType"},{"arg":"embedding_dimension","type":"Optional[int]"}],"return_type":"Neo4jVector","control_flow":[{"type":"if","lineno":1049},{"type":"if","lineno":1064},{"type":"if","lineno":1070},{"type":"if","lineno":1071},{"type":"if","lineno":1081},{"type":"if","lineno":1087},{"type":"if","lineno":1095}],"reason":"it is about detailed validation and retrieval logic for existing Neo4j relationship vector indexes, including checks for index existence, dimension matching, and index type validation, ensuring proper instantiation of the store object without creating new entries.","reason_kor":"기존 Neo4j 관계 벡터 인덱스에 대한 상세 검증 및 검색 로직을 포함하며, 인덱스 존재 여부, 차원 일치, 인덱스 유형 검사를 수행하여 새 엔트리를 생성하지 않고 스토어 객체를 올바르게 인스턴스화합니다."},{"_key":"langchain_neo4j_vectorstores_neo4j_vector_py_from_texts","_id":"nodes/langchain_neo4j_vectorstores_neo4j_vector_py_from_texts","_rev":"_jzRpK9m---","type":"function","name":"from_texts","defined_in":"langchain_neo4j_vectorstores_neo4j_vector_py","lineno":869,"source":"def from_texts(\n        cls: Type[Neo4jVector],\n        texts: List[str],\n        embedding: Embeddings,\n        metadatas: Optional[List[dict]] = None,\n        distance_strategy: DistanceStrategy = DEFAULT_DISTANCE_STRATEGY,\n        ids: Optional[List[str]] = None,\n        **kwargs: Any,\n    ) -> Neo4jVector:\n        \"\"\"\n        Return Neo4jVector initialized from texts and embeddings.\n        Neo4j credentials are required in the form of `url`, `username`,\n        and `password` and optional `database` parameters.\n        \"\"\"\n        embeddings = embedding.embed_documents(list(texts))\n\n        return cls.__from(\n            texts,\n            embeddings,\n            embedding,\n            metadatas=metadatas,\n            ids=ids,\n            distance_strategy=distance_strategy,\n            **kwargs,\n        )","docstring":"Return Neo4jVector initialized from texts and embeddings.\nNeo4j credentials are required in the form of `url`, `username`,\nand `password` and optional `database` parameters.","args":[{"arg":"cls","type":"Type[Neo4jVector]"},{"arg":"texts","type":"List[str]"},{"arg":"embedding","type":"Embeddings"},{"arg":"metadatas","type":"Optional[List[dict]]"},{"arg":"distance_strategy","type":"DistanceStrategy"},{"arg":"ids","type":"Optional[List[str]]"}],"return_type":"Neo4jVector","control_flow":[],"reason":"it is about parameters such as texts, embedding models, metadata, IDs, and distance strategy, to generate a Neo4jVector instance by embedding the texts and then initializing the object with these embeddings and associated data.","reason_kor":"텍스트, 임베딩 모델, 메타데이터, ID, 거리 전략 등 매개변수를 결합하여 텍스트를 임베딩하고, 해당 임베딩 및 관련 데이터로 Neo4jVector 인스턴스를 생성합니다."},{"_key":"langchain_neo4j_vectorstores_neo4j_vector_py_max_marginal_relevance_search","_id":"nodes/langchain_neo4j_vectorstores_neo4j_vector_py_max_marginal_relevance_search","_rev":"_jzRpK9y---","type":"function","name":"max_marginal_relevance_search","defined_in":"langchain_neo4j_vectorstores_neo4j_vector_py","lineno":1274,"source":"def max_marginal_relevance_search(\n        self,\n        query: str,\n        k: int = 4,\n        fetch_k: int = 20,\n        lambda_mult: float = 0.5,\n        filter: Optional[dict] = None,\n        **kwargs: Any,\n    ) -> List[Document]:\n        \"\"\"Return docs selected using the maximal marginal relevance.\n\n        Maximal marginal relevance optimizes for similarity to query AND diversity\n        among selected documents.\n\n        Args:\n            query: search query text.\n            k: Number of Documents to return. Defaults to 4.\n            fetch_k: Number of Documents to fetch to pass to MMR algorithm.\n            lambda_mult: Number between 0 and 1 that determines the degree\n                        of diversity among the results with 0 corresponding\n                        to maximum diversity and 1 to minimum diversity.\n                        Defaults to 0.5.\n            filter: Filter on metadata properties, e.g.\n                            {\n                                \"str_property\": \"foo\",\n                                \"int_property\": 123\n                            }\n        Returns:\n            List of Documents selected by maximal marginal relevance.\n        \"\"\"\n        # Embed the query\n        query_embedding = self.embedding.embed_query(query)\n\n        # Fetch the initial documents\n        got_docs = self.similarity_search_with_score_by_vector(\n            embedding=query_embedding,\n            query=query,\n            k=fetch_k,\n            return_embeddings=True,\n            filter=filter,\n            **kwargs,\n        )\n\n        # Get the embeddings for the fetched documents\n        got_embeddings = [doc.metadata[\"_embedding_\"] for doc, _ in got_docs]\n\n        # Select documents using maximal marginal relevance\n        selected_indices = maximal_marginal_relevance(\n            np.array(query_embedding), got_embeddings, lambda_mult=lambda_mult, k=k\n        )\n        selected_docs = [got_docs[i][0] for i in selected_indices]\n\n        # Remove embedding values from metadata\n        for doc in selected_docs:\n            del doc.metadata[\"_embedding_\"]\n\n        return selected_docs","docstring":"Return docs selected using the maximal marginal relevance.\n\nMaximal marginal relevance optimizes for similarity to query AND diversity\namong selected documents.\n\nArgs:\n    query: search query text.\n    k: Number of Documents to return. Defaults to 4.\n    fetch_k: Number of Documents to fetch to pass to MMR algorithm.\n    lambda_mult: Number between 0 and 1 that determines the degree\n                of diversity among the results with 0 corresponding\n                to maximum diversity and 1 to minimum diversity.\n                Defaults to 0.5.\n    filter: Filter on metadata properties, e.g.\n                    {\n                        \"str_property\": \"foo\",\n                        \"int_property\": 123\n                    }\nReturns:\n    List of Documents selected by maximal marginal relevance.","args":[{"arg":"self","type":null},{"arg":"query","type":"str"},{"arg":"k","type":"int"},{"arg":"fetch_k","type":"int"},{"arg":"lambda_mult","type":"float"},{"arg":"filter","type":"Optional[dict]"}],"return_type":"List[Document]","control_flow":[{"type":"for","lineno":1327}],"reason":"it is about embedding-based retrieval with maximal marginal relevance for selecting diverse and relevant documents based on a query, optimizing both similarity and diversity among the results.","reason_kor":"최대 주변 관련성(Maximal Marginal Relevance)을 활용해 쿼리에 기반한 다양하고 관련성 높은 문서 선택을 수행하며, 결과 간 유사성과 다양성을 최적화합니다."},{"_key":"langchain_neo4j_vectorstores_neo4j_vector_py_query","_id":"nodes/langchain_neo4j_vectorstores_neo4j_vector_py_query","_rev":"_jzRpL-----","type":"function","name":"query","defined_in":"langchain_neo4j_vectorstores_neo4j_vector_py","lineno":296,"source":"def query(\n        self,\n        query: str,\n        *,\n        params: Optional[dict] = None,\n    ) -> List[Dict[str, Any]]:\n        \"\"\"Query Neo4j database with retries and exponential backoff.\n\n        Args:\n            query (str): The Cypher query to execute.\n            params (dict, optional): Dictionary of query parameters. Defaults to {}.\n\n        Returns:\n            List[Dict[str, Any]]: List of dictionaries containing the query results.\n        \"\"\"\n        from neo4j import Query\n        from neo4j.exceptions import Neo4jError\n\n        params = params or {}\n        try:\n            data, _, _ = self._driver.execute_query(\n                query, database_=self._database, parameters_=params\n            )\n            return [r.data() for r in data]\n        except Neo4jError as e:\n            if not (\n                (\n                    (  # isCallInTransactionError\n                        e.code == \"Neo.DatabaseError.Statement.ExecutionFailed\"\n                        or e.code\n                        == \"Neo.DatabaseError.Transaction.TransactionStartFailed\"\n                    )\n                    and e.message is not None\n                    and \"in an implicit transaction\" in e.message\n                )\n                or (  # isPeriodicCommitError\n                    e.code == \"Neo.ClientError.Statement.SemanticError\"\n                    and e.message is not None\n                    and (\n                        \"in an open transaction is not possible\" in e.message\n                        or \"tried to execute in an explicit transaction\" in e.message\n                    )\n                )\n            ):\n                raise\n        # Fallback to allow implicit transactions\n        with self._driver.session(database=self._database) as session:\n            result = session.run(Query(text=query), params)\n            return [r.data() for r in result]","docstring":"Query Neo4j database with retries and exponential backoff.\n\nArgs:\n    query (str): The Cypher query to execute.\n    params (dict, optional): Dictionary of query parameters. Defaults to {}.\n\nReturns:\n    List[Dict[str, Any]]: List of dictionaries containing the query results.","args":[{"arg":"self","type":null},{"arg":"query","type":"str"}],"return_type":"List[Dict[str, Any]]","control_flow":[{"type":"try","lineno":315},{"type":"if","lineno":321}],"reason":"it is about the execution of a Neo4j query with error handling and retries by first attempting to execute a query using a driver method that supports retries, then catching specific Neo4j errors related to transactions, and if those errors occur, it falls back to executing the query within a session as an implicit transaction, returning the query results as a list of dictionaries.","reason_kor":"드라이버를 사용해 Neo4j 쿼리를 실행하며 오류 처리와 재시도를 결합함; 트랜잭션 관련 특정 Neo4j 오류가 발생하면 암묵적 트랜잭션으로 세션 내에서 쿼리를 실행하여 딕셔너리 리스트 형태로 결과를 반환합니다."},{"_key":"langchain_neo4j_vectorstores_neo4j_vector_py_remove_lucene_chars","_id":"nodes/langchain_neo4j_vectorstores_neo4j_vector_py_remove_lucene_chars","_rev":"_jzRpL-K---","type":"function","name":"remove_lucene_chars","defined_in":"langchain_neo4j_vectorstores_neo4j_vector_py","lineno":61,"source":"def remove_lucene_chars(text: str) -> str:\n    \"\"\"Remove Lucene special characters\"\"\"\n    special_chars = [\n        \"+\",\n        \"-\",\n        \"&\",\n        \"|\",\n        \"!\",\n        \"(\",\n        \")\",\n        \"{\",\n        \"}\",\n        \"[\",\n        \"]\",\n        \"^\",\n        '\"',\n        \"~\",\n        \"*\",\n        \"?\",\n        \":\",\n        \"\\\\\",\n        \"/\",\n    ]\n    for char in special_chars:\n        if char in text:\n            text = text.replace(char, \" \")\n    return text.strip()","docstring":"Remove Lucene special characters","args":[{"arg":"text","type":"str"}],"return_type":"str","control_flow":[{"type":"for","lineno":84},{"type":"if","lineno":85}],"reason":"Utility function that cleans a given string by removing special Lucene query characters to prevent query syntax errors.","reason_kor":"Lucene 쿼리에서 특수 문자를 제거하여 쿼리 구문 오류를 방지하기 위한 문자열 정리 유틸 함수입니다."},{"_key":"langchain_neo4j_vectorstores_neo4j_vector_py_retrieve_existing_fts_index","_id":"nodes/langchain_neo4j_vectorstores_neo4j_vector_py_retrieve_existing_fts_index","_rev":"_jzRpL-W---","type":"function","name":"retrieve_existing_fts_index","defined_in":"langchain_neo4j_vectorstores_neo4j_vector_py","lineno":403,"source":"def retrieve_existing_fts_index(\n        self, text_node_properties: List[str] = []\n    ) -> Optional[str]:\n        \"\"\"\n        Check if the fulltext index exists in the Neo4j database\n\n        This method queries the Neo4j database for existing fts indexes\n        with the specified name.\n\n        Returns:\n            (Tuple): keyword index information\n        \"\"\"\n        if self.keyword_index_name:\n            index_information = retrieve_fulltext_index_info(\n                driver=self._driver,\n                index_name=self.keyword_index_name,\n                label_or_type=self.node_label,\n                text_properties=text_node_properties or [self.text_node_property],\n            )\n        else:\n            raise ValueError(\"keyword_index_name is not set.\")\n        if index_information:\n            try:\n                self.keyword_index_name = index_information[\"name\"]\n                self.text_node_property = index_information[\"properties\"][0]\n                node_label = index_information[\"labelsOrTypes\"][0]\n                return node_label\n            except IndexError:\n                return None\n        else:\n            return None","docstring":"Check if the fulltext index exists in the Neo4j database\n\nThis method queries the Neo4j database for existing fts indexes\nwith the specified name.\n\nReturns:\n    (Tuple): keyword index information","args":[{"arg":"self","type":null},{"arg":"text_node_properties","type":"List[str]"}],"return_type":"Optional[str]","control_flow":[{"type":"if","lineno":415},{"type":"if","lineno":424},{"type":"try","lineno":425}],"reason":"it is about a method that checks the existence of a fulltext index in a Neo4j database by querying index info using a driver, handling potential missing index data, and returning the associated node label if found, or None otherwise.","reason_kor":"Neo4j 데이터베이스에서 전체 텍스트 인덱스 존재 여부를 드라이버를 사용해 확인하며, 인덱스 정보가 없거나 누락될 수 있는 상황을 처리하고, 발견 시 관련 노드 라벨을 반환하거나 없으면 None을 반환합니다."},{"_key":"langchain_neo4j_vectorstores_neo4j_vector_py_retrieve_existing_index","_id":"nodes/langchain_neo4j_vectorstores_neo4j_vector_py_retrieve_existing_index","_rev":"_jzRpL-i---","type":"function","name":"retrieve_existing_index","defined_in":"langchain_neo4j_vectorstores_neo4j_vector_py","lineno":368,"source":"def retrieve_existing_index(self) -> Optional[Tuple[Optional[int], str]]:\n        \"\"\"\n        Check if the vector index exists in the Neo4j database\n        and returns its embedding dimension.\n\n        This method queries the Neo4j database for existing indexes\n        and attempts to retrieve the dimension of the vector index\n        with the specified name. If the index exists, its dimension is returned.\n        If the index doesn't exist, `None` is returned.\n\n        Returns:\n            int or None: The embedding dimension of the existing index if found.\n        \"\"\"\n        index_information = retrieve_vector_index_info(\n            driver=self._driver,\n            index_name=self.index_name,\n            label_or_type=self.node_label,\n            embedding_property=self.embedding_node_property,\n        )\n        if index_information:\n            try:\n                self.index_name = index_information[\"name\"]\n                self.node_label = index_information[\"labelsOrTypes\"][0]\n                self.embedding_node_property = index_information[\"properties\"][0]\n                self._index_type = index_information[\"entityType\"]\n                embedding_dimension = None\n                index_config = index_information[\"options\"][\"indexConfig\"]\n                if \"vector.dimensions\" in index_config:\n                    embedding_dimension = index_config[\"vector.dimensions\"]\n                return embedding_dimension, index_information[\"entityType\"]\n            except IndexError:\n                return None\n        else:\n            return None","docstring":"Check if the vector index exists in the Neo4j database\nand returns its embedding dimension.\n\nThis method queries the Neo4j database for existing indexes\nand attempts to retrieve the dimension of the vector index\nwith the specified name. If the index exists, its dimension is returned.\nIf the index doesn't exist, `None` is returned.\n\nReturns:\n    int or None: The embedding dimension of the existing index if found.","args":[{"arg":"self","type":null}],"return_type":"Optional[Tuple[Optional[int], str]]","control_flow":[{"type":"if","lineno":387},{"type":"try","lineno":388},{"type":"if","lineno":395}],"reason":"it is about querying Neo4j for index information, updating internal attributes if found, and extracting the vector dimension from the index configuration, returning the dimension and entity type if available, otherwise None.","reason_kor":"Neo4j에서 인덱스 정보를 조회하고 내부 속성을 갱신하며, 인덱스 설정에서 벡터 차원을 추출하여 차원 및 엔티티 타입을 반환하거나 없으면 None 반환합니다."},{"_key":"langchain_neo4j_vectorstores_neo4j_vector_py_similarity_search","_id":"nodes/langchain_neo4j_vectorstores_neo4j_vector_py_similarity_search","_rev":"_jzRpL-q---","type":"function","name":"similarity_search","defined_in":"langchain_neo4j_vectorstores_neo4j_vector_py","lineno":635,"source":"def similarity_search(\n        self,\n        query: str,\n        k: int = 4,\n        params: Dict[str, Any] = {},\n        filter: Optional[Dict[str, Any]] = None,\n        effective_search_ratio: int = 1,\n        **kwargs: Any,\n    ) -> List[Document]:\n        \"\"\"Run similarity search with Neo4jVector.\n\n        Args:\n            query (str): Query text to search for.\n            k (int): Number of results to return. Defaults to 4.\n            params (Dict[str, Any]): The search params for the index type.\n                Defaults to empty dict.\n            filter (Optional[Dict[str, Any]]): Dictionary of argument(s) to\n                    filter on metadata.\n                Defaults to None.\n            effective_search_ratio (int): Controls the candidate pool size\n               by multiplying $k to balance query accuracy and performance.\n               Defaults to 1.\n        Returns:\n            List of Documents most similar to the query.\n        \"\"\"\n        embedding = self.embedding.embed_query(text=query)\n        return self.similarity_search_by_vector(\n            embedding=embedding,\n            k=k,\n            query=query,\n            params=params,\n            filter=filter,\n            effective_search_ratio=effective_search_ratio,\n            **kwargs,\n        )","docstring":"Run similarity search with Neo4jVector.\n\nArgs:\n    query (str): Query text to search for.\n    k (int): Number of results to return. Defaults to 4.\n    params (Dict[str, Any]): The search params for the index type.\n        Defaults to empty dict.\n    filter (Optional[Dict[str, Any]]): Dictionary of argument(s) to\n            filter on metadata.\n        Defaults to None.\n    effective_search_ratio (int): Controls the candidate pool size\n       by multiplying $k to balance query accuracy and performance.\n       Defaults to 1.\nReturns:\n    List of Documents most similar to the query.","args":[{"arg":"self","type":null},{"arg":"query","type":"str"},{"arg":"k","type":"int"},{"arg":"params","type":"Dict[str, Any]"},{"arg":"filter","type":"Optional[Dict[str, Any]]"},{"arg":"effective_search_ratio","type":"int"}],"return_type":"List[Document]","control_flow":[],"reason":"Method to perform a semantic similarity search in Neo4j using a natural language query, embedding the query text and delegating to vector similarity search.","reason_kor":"자연어 쿼리를 임베딩하여 Neo4j에서 의미 기반 유사도 검색을 수행하고, 벡터 유사도 검색에 위임하는 메서드입니다."},{"_key":"langchain_neo4j_vectorstores_neo4j_vector_py_similarity_search_by_vector","_id":"nodes/langchain_neo4j_vectorstores_neo4j_vector_py_similarity_search_by_vector","_rev":"_jzRpL-2---","type":"function","name":"similarity_search_by_vector","defined_in":"langchain_neo4j_vectorstores_neo4j_vector_py","lineno":835,"source":"def similarity_search_by_vector(\n        self,\n        embedding: List[float],\n        k: int = 4,\n        filter: Optional[Dict[str, Any]] = None,\n        params: Dict[str, Any] = {},\n        effective_search_ratio: int = 1,\n        **kwargs: Any,\n    ) -> List[Document]:\n        \"\"\"Return docs most similar to embedding vector.\n\n        Args:\n            embedding: Embedding to look up documents similar to.\n            k: Number of Documents to return. Defaults to 4.\n            filter (Optional[Dict[str, Any]]): Dictionary of argument(s) to\n                    filter on metadata.\n                Defaults to None.\n            params (Dict[str, Any]): The search params for the index type.\n                Defaults to empty dict.\n\n        Returns:\n            List of Documents most similar to the query vector.\n        \"\"\"\n        docs_and_scores = self.similarity_search_with_score_by_vector(\n            embedding=embedding,\n            k=k,\n            filter=filter,\n            params=params,\n            effective_search_ratio=effective_search_ratio,\n            **kwargs,\n        )\n        return [doc for doc, _ in docs_and_scores]","docstring":"Return docs most similar to embedding vector.\n\nArgs:\n    embedding: Embedding to look up documents similar to.\n    k: Number of Documents to return. Defaults to 4.\n    filter (Optional[Dict[str, Any]]): Dictionary of argument(s) to\n            filter on metadata.\n        Defaults to None.\n    params (Dict[str, Any]): The search params for the index type.\n        Defaults to empty dict.\n\nReturns:\n    List of Documents most similar to the query vector.","args":[{"arg":"self","type":null},{"arg":"embedding","type":"List[float]"},{"arg":"k","type":"int"},{"arg":"filter","type":"Optional[Dict[str, Any]]"},{"arg":"params","type":"Dict[str, Any]"},{"arg":"effective_search_ratio","type":"int"}],"return_type":"List[Document]","control_flow":[],"reason":"Method to perform similarity search based on a given embedding vector, returning a list of documents ranked by similarity score.","reason_kor":"주어진 임베딩 벡터를 기반으로 유사도 검색을 수행해 유사도 점수로 정렬된 문서 리스트를 반환하는 메서드입니다."},{"_key":"langchain_neo4j_vectorstores_neo4j_vector_py_similarity_search_with_score","_id":"nodes/langchain_neo4j_vectorstores_neo4j_vector_py_similarity_search_with_score","_rev":"_jzRpL_C---","type":"function","name":"similarity_search_with_score","defined_in":"langchain_neo4j_vectorstores_neo4j_vector_py","lineno":671,"source":"def similarity_search_with_score(\n        self,\n        query: str,\n        k: int = 4,\n        params: Dict[str, Any] = {},\n        filter: Optional[Dict[str, Any]] = None,\n        effective_search_ratio: int = 1,\n        **kwargs: Any,\n    ) -> List[Tuple[Document, float]]:\n        \"\"\"Return docs most similar to query.\n\n        Args:\n            query: Text to look up documents similar to.\n            k: Number of Documents to return. Defaults to 4.\n            params (Dict[str, Any]): The search params for the index type.\n                Defaults to empty dict.\n            filter (Optional[Dict[str, Any]]): Dictionary of argument(s) to\n                    filter on metadata.\n                Defaults to None.\n            effective_search_ratio (int): Controls the candidate pool size\n               by multiplying $k to balance query accuracy and performance.\n               Defaults to 1.\n\n        Returns:\n            List of Documents most similar to the query and score for each\n        \"\"\"\n        embedding = self.embedding.embed_query(query)\n        docs = self.similarity_search_with_score_by_vector(\n            embedding=embedding,\n            k=k,\n            query=query,\n            params=params,\n            filter=filter,\n            effective_search_ratio=effective_search_ratio,\n            **kwargs,\n        )\n        return docs","docstring":"Return docs most similar to query.\n\nArgs:\n    query: Text to look up documents similar to.\n    k: Number of Documents to return. Defaults to 4.\n    params (Dict[str, Any]): The search params for the index type.\n        Defaults to empty dict.\n    filter (Optional[Dict[str, Any]]): Dictionary of argument(s) to\n            filter on metadata.\n        Defaults to None.\n    effective_search_ratio (int): Controls the candidate pool size\n       by multiplying $k to balance query accuracy and performance.\n       Defaults to 1.\n\nReturns:\n    List of Documents most similar to the query and score for each","args":[{"arg":"self","type":null},{"arg":"query","type":"str"},{"arg":"k","type":"int"},{"arg":"params","type":"Dict[str, Any]"},{"arg":"filter","type":"Optional[Dict[str, Any]]"},{"arg":"effective_search_ratio","type":"int"}],"return_type":"List[Tuple[Document, float]]","control_flow":[],"reason":"Method to perform similarity search with scores using a natural language query, embedding the query and returning document-score pairs.","reason_kor":"자연어 쿼리를 임베딩하여 유사도 점수와 함께 문서-점수 쌍을 반환하는 유사도 검색 메서드입니다."},{"_key":"langchain_neo4j_vectorstores_neo4j_vector_py_similarity_search_with_score_by_vector","_id":"nodes/langchain_neo4j_vectorstores_neo4j_vector_py_similarity_search_with_score_by_vector","_rev":"_jzRpL_O---","type":"function","name":"similarity_search_with_score_by_vector","defined_in":"langchain_neo4j_vectorstores_neo4j_vector_py","lineno":709,"source":"def similarity_search_with_score_by_vector(\n        self,\n        embedding: List[float],\n        k: int = 4,\n        filter: Optional[Dict[str, Any]] = None,\n        params: Dict[str, Any] = {},\n        effective_search_ratio: int = 1,\n        **kwargs: Any,\n    ) -> List[Tuple[Document, float]]:\n        \"\"\"\n        Perform a similarity search in the Neo4j database using a\n        given vector and return the top k similar documents with their scores.\n\n        This method uses a Cypher query to find the top k documents that\n        are most similar to a given embedding. The similarity is measured\n        using a vector index in the Neo4j database. The results are returned\n        as a list of tuples, each containing a Document object and\n        its similarity score.\n\n        Args:\n            embedding (List[float]): The embedding vector to compare against.\n            k (int, optional): The number of top similar documents to retrieve.\n            filter (Optional[Dict[str, Any]]): Dictionary of argument(s) to\n                    filter on metadata.\n                Defaults to None.\n            params (Dict[str, Any]): The search params for the index type.\n                Defaults to empty dict.\n            effective_search_ratio (int): Controls the candidate pool size\n               by multiplying $k to balance query accuracy and performance.\n               Defaults to 1.\n\n        Returns:\n            List[Tuple[Document, float]]: A list of tuples, each containing\n                                a Document object and its similarity score.\n        \"\"\"\n        if filter and not self.support_metadata_filter:\n            raise ValueError(\n                \"Metadata filtering is only supported in \"\n                \"Neo4j version 5.18 or greater\"\n            )\n        entity_prefix = (\n            \"relationship\" if self._index_type == IndexType.RELATIONSHIP else \"node\"\n        )\n        default_retrieval = (\n            f\"RETURN {entity_prefix}.`{self.text_node_property}` AS text, score, \"\n            f\"{entity_prefix} \"\n            \"{.*, \"\n            f\"`{self.text_node_property}`: Null, \"\n            f\"`{self.embedding_node_property}`: Null, id: Null \"\n        )\n        if kwargs.get(\"return_embeddings\"):\n            default_retrieval += (\n                f\", _embedding_: {entity_prefix}.`{self.embedding_node_property}` \"\n            )\n        default_retrieval += \"} AS metadata\"\n        retrieval_query = (\n            self.retrieval_query if self.retrieval_query else default_retrieval\n        )\n\n        read_query, filter_params = get_search_query(\n            search_type=self.search_type,\n            entity_type=self._index_type,\n            retrieval_query=retrieval_query,\n            node_label=self.node_label,\n            embedding_node_property=self.embedding_node_property,\n            embedding_dimension=self.embedding_dimension,\n            filters=filter,\n            neo4j_version_is_5_23_or_above=self.neo4j_version_is_5_23_or_above,\n            use_parallel_runtime=self._is_enterprise,\n        )\n        parameters = {\n            \"vector_index_name\": self.index_name,\n            \"top_k\": k,\n            \"query_vector\": embedding,\n            \"fulltext_index_name\": self.keyword_index_name,\n            \"query_text\": remove_lucene_chars(kwargs[\"query\"]),\n            \"effective_search_ratio\": effective_search_ratio,\n            **params,\n            **filter_params,\n        }\n\n        results = self.query(read_query, params=parameters)\n\n        if any(result[\"text\"] is None for result in results):\n            if not self.retrieval_query:\n                raise ValueError(\n                    f\"Make sure that none of the `{self.text_node_property}` \"\n                    f\"properties on nodes with label `{self.node_label}` \"\n                    \"are missing or empty\"\n                )\n            else:\n                raise ValueError(\n                    \"Inspect the `retrieval_query` and ensure it doesn't \"\n                    \"return None for the `text` column\"\n                )\n        if kwargs.get(\"return_embeddings\") and any(\n            result[\"metadata\"][\"_embedding_\"] is None for result in results\n        ):\n            if not self.retrieval_query:\n                raise ValueError(\n                    f\"Make sure that none of the `{self.embedding_node_property}` \"\n                    f\"properties on nodes with label `{self.node_label}` \"\n                    \"are missing or empty\"\n                )\n            else:\n                raise ValueError(\n                    \"Inspect the `retrieval_query` and ensure it doesn't \"\n                    \"return None for the `_embedding_` metadata column\"\n                )\n\n        docs = [\n            (\n                Document(\n                    page_content=dict_to_yaml_str(result[\"text\"])\n                    if isinstance(result[\"text\"], dict)\n                    else result[\"text\"],\n                    metadata={\n                        k: v for k, v in result[\"metadata\"].items() if v is not None\n                    },\n                ),\n                result[\"score\"],\n            )\n            for result in results\n        ]\n        return docs","docstring":"Perform a similarity search in the Neo4j database using a\ngiven vector and return the top k similar documents with their scores.\n\nThis method uses a Cypher query to find the top k documents that\nare most similar to a given embedding. The similarity is measured\nusing a vector index in the Neo4j database. The results are returned\nas a list of tuples, each containing a Document object and\nits similarity score.\n\nArgs:\n    embedding (List[float]): The embedding vector to compare against.\n    k (int, optional): The number of top similar documents to retrieve.\n    filter (Optional[Dict[str, Any]]): Dictionary of argument(s) to\n            filter on metadata.\n        Defaults to None.\n    params (Dict[str, Any]): The search params for the index type.\n        Defaults to empty dict.\n    effective_search_ratio (int): Controls the candidate pool size\n       by multiplying $k to balance query accuracy and performance.\n       Defaults to 1.\n\nReturns:\n    List[Tuple[Document, float]]: A list of tuples, each containing\n                        a Document object and its similarity score.","args":[{"arg":"self","type":null},{"arg":"embedding","type":"List[float]"},{"arg":"k","type":"int"},{"arg":"filter","type":"Optional[Dict[str, Any]]"},{"arg":"params","type":"Dict[str, Any]"},{"arg":"effective_search_ratio","type":"int"}],"return_type":"List[Tuple[Document, float]]","control_flow":[{"type":"if","lineno":744},{"type":"if","lineno":759},{"type":"if","lineno":792},{"type":"if","lineno":793},{"type":"if","lineno":804},{"type":"if","lineno":807}],"reason":"it is about a vector similarity search in a Neo4j database with filtering, dynamic retrieval query construction, error handling for missing data, and conversion of raw results into Document objects with metadata and scores","reason_kor":"필터링, 동적 검색 쿼리 생성, 누락 데이터에 대한 오류 처리, 원시 결과를 메타데이터와 점수를 포함한 Document 객체로 변환하는 Neo4j 데이터베이스 내 벡터 유사도 검색을 수행합니다."},{"_key":"langchain_neo4j_vectorstores_neo4j_vector_py_verify_version","_id":"nodes/langchain_neo4j_vectorstores_neo4j_vector_py_verify_version","_rev":"_jzRpL_a---","type":"function","name":"verify_version","defined_in":"langchain_neo4j_vectorstores_neo4j_vector_py","lineno":346,"source":"def verify_version(self) -> None:\n        \"\"\"\n        Check if the connected Neo4j database version supports vector indexing.\n\n        Queries the Neo4j database to retrieve its version and compares it\n        against a target version (5.11.0) that is known to support vector\n        indexing. Raises a ValueError if the connected Neo4j version is\n        not supported.\n        \"\"\"\n        version_tuple, is_aura, is_enterprise = get_version(\n            self._driver, self._database\n        )\n        self._is_enterprise = is_enterprise\n        self.neo4j_version_is_5_23_or_above = is_version_5_23_or_above(version_tuple)\n        if not has_vector_index_support(version_tuple):\n            raise ValueError(\n                \"Vector index is only supported in Neo4j version 5.11 or greater\"\n            )\n        self.support_metadata_filter = has_metadata_filtering_support(\n            version_tuple, is_aura\n        )","docstring":"Check if the connected Neo4j database version supports vector indexing.\n\nQueries the Neo4j database to retrieve its version and compares it\nagainst a target version (5.11.0) that is known to support vector\nindexing. Raises a ValueError if the connected Neo4j version is\nnot supported.","args":[{"arg":"self","type":null}],"return_type":"None","control_flow":[{"type":"if","lineno":360}],"reason":"it is about version retrieval from the database, checks if the version supports vector indexing, and sets internal flags accordingly, raising an error if not supported.","reason_kor":"데이터베이스 버전을 조회하고 벡터 인덱싱을 지원하는지 확인하여 내부 플래그를 설정하며, 지원하지 않는 경우 오류를 발생시킴"},{"_key":"langchain_neo4j_vectorstores_utils_py","_id":"nodes/langchain_neo4j_vectorstores_utils_py","_rev":"_jzRpBOm---","type":"file","name":"utils.py","path":"C:\\workspace\\langchain-neo4j\\langchain_neo4j\\vectorstores\\utils.py"},{"_key":"langchain_neo4j_vectorstores_utils_py_DistanceStrategy","_id":"nodes/langchain_neo4j_vectorstores_utils_py_DistanceStrategy","_rev":"_jzRpL_m---","type":"class","name":"DistanceStrategy","defined_in":"langchain_neo4j_vectorstores_utils_py","lineno":4,"docstring":"Enumerator of the Distance strategies for calculating distances\nbetween vectors.","source":"class DistanceStrategy(str, Enum):\n    \"\"\"Enumerator of the Distance strategies for calculating distances\n    between vectors.\"\"\"\n\n    EUCLIDEAN_DISTANCE = \"EUCLIDEAN_DISTANCE\"\n    MAX_INNER_PRODUCT = \"MAX_INNER_PRODUCT\"\n    DOT_PRODUCT = \"DOT_PRODUCT\"\n    JACCARD = \"JACCARD\"\n    COSINE = \"COSINE\"","inst_variables":[],"reason":"Enumeration defining supported distance calculation strategies between vectors, such as Euclidean and Cosine distance.","reason_kor":"벡터 간 거리 계산 방식(유클리드, 코사인 등)을 정의한 열거형입니다."},{"_key":"poetry_lock","_id":"nodes/poetry_lock","_rev":"_jzRp_iG---","type":"file","name":"poetry.lock","path":"C:\\workspace\\langchain-neo4j\\poetry.lock"},{"_key":"pyproject_toml","_id":"nodes/pyproject_toml","_rev":"_jzRp_ie---","type":"file","name":"pyproject.toml","path":"C:\\workspace\\langchain-neo4j\\pyproject.toml"},{"_key":"scripts","_id":"nodes/scripts","_rev":"_jzRpBP6---","type":"directory","name":"scripts","path":"C:\\workspace\\langchain-neo4j\\scripts"},{"_key":"scripts_check_imports_py","_id":"nodes/scripts_check_imports_py","_rev":"_jzRpBQW---","type":"file","name":"check_imports.py","path":"C:\\workspace\\langchain-neo4j\\scripts\\check_imports.py"},{"_key":"scripts_lint_imports_sh","_id":"nodes/scripts_lint_imports_sh","_rev":"_jzRpBQy---","type":"file","name":"lint_imports.sh","path":"C:\\workspace\\langchain-neo4j\\scripts\\lint_imports.sh"},{"_key":"tests","_id":"nodes/tests","_rev":"_jzRpBRO---","type":"directory","name":"tests","path":"C:\\workspace\\langchain-neo4j\\tests"},{"_key":"tests___init___py","_id":"nodes/tests___init___py","_rev":"_jzRpBRq---","type":"file","name":"__init__.py","path":"C:\\workspace\\langchain-neo4j\\tests\\__init__.py"},{"_key":"tests_integration_tests","_id":"nodes/tests_integration_tests","_rev":"_jzRpBSK---","type":"directory","name":"integration_tests","path":"C:\\workspace\\langchain-neo4j\\tests\\integration_tests"},{"_key":"tests_integration_tests___init___py","_id":"nodes/tests_integration_tests___init___py","_rev":"_jzRpBWW---","type":"file","name":"__init__.py","path":"C:\\workspace\\langchain-neo4j\\tests\\integration_tests\\__init__.py"},{"_key":"tests_integration_tests_chains","_id":"nodes/tests_integration_tests_chains","_rev":"_jzRpBW2---","type":"directory","name":"chains","path":"C:\\workspace\\langchain-neo4j\\tests\\integration_tests\\chains"},{"_key":"tests_integration_tests_chains___init___py","_id":"nodes/tests_integration_tests_chains___init___py","_rev":"_jzRpBga---","type":"file","name":"__init__.py","path":"C:\\workspace\\langchain-neo4j\\tests\\integration_tests\\chains\\__init__.py"},{"_key":"tests_integration_tests_chains_test_graph_database_py","_id":"nodes/tests_integration_tests_chains_test_graph_database_py","_rev":"_jzRpBXa---","type":"file","name":"test_graph_database.py","path":"C:\\workspace\\langchain-neo4j\\tests\\integration_tests\\chains\\test_graph_database.py"},{"_key":"tests_integration_tests_chains_test_graph_database_py_test_cypher_generating_run","_id":"nodes/tests_integration_tests_chains_test_graph_database_py_test_cypher_generating_run","_rev":"_jzRpL_u---","type":"function","name":"test_cypher_generating_run","defined_in":"tests_integration_tests_chains_test_graph_database_py","lineno":15,"source":"def test_cypher_generating_run(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test that Cypher statement is correctly generated and executed.\"\"\"\n    graph = Neo4jGraph(**neo4j_credentials)\n    # Create two nodes and a relationship\n    graph.query(\n        \"CREATE (a:Actor {name:'Bruce Willis'})\"\n        \"-[:ACTED_IN]->(:Movie {title: 'Pulp Fiction'})\"\n    )\n    # Refresh schema information\n    graph.refresh_schema()\n\n    query = (\n        \"MATCH (a:Actor)-[:ACTED_IN]->(m:Movie) \"\n        \"WHERE m.title = 'Pulp Fiction' \"\n        \"RETURN a.name\"\n    )\n    llm = FakeLLM(\n        queries={\"query\": query, \"response\": \"Bruce Willis\"}, sequential_responses=True\n    )\n    chain = GraphCypherQAChain.from_llm(\n        llm=llm,\n        graph=graph,\n        validate_cypher=True,\n        allow_dangerous_requests=True,\n    )\n    output = chain.run(\"Who starred in Pulp Fiction?\")\n    expected_output = \"Bruce Willis\"\n    assert output == expected_output","docstring":"Test that Cypher statement is correctly generated and executed.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason":"it is about database operations with a testing framework to verify the correctness of Cypher query generation and execution, including setting up nodes, relationships, schema refresh, and validation through a language model interface.","reason_kor":"Cypher 쿼리 생성 및 실행의 정확성을 검증하기 위한 데이터베이스 작업과 테스트 프레임워크를 결합하여, 노드와 관계 설정, 스키마 갱신, 언어 모델 인터페이스를 통한 검증을 합니다."},{"_key":"tests_integration_tests_chains_test_graph_database_py_test_cypher_intermediate_steps","_id":"nodes/tests_integration_tests_chains_test_graph_database_py_test_cypher_intermediate_steps","_rev":"_jzRpL_6---","type":"function","name":"test_cypher_intermediate_steps","defined_in":"tests_integration_tests_chains_test_graph_database_py","lineno":79,"source":"def test_cypher_intermediate_steps(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test the returning of the intermediate steps.\"\"\"\n    graph = Neo4jGraph(**neo4j_credentials)\n    # Delete all nodes in the graph\n    graph.query(\"MATCH (n) DETACH DELETE n\")\n    # Create two nodes and a relationship\n    graph.query(\n        \"CREATE (a:Actor {name:'Bruce Willis'})\"\n        \"-[:ACTED_IN]->(:Movie {title: 'Pulp Fiction'})\"\n    )\n    # Refresh schema information\n    graph.refresh_schema()\n\n    query = (\n        \"MATCH (a:Actor)-[:ACTED_IN]->(m:Movie) \"\n        \"WHERE m.title = 'Pulp Fiction' \"\n        \"RETURN a.name\"\n    )\n    llm = FakeLLM(\n        queries={\"query\": query, \"response\": \"Bruce Willis\"}, sequential_responses=True\n    )\n    chain = GraphCypherQAChain.from_llm(\n        llm=llm,\n        graph=graph,\n        return_intermediate_steps=True,\n        allow_dangerous_requests=True,\n    )\n    output = chain(\"Who starred in Pulp Fiction?\")\n\n    expected_output = \"Bruce Willis\"\n    assert output[\"result\"] == expected_output\n\n    assert output[\"intermediate_steps\"][0][\"query\"] == query\n\n    context = output[\"intermediate_steps\"][1][\"context\"]\n    expected_context = [{\"a.name\": \"Bruce Willis\"}]\n    assert context == expected_context","docstring":"Test the returning of the intermediate steps.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason":"it is about graph database setup, schema refresh, query execution via a chain with LLM, and assertions to verify intermediate steps and final output","reason_kor":"그래프 데이터베이스 설정, 스키마 갱신, LLM을 통한 쿼리 실행, 중간 단계 및 최종 결과 확인을 위한 단언을 수행합니다."},{"_key":"tests_integration_tests_chains_test_graph_database_py_test_cypher_return_direct","_id":"nodes/tests_integration_tests_chains_test_graph_database_py_test_cypher_return_direct","_rev":"_jzRpLAC---","type":"function","name":"test_cypher_return_direct","defined_in":"tests_integration_tests_chains_test_graph_database_py","lineno":119,"source":"def test_cypher_return_direct(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test that chain returns direct results.\"\"\"\n    graph = Neo4jGraph(**neo4j_credentials)\n    # Delete all nodes in the graph\n    graph.query(\"MATCH (n) DETACH DELETE n\")\n    # Create two nodes and a relationship\n    graph.query(\n        \"CREATE (a:Actor {name:'Bruce Willis'})\"\n        \"-[:ACTED_IN]->(:Movie {title: 'Pulp Fiction'})\"\n    )\n    # Refresh schema information\n    graph.refresh_schema()\n\n    query = (\n        \"MATCH (a:Actor)-[:ACTED_IN]->(m:Movie) \"\n        \"WHERE m.title = 'Pulp Fiction' \"\n        \"RETURN a.name\"\n    )\n    llm = FakeLLM(queries={\"query\": query}, sequential_responses=True)\n    chain = GraphCypherQAChain.from_llm(\n        llm=llm,\n        graph=graph,\n        return_direct=True,\n        allow_dangerous_requests=True,\n    )\n    output = chain.run(\"Who starred in Pulp Fiction?\")\n    expected_output = [{\"a.name\": \"Bruce Willis\"}]\n    assert output == expected_output","docstring":"Test that chain returns direct results.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason":"it is about setting up a Neo4j graph with nodes and relationships, refreshing schema, creating a graph query, initializing a chain with return_direct=True to directly return query results, and running a question to verify the correct actor's name is retrieved from the graph.","reason_kor":"노드 및 관계가 포함된 Neo4j 그래프를 설정하고, 스키마를 갱신한 후 그래프 쿼리를 생성, return_direct=True인 체인을 초기화하여 쿼리 결과를 직접 반환하며, 질문 실행을 통해 올바른 배우 이름을 조회합니다."},{"_key":"tests_integration_tests_chains_test_graph_database_py_test_cypher_top_k","_id":"nodes/tests_integration_tests_chains_test_graph_database_py_test_cypher_top_k","_rev":"_jzRpLAO---","type":"function","name":"test_cypher_top_k","defined_in":"tests_integration_tests_chains_test_graph_database_py","lineno":46,"source":"def test_cypher_top_k(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test top_k parameter correctly limits the number of results in the context.\"\"\"\n    TOP_K = 1\n    graph = Neo4jGraph(**neo4j_credentials)\n    # Delete all nodes in the graph\n    graph.query(\"MATCH (n) DETACH DELETE n\")\n    # Create two nodes and a relationship\n    graph.query(\n        \"CREATE (a:Actor {name:'Bruce Willis'})\"\n        \"-[:ACTED_IN]->(:Movie {title: 'Pulp Fiction'})\"\n        \"<-[:ACTED_IN]-(:Actor {name:'Foo'})\"\n    )\n    # Refresh schema information\n    graph.refresh_schema()\n\n    query = (\n        \"MATCH (a:Actor)-[:ACTED_IN]->(m:Movie) \"\n        \"WHERE m.title = 'Pulp Fiction' \"\n        \"RETURN a.name\"\n    )\n    llm = FakeLLM(queries={\"query\": query}, sequential_responses=True)\n    chain = GraphCypherQAChain.from_llm(\n        llm=llm,\n        graph=graph,\n        return_direct=True,\n        top_k=TOP_K,\n        allow_dangerous_requests=True,\n    )\n    output = chain.run(\"Who starred in Pulp Fiction?\")\n    assert len(output) == TOP_K","docstring":"Test top_k parameter correctly limits the number of results in the context.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason":"it is about setting up a Neo4j graph with test data, executing a Cypher query to match actors in a specific movie, and using a chain with the 'top_k' parameter to limit the results to the specified number, then verifying that the output length matches the 'top_k' value.","reason_kor":"테스트 데이터가 포함된 Neo4j 그래프를 설정하고, 특정 영화에 출연한 배우를 매칭하는 Cypher 쿼리를 실행하며, 'top_k' 파라미터로 결과 수를 제한한 뒤 출력 길이가 'top_k'와 일치하는지 확인합니다."},{"_key":"tests_integration_tests_chains_test_graph_database_py_test_exclude_types","_id":"nodes/tests_integration_tests_chains_test_graph_database_py_test_exclude_types","_rev":"_jzRpLAa---","type":"function","name":"test_exclude_types","defined_in":"tests_integration_tests_chains_test_graph_database_py","lineno":183,"source":"def test_exclude_types(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test exclude types from schema.\"\"\"\n    graph = Neo4jGraph(**neo4j_credentials)\n    # Delete all nodes in the graph\n    graph.query(\"MATCH (n) DETACH DELETE n\")\n    # Create two nodes and a relationship\n    graph.query(\n        \"CREATE (a:Actor {name:'Bruce Willis'})\"\n        \"-[:ACTED_IN]->(:Movie {title: 'Pulp Fiction'})\"\n        \"<-[:DIRECTED]-(p:Person {name:'John'})\"\n    )\n    # Refresh schema information\n    graph.refresh_schema()\n\n    llm = MagicMock(spec=BaseLanguageModel)\n    chain = GraphCypherQAChain.from_llm(\n        llm=llm,\n        graph=graph,\n        exclude_types=[\"Person\", \"DIRECTED\"],\n        allow_dangerous_requests=True,\n    )\n    expected_schema = (\n        \"Node properties:\\n\"\n        \"Actor {name: STRING}\\n\"\n        \"Movie {title: STRING}\\n\"\n        \"Relationship properties:\\n\\n\"\n        \"The relationships:\\n\"\n        \"(:Actor)-[:ACTED_IN]->(:Movie)\"\n    )\n    assert chain.graph_schema == expected_schema","docstring":"Test exclude types from schema.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason":"it is about setting up a Neo4j graph with nodes and relationships, refreshing the schema, creating a chain with specific types excluded, and then asserting that the filtered schema matches the expected output.","reason_kor":"노드 및 관계가 포함된 Neo4j 그래프를 설정하고, 스키마를 갱신하며, 특정 유형을 제외하는 체인을 생성한 후 필터링된 스키마가 예상 출력과 일치하는지 단언합니다."},{"_key":"tests_integration_tests_chains_test_graph_database_py_test_function_response","_id":"nodes/tests_integration_tests_chains_test_graph_database_py_test_function_response","_rev":"_jzRpLAm---","type":"function","name":"test_function_response","defined_in":"tests_integration_tests_chains_test_graph_database_py","lineno":150,"source":"def test_function_response(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test returning a function response.\"\"\"\n    graph = Neo4jGraph(**neo4j_credentials)\n    # Delete all nodes in the graph\n    graph.query(\"MATCH (n) DETACH DELETE n\")\n    # Create two nodes and a relationship\n    graph.query(\n        \"CREATE (a:Actor {name:'Bruce Willis'})\"\n        \"-[:ACTED_IN]->(:Movie {title: 'Pulp Fiction'})\"\n    )\n    # Refresh schema information\n    graph.refresh_schema()\n\n    query = (\n        \"MATCH (a:Actor)-[:ACTED_IN]->(m:Movie) \"\n        \"WHERE m.title = 'Pulp Fiction' \"\n        \"RETURN a.name\"\n    )\n    llm = FakeLLM(\n        queries={\"query\": query, \"response\": \"Bruce Willis\"}, sequential_responses=True\n    )\n    chain = GraphCypherQAChain.from_llm(\n        llm=llm,\n        graph=graph,\n        allow_dangerous_requests=True,\n        use_function_response=True,\n    )\n    output = chain.run(\"Who starred in Pulp Fiction?\")\n    expected_output = \"Bruce Willis\"\n    assert output == expected_output","docstring":"Test returning a function response.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason_kor":"그래프 데이터베이스 작업과 언어 모델을 결합하여 쿼리를 생성하고, 체인을 사용해 사용자 질문을 해석하여 쿼리를 실행하고 FakeLLM 출력에 따라 관련 배우 이름을 반환함으로써 통합 데이터 조회와 응답을 수행합니다.","reason":"it is about graph database operations with a language model to create a query, then used a chain to interpret a user question, execute the query, and return the relevant actor's name based on the output from the FakeLLM, facilitating integrated data retrieval and response."},{"_key":"tests_integration_tests_chains_test_graph_database_py_test_include_types","_id":"nodes/tests_integration_tests_chains_test_graph_database_py_test_include_types","_rev":"_jzRpLAy---","type":"function","name":"test_include_types","defined_in":"tests_integration_tests_chains_test_graph_database_py","lineno":216,"source":"def test_include_types(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test include types from schema.\"\"\"\n    graph = Neo4jGraph(**neo4j_credentials)\n    # Delete all nodes in the graph\n    graph.query(\"MATCH (n) DETACH DELETE n\")\n    # Create two nodes and a relationship\n    graph.query(\n        \"CREATE (a:Actor {name:'Bruce Willis'})\"\n        \"-[:ACTED_IN]->(:Movie {title: 'Pulp Fiction'})\"\n        \"<-[:DIRECTED]-(p:Person {name:'John'})\"\n    )\n    # Refresh schema information\n    graph.refresh_schema()\n\n    llm = MagicMock(spec=BaseLanguageModel)\n    chain = GraphCypherQAChain.from_llm(\n        llm=llm,\n        graph=graph,\n        include_types=[\"Movie\", \"Actor\", \"ACTED_IN\"],\n        allow_dangerous_requests=True,\n    )\n    expected_schema = (\n        \"Node properties:\\n\"\n        \"Actor {name: STRING}\\n\"\n        \"Movie {title: STRING}\\n\"\n        \"Relationship properties:\\n\\n\"\n        \"The relationships:\\n\"\n        \"(:Actor)-[:ACTED_IN]->(:Movie)\"\n    )\n\n    assert chain.graph_schema == expected_schema","docstring":"Test include types from schema.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason_kor":"노드 및 관계가 포함된 Neo4j 그래프를 설정하고, 모의 언어 모델을 사용해 특정 스키마 유형을 포함하는 GraphCypherQAChain을 생성한 후 생성된 스키마 문자열을 예상 스키마와 비교하여 올바른 유형 포함을 검증합니다.","reason":"it is about setup of a Neo4j graph with nodes and relationships, then used a mock language model to create a GraphCypherQAChain that includes specific schema types, and finally compared the generated schema string to an expected schema to verify correct inclusion of types."},{"_key":"tests_integration_tests_chains_test_graph_database_py_test_include_types2","_id":"nodes/tests_integration_tests_chains_test_graph_database_py_test_include_types2","_rev":"_jzRpLA6---","type":"function","name":"test_include_types2","defined_in":"tests_integration_tests_chains_test_graph_database_py","lineno":250,"source":"def test_include_types2(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test include types from schema.\"\"\"\n    graph = Neo4jGraph(**neo4j_credentials)\n    # Delete all nodes in the graph\n    graph.query(\"MATCH (n) DETACH DELETE n\")\n    # Create two nodes and a relationship\n    graph.query(\n        \"CREATE (a:Actor {name:'Bruce Willis'})\"\n        \"-[:ACTED_IN]->(:Movie {title: 'Pulp Fiction'})\"\n        \"<-[:DIRECTED]-(p:Person {name:'John'})\"\n    )\n    # Refresh schema information\n    graph.refresh_schema()\n\n    llm = MagicMock(spec=BaseLanguageModel)\n    chain = GraphCypherQAChain.from_llm(\n        llm=llm,\n        graph=graph,\n        include_types=[\"Movie\", \"ACTED_IN\"],\n        allow_dangerous_requests=True,\n    )\n    expected_schema = (\n        \"Node properties:\\n\"\n        \"Movie {title: STRING}\\n\"\n        \"Relationship properties:\\n\\n\"\n        \"The relationships:\\n\"\n    )\n    assert chain.graph_schema == expected_schema","docstring":"Test include types from schema.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason_kor":"노드 및 관계가 포함된 Neo4j 그래프를 설정, 스키마 갱신, 모의 언어 모델 생성, 특정 include_types를 가진 GraphCypherQAChain 인스턴스를 생성하여 지정된 유형 기반으로 스키마를 올바르게 필터링하고 표현하는지 검증합니다.","reason":"it is about setup of Neo4j graph with nodes and relationships, schema refresh, creation of a mock language model, and instantiation of a GraphCypherQAChain with specific include_types to verify it correctly filters and represents the schema based on specified types."},{"_key":"tests_integration_tests_chat_message_histories","_id":"nodes/tests_integration_tests_chat_message_histories","_rev":"_jzRpBh----","type":"directory","name":"chat_message_histories","path":"C:\\workspace\\langchain-neo4j\\tests\\integration_tests\\chat_message_histories"},{"_key":"tests_integration_tests_chat_message_histories___init___py","_id":"nodes/tests_integration_tests_chat_message_histories___init___py","_rev":"_jzRpBt2---","type":"file","name":"__init__.py","path":"C:\\workspace\\langchain-neo4j\\tests\\integration_tests\\chat_message_histories\\__init__.py"},{"_key":"tests_integration_tests_chat_message_histories_test_neo4j_py","_id":"nodes/tests_integration_tests_chat_message_histories_test_neo4j_py","_rev":"_jzRpBha---","type":"file","name":"test_neo4j.py","path":"C:\\workspace\\langchain-neo4j\\tests\\integration_tests\\chat_message_histories\\test_neo4j.py"},{"_key":"tests_integration_tests_chat_message_histories_test_neo4j_py_test_add_messages","_id":"nodes/tests_integration_tests_chat_message_histories_test_neo4j_py_test_add_messages","_rev":"_jzRpLBG---","type":"function","name":"test_add_messages","defined_in":"tests_integration_tests_chat_message_histories_test_neo4j_py","lineno":13,"source":"def test_add_messages() -> None:\n    \"\"\"Basic testing: adding messages to the Neo4jChatMessageHistory.\"\"\"\n    assert os.environ.get(\"NEO4J_URI\") is not None\n    assert os.environ.get(\"NEO4J_USERNAME\") is not None\n    assert os.environ.get(\"NEO4J_PASSWORD\") is not None\n    message_store = Neo4jChatMessageHistory(\"23334\")\n    message_store.clear()\n    assert len(message_store.messages) == 0\n    message_store.add_user_message(\"Hello! Language Chain!\")\n    message_store.add_ai_message(\"Hi Guys!\")\n\n    # create another message store to check if the messages are stored correctly\n    message_store_another = Neo4jChatMessageHistory(\"46666\")\n    message_store_another.clear()\n    assert len(message_store_another.messages) == 0\n    message_store_another.add_user_message(\"Hello! Bot!\")\n    message_store_another.add_ai_message(\"Hi there!\")\n    message_store_another.add_user_message(\"How's this pr going?\")\n\n    # Now check if the messages are stored in the database correctly\n    assert len(message_store.messages) == 2\n    assert isinstance(message_store.messages[0], HumanMessage)\n    assert isinstance(message_store.messages[1], AIMessage)\n    assert message_store.messages[0].content == \"Hello! Language Chain!\"\n    assert message_store.messages[1].content == \"Hi Guys!\"\n\n    assert len(message_store_another.messages) == 3\n    assert isinstance(message_store_another.messages[0], HumanMessage)\n    assert isinstance(message_store_another.messages[1], AIMessage)\n    assert isinstance(message_store_another.messages[2], HumanMessage)\n    assert message_store_another.messages[0].content == \"Hello! Bot!\"\n    assert message_store_another.messages[1].content == \"Hi there!\"\n    assert message_store_another.messages[2].content == \"How's this pr going?\"\n\n    # Now clear the first history\n    message_store.clear()\n    assert len(message_store.messages) == 0\n    assert len(message_store_another.messages) == 3\n    message_store_another.clear()\n    assert len(message_store.messages) == 0\n    assert len(message_store_another.messages) == 0","docstring":"Basic testing: adding messages to the Neo4jChatMessageHistory.","args":[],"return_type":"None","control_flow":[],"reason_kor":"Neo4j 기반 채팅 메시지 히스토리 클래스의 기능을 검증하는 단위 테스트 절차로, 메시지 추가, 조회, 삭제를 확인하며 HumanMessage와 AIMessage 인스턴스 저장 및 유형 일관성을 보장하고 환경 변수 전제 조건도 검증합니다.","reason":"it is about unit testing procedures to verify the functionality of a Neo4j-based chat message history class. The test checks if messages can be added, retrieved, and cleared correctly, ensuring the storage and type consistency of HumanMessage and AIMessage instances, while also validating environment variable prerequisites."},{"_key":"tests_integration_tests_chat_message_histories_test_neo4j_py_test_add_messages_graph_object","_id":"nodes/tests_integration_tests_chat_message_histories_test_neo4j_py_test_add_messages_graph_object","_rev":"_jzRpLBS---","type":"function","name":"test_add_messages_graph_object","defined_in":"tests_integration_tests_chat_message_histories_test_neo4j_py","lineno":57,"source":"def test_add_messages_graph_object(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Basic testing: Passing driver through graph object.\"\"\"\n    graph = Neo4jGraph(**neo4j_credentials)\n    # rewrite env for testing\n    old_username = os.environ[\"NEO4J_USERNAME\"]\n    os.environ[\"NEO4J_USERNAME\"] = \"foo\"\n    message_store = Neo4jChatMessageHistory(\"23334\", graph=graph)\n    message_store.clear()\n    assert len(message_store.messages) == 0\n    message_store.add_user_message(\"Hello! Language Chain!\")\n    message_store.add_ai_message(\"Hi Guys!\")\n    # Now check if the messages are stored in the database correctly\n    assert len(message_store.messages) == 2\n    os.environ[\"NEO4J_USERNAME\"] = old_username","docstring":"Basic testing: Passing driver through graph object.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason_kor":"Neo4j 자격 증명, 환경 변수 조작, 메시지 저장소 조작(추가 및 삭제)을 포함하는 테스트 함수로, Neo4j 백엔드 채팅 히스토리에서 메시지 저장 기능을 검증합니다.","reason":"it is about neo4j credentials, environment variable manipulation, and message store operations (adding and clearing messages) within a test function to verify message storage functionality in a Neo4j-backed chat history"},{"_key":"tests_integration_tests_chat_message_histories_test_neo4j_py_test_invalid_credentials","_id":"nodes/tests_integration_tests_chat_message_histories_test_neo4j_py_test_invalid_credentials","_rev":"_jzRpLBe---","type":"function","name":"test_invalid_credentials","defined_in":"tests_integration_tests_chat_message_histories_test_neo4j_py","lineno":95,"source":"def test_invalid_credentials(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test initializing with invalid credentials raises ValueError.\"\"\"\n    with pytest.raises(ValueError) as exc_info:\n        Neo4jChatMessageHistory(\n            \"test_session\",\n            url=neo4j_credentials[\"url\"],\n            username=\"invalid_username\",\n            password=\"invalid_password\",\n        )\n    assert \"Please ensure that the username and password are correct\" in str(\n        exc_info.value\n    )","docstring":"Test initializing with invalid credentials raises ValueError.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason_kor":"잘못된 자격 증명으로 Neo4jChatMessageHistory 초기화 시 예외 처리를 테스트하며, 잘못된 사용자 이름 또는 비밀번호일 때 적절한 메시지와 함께 ValueError가 발생하는지 확인합니다.","reason":"it is about a function that tests exception handling when initializing Neo4jChatMessageHistory with invalid credentials, ensuring that a ValueError is raised with an appropriate message when incorrect username or password are used."},{"_key":"tests_integration_tests_chat_message_histories_test_neo4j_py_test_invalid_url","_id":"nodes/tests_integration_tests_chat_message_histories_test_neo4j_py_test_invalid_url","_rev":"_jzRpLBq---","type":"function","name":"test_invalid_url","defined_in":"tests_integration_tests_chat_message_histories_test_neo4j_py","lineno":73,"source":"def test_invalid_url(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test initializing with invalid credentials raises ValueError.\"\"\"\n    # Parse the original URL\n    parsed_url = urllib.parse.urlparse(neo4j_credentials[\"url\"])\n    # Increment the port number by 1 and wrap around if necessary\n    original_port = parsed_url.port or 7687\n    new_port = (original_port + 1) % 65535 or 1\n    # Reconstruct the netloc (hostname:port)\n    new_netloc = f\"{parsed_url.hostname}:{new_port}\"\n    # Rebuild the URL with the new netloc\n    new_url = parsed_url._replace(netloc=new_netloc).geturl()\n\n    with pytest.raises(ValueError) as exc_info:\n        Neo4jChatMessageHistory(\n            \"test_session\",\n            url=new_url,\n            username=neo4j_credentials[\"username\"],\n            password=neo4j_credentials[\"password\"],\n        )\n    assert \"Please ensure that the url is correct\" in str(exc_info.value)","docstring":"Test initializing with invalid credentials raises ValueError.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason":"it is about URL parsing to modify the port by incrementing it, then reconstructed the URL with the new port, and tested that initializing Neo4jChatMessageHistory with this invalid URL raised a ValueError with the specific message.","reason_kor":"포트를 증가시켜 URL을 수정한 후 재구성하며, 이 잘못된 URL로 Neo4jChatMessageHistory 초기화 시 특정 메시지와 함께 ValueError가 발생하는지 테스트합니다."},{"_key":"tests_integration_tests_chat_message_histories_test_neo4j_py_test_neo4j_message_history_clear_messages","_id":"nodes/tests_integration_tests_chat_message_histories_test_neo4j_py_test_neo4j_message_history_clear_messages","_rev":"_jzRpLB2---","type":"function","name":"test_neo4j_message_history_clear_messages","defined_in":"tests_integration_tests_chat_message_histories_test_neo4j_py","lineno":110,"source":"def test_neo4j_message_history_clear_messages(\n    neo4j_credentials: Neo4jCredentials,\n) -> None:\n    message_history = Neo4jChatMessageHistory(session_id=\"123\", **neo4j_credentials)\n    message_history.add_messages(\n        [\n            HumanMessage(content=\"You are a helpful assistant.\"),\n            AIMessage(content=\"Hello\"),\n        ]\n    )\n    assert len(message_history.messages) == 2\n    message_history.clear()\n    assert len(message_history.messages) == 0\n    # Test that the session node is not deleted\n    results = message_history._driver.execute_query(\n        query_=\"MATCH (s:`Session`) WHERE s.id = '123' RETURN s\"\n    )\n    assert len(results.records) == 1\n    assert results.records[0][\"s\"][\"id\"] == \"123\"\n    assert list(results.records[0][\"s\"].labels) == [\"Session\"]","docstring":null,"args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason":"it is about creating a Neo4jChatMessageHistory instance, adding messages to it, verifying message count, clearing messages, and confirming the session node remains in the database after clearing messages.","reason_kor":"Neo4jChatMessageHistory 인스턴스를 생성하고 메시지를 추가, 메시지 개수를 확인한 후 메시지를 삭제하고 세션 노드가 데이터베이스에 남아있는지 확인합니다."},{"_key":"tests_integration_tests_chat_message_histories_test_neo4j_py_test_neo4j_message_history_clear_session_and_messages","_id":"nodes/tests_integration_tests_chat_message_histories_test_neo4j_py_test_neo4j_message_history_clear_session_and_messages","_rev":"_jzRpLCC---","type":"function","name":"test_neo4j_message_history_clear_session_and_messages","defined_in":"tests_integration_tests_chat_message_histories_test_neo4j_py","lineno":133,"source":"def test_neo4j_message_history_clear_session_and_messages(\n    neo4j_credentials: Neo4jCredentials,\n) -> None:\n    message_history = Neo4jChatMessageHistory(session_id=\"123\", **neo4j_credentials)\n    message_history.add_messages(\n        [\n            HumanMessage(content=\"You are a helpful assistant.\"),\n            AIMessage(content=\"Hello\"),\n        ]\n    )\n    assert len(message_history.messages) == 2\n    message_history.clear(delete_session_node=True)\n    assert len(message_history.messages) == 0\n    # Test that the session node is deleted\n    results = message_history._driver.execute_query(\n        query_=\"MATCH (s:`Session`) WHERE s.id = '123' RETURN s\"\n    )\n    assert results.records == []","docstring":null,"args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason":"it is about creating a message history with a specific session ID, adding messages to it, asserting the message count, clearing messages and optionally deleting the session node, and verifying the session node deletion in the database.","reason_kor":"특정 세션 ID로 메시지 히스토리를 생성, 메시지 추가 및 개수 단언, 메시지 삭제 및 선택적으로 세션 노드 삭제, 세션 노드 삭제 여부를 데이터베이스에서 검증합니다."},{"_key":"tests_integration_tests_conftest_py","_id":"nodes/tests_integration_tests_conftest_py","_rev":"_jzRpBSu---","type":"file","name":"conftest.py","path":"C:\\workspace\\langchain-neo4j\\tests\\integration_tests\\conftest.py"},{"_key":"tests_integration_tests_conftest_py_clear_neo4j_database","_id":"nodes/tests_integration_tests_conftest_py_clear_neo4j_database","_rev":"_jzRpLCO---","type":"function","name":"clear_neo4j_database","defined_in":"tests_integration_tests_conftest_py","lineno":17,"source":"def clear_neo4j_database() -> None:\n    driver = neo4j.GraphDatabase.driver(url, auth=(username, password))\n    driver.execute_query(\"MATCH (n) DETACH DELETE n;\")\n    driver.close()","docstring":null,"args":[],"return_type":"None","control_flow":[],"reason":"Test fixture utility to clear all nodes and relationships from the Neo4j database before running integration tests.","reason_kor":"통합 테스트 실행 전 Neo4j 데이터베이스의 모든 노드와 관계를 삭제하는 테스트 헬퍼 함수입니다."},{"_key":"tests_integration_tests_conftest_py_neo4j_credentials","_id":"nodes/tests_integration_tests_conftest_py_neo4j_credentials","_rev":"_jzRpLCa---","type":"function","name":"neo4j_credentials","defined_in":"tests_integration_tests_conftest_py","lineno":24,"source":"def neo4j_credentials() -> Neo4jCredentials:\n    return {\n        \"url\": url,\n        \"username\": username,\n        \"password\": password,\n    }","docstring":null,"args":[],"return_type":"Neo4jCredentials","control_flow":[],"reason":"Test fixture utility providing Neo4j connection credentials as a typed dictionary for use in integration tests.","reason_kor":"통합 테스트에 사용할 Neo4j 접속 정보를 타입 딕셔너리 형태로 제공하는 테스트 헬퍼입니다."},{"_key":"tests_integration_tests_docker-compose","_id":"nodes/tests_integration_tests_docker-compose","_rev":"_jzRpBui---","type":"directory","name":"docker-compose","path":"C:\\workspace\\langchain-neo4j\\tests\\integration_tests\\docker-compose"},{"_key":"tests_integration_tests_docker-compose_neo4j_yml","_id":"nodes/tests_integration_tests_docker-compose_neo4j_yml","_rev":"_jzRpBvG---","type":"file","name":"neo4j.yml","path":"C:\\workspace\\langchain-neo4j\\tests\\integration_tests\\docker-compose\\neo4j.yml"},{"_key":"tests_integration_tests_graphs","_id":"nodes/tests_integration_tests_graphs","_rev":"_jzRpBvq---","type":"directory","name":"graphs","path":"C:\\workspace\\langchain-neo4j\\tests\\integration_tests\\graphs"},{"_key":"tests_integration_tests_graphs___init___py","_id":"nodes/tests_integration_tests_graphs___init___py","_rev":"_jzRpCG----","type":"file","name":"__init__.py","path":"C:\\workspace\\langchain-neo4j\\tests\\integration_tests\\graphs\\__init__.py"},{"_key":"tests_integration_tests_graphs_test_neo4j_py","_id":"nodes/tests_integration_tests_graphs_test_neo4j_py","_rev":"_jzRpBwW---","type":"file","name":"test_neo4j.py","path":"C:\\workspace\\langchain-neo4j\\tests\\integration_tests\\graphs\\test_neo4j.py"},{"_key":"tests_integration_tests_graphs_test_neo4j_py_test_backticks","_id":"nodes/tests_integration_tests_graphs_test_neo4j_py_test_backticks","_rev":"_jzRpLCm---","type":"function","name":"test_backticks","defined_in":"tests_integration_tests_graphs_test_neo4j_py","lineno":356,"source":"def test_backticks(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test that backticks are correctly removed.\"\"\"\n    graph = Neo4jGraph(**neo4j_credentials)\n    graph.query(\"MATCH (n) DETACH DELETE n\")\n    graph.add_graph_documents(test_data_backticks)\n    nodes = graph.query(\"MATCH (n) RETURN labels(n) AS labels ORDER BY n.id\")\n    rels = graph.query(\"MATCH ()-[r]->() RETURN type(r) AS type\")\n    expected_nodes = [{\"labels\": [\"bar\"]}, {\"labels\": [\"foo\"]}]\n    expected_rels = [{\"type\": \"REL\"}]\n\n    assert nodes == expected_nodes\n    assert rels == expected_rels","docstring":"Test that backticks are correctly removed.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason":"it is about the creation and deletion of nodes, adding test data with backticks, executing queries to retrieve nodes and relationships, and asserting the results match expected values to verify backtick removal.","reason_kor":"노드 생성 및 삭제, 백틱이 포함된 테스트 데이터 추가, 쿼리 실행을 통해 노드와 관계를 조회하고 결과가 기대값과 일치하는지 단언하여 백틱 제거 기능을 검증합니다."},{"_key":"tests_integration_tests_graphs_test_neo4j_py_test_connect_neo4j","_id":"nodes/tests_integration_tests_graphs_test_neo4j_py_test_connect_neo4j","_rev":"_jzRpLCy---","type":"function","name":"test_connect_neo4j","defined_in":"tests_integration_tests_graphs_test_neo4j_py","lineno":44,"source":"def test_connect_neo4j(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test that Neo4j database is correctly instantiated and connected.\"\"\"\n    graph = Neo4jGraph(**neo4j_credentials)\n\n    output = graph.query('RETURN \"test\" AS output')\n    expected_output = [{\"output\": \"test\"}]\n    assert output == expected_output","docstring":"Test that Neo4j database is correctly instantiated and connected.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason":"it is about creating a Neo4jGraph instance with provided credentials and executing a query to verify the connection by matching the expected output","reason_kor":"제공된 자격 증명으로 Neo4jGraph 인스턴스를 생성하고, 예상 결과와 일치하는 쿼리를 실행하여 연결을 검증합니다."},{"_key":"tests_integration_tests_graphs_test_neo4j_py_test_connect_neo4j_env","_id":"nodes/tests_integration_tests_graphs_test_neo4j_py_test_connect_neo4j_env","_rev":"_jzRpLD----","type":"function","name":"test_connect_neo4j_env","defined_in":"tests_integration_tests_graphs_test_neo4j_py","lineno":54,"source":"def test_connect_neo4j_env() -> None:\n    \"\"\"Test that Neo4j database environment variables.\"\"\"\n    assert os.environ.get(\"NEO4J_URI\") is not None\n    assert os.environ.get(\"NEO4J_USERNAME\") is not None\n    assert os.environ.get(\"NEO4J_PASSWORD\") is not None\n    graph = Neo4jGraph()\n\n    output = graph.query('RETURN \"test\" AS output')\n    expected_output = [{\"output\": \"test\"}]\n    assert output == expected_output","docstring":"Test that Neo4j database environment variables.","args":[],"return_type":"None","control_flow":[],"reason":"it is about environment variable checks for NEO4J connection and a simple query execution to verify Neo4j database connectivity","reason_kor":"NEO4J 연결을 위한 환경 변수 확인과 단순 쿼리 실행으로 Neo4j 데이터베이스 연결을 검증합니다."},{"_key":"tests_integration_tests_graphs_test_neo4j_py_test_cypher_return_correct_schema","_id":"nodes/tests_integration_tests_graphs_test_neo4j_py_test_cypher_return_correct_schema","_rev":"_jzRpLDK---","type":"function","name":"test_cypher_return_correct_schema","defined_in":"tests_integration_tests_graphs_test_neo4j_py","lineno":67,"source":"def test_cypher_return_correct_schema(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test that chain returns direct results.\"\"\"\n    graph = Neo4jGraph(**neo4j_credentials)\n    # Delete all nodes in the graph\n    graph.query(\"MATCH (n) DETACH DELETE n\")\n    # Create two nodes and a relationship\n    graph.query(\n        \"\"\"\n        CREATE (la:LabelA {property_a: 'a'})\n        CREATE (lb:LabelB)\n        CREATE (lc:LabelC)\n        MERGE (la)-[:REL_TYPE]-> (lb)\n        MERGE (la)-[:REL_TYPE {rel_prop: 'abc'}]-> (lc)\n        \"\"\"\n    )\n    # Refresh schema information\n    graph.refresh_schema()\n\n    node_properties = graph.query(\n        NODE_PROPERTIES_QUERY, params={\"EXCLUDED_LABELS\": [BASE_ENTITY_LABEL]}\n    )\n    relationships_properties = graph.query(\n        REL_PROPERTIES_QUERY, params={\"EXCLUDED_LABELS\": [BASE_ENTITY_LABEL]}\n    )\n    relationships = graph.query(\n        REL_QUERY, params={\"EXCLUDED_LABELS\": [BASE_ENTITY_LABEL]}\n    )\n\n    expected_node_properties = [\n        {\n            \"output\": {\n                \"properties\": [{\"property\": \"property_a\", \"type\": \"STRING\"}],\n                \"label\": \"LabelA\",\n            }\n        }\n    ]\n    expected_relationships_properties = [\n        {\n            \"output\": {\n                \"type\": \"REL_TYPE\",\n                \"properties\": [{\"property\": \"rel_prop\", \"type\": \"STRING\"}],\n            }\n        }\n    ]\n    expected_relationships = [\n        {\"output\": {\"start\": \"LabelA\", \"type\": \"REL_TYPE\", \"end\": \"LabelB\"}},\n        {\"output\": {\"start\": \"LabelA\", \"type\": \"REL_TYPE\", \"end\": \"LabelC\"}},\n    ]\n\n    assert node_properties == expected_node_properties\n    assert relationships_properties == expected_relationships_properties\n    # Order is not guaranteed with Neo4j returns\n    assert (\n        sorted(relationships, key=lambda x: x[\"output\"][\"end\"])\n        == expected_relationships\n    )","docstring":"Test that chain returns direct results.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason":"it is about setting up a Neo4j graph with nodes and relationships, refreshing the schema, querying for node properties, relationship properties, and relationships, and then asserting that these queries return the expected schemas and relationships indicating the function tests that the graph schema matches predefined expectations.","reason_kor":"노드 및 관계를 포함한 Neo4j 그래프 설정, 스키마 갱신, 노드 속성, 관계 속성 및 관계 쿼리를 수행하여 반환된 스키마 및 관계가 기대값과 일치하는지 확인, 그래프 스키마가 사전 정의된 기대와 일치함을 테스트합니다."},{"_key":"tests_integration_tests_graphs_test_neo4j_py_test_driver_config","_id":"nodes/tests_integration_tests_graphs_test_neo4j_py_test_driver_config","_rev":"_jzRpLDW---","type":"function","name":"test_driver_config","defined_in":"tests_integration_tests_graphs_test_neo4j_py","lineno":270,"source":"def test_driver_config(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test that neo4j works with driver config.\"\"\"\n    graph = Neo4jGraph(\n        driver_config={\"max_connection_pool_size\": 1}, **neo4j_credentials\n    )\n    graph.query(\"RETURN 'foo'\")","docstring":"Test that neo4j works with driver config.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason":"it is about an instance of Neo4jGraph with a custom driver configuration including max_connection_pool_size, and also supplied neo4j credentials to establish a connection, then executed a simple query to test the setup","reason_kor":"max_connection_pool_size를 포함한 사용자 정의 드라이버 구성을 가진 Neo4jGraph 인스턴스를 생성하고, neo4j 자격 증명도 제공하여 연결 설정 후 간단한 쿼리 실행을 테스트합니다."},{"_key":"tests_integration_tests_graphs_test_neo4j_py_test_enhanced_schema","_id":"nodes/tests_integration_tests_graphs_test_neo4j_py_test_enhanced_schema","_rev":"_jzRpLDi---","type":"function","name":"test_enhanced_schema","defined_in":"tests_integration_tests_graphs_test_neo4j_py","lineno":279,"source":"def test_enhanced_schema(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test that neo4j works with driver config.\"\"\"\n    graph = Neo4jGraph(enhanced_schema=True, **neo4j_credentials)\n    graph.query(\"MATCH (n) DETACH DELETE n\")\n    graph.add_graph_documents(test_data)\n    graph.refresh_schema()\n    expected_output = {\n        \"node_props\": {\n            \"foo\": [\n                {\n                    \"property\": \"id\",\n                    \"type\": \"STRING\",\n                    \"values\": [\"foo\"],\n                    \"distinct_count\": 1,\n                }\n            ],\n            \"bar\": [\n                {\n                    \"property\": \"id\",\n                    \"type\": \"STRING\",\n                    \"values\": [\"bar\"],\n                    \"distinct_count\": 1,\n                }\n            ],\n        },\n        \"rel_props\": {\n            \"REL\": [\n                {\n                    \"distinct_count\": 1,\n                    \"property\": \"key\",\n                    \"type\": \"STRING\",\n                    \"values\": [\"val\"],\n                }\n            ]\n        },\n        \"relationships\": [{\"start\": \"foo\", \"type\": \"REL\", \"end\": \"bar\"}],\n    }\n    # remove metadata portion of schema\n    del graph.structured_schema[\"metadata\"]\n    assert graph.structured_schema == expected_output","docstring":"Test that neo4j works with driver config.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason":"it is about the creation and configuration of a Neo4j graph with an enhanced schema, added test data, refreshed the schema, and then verified that the generated schema matched the expected structure by removing metadata before comparison.","reason_kor":"향상된 스키마와 테스트 데이터를 포함하는 Neo4j 그래프를 생성, 스키마 갱신 후 메타데이터를 제거하고 생성된 스키마가 기대 구조와 일치하는지 검증합니다."},{"_key":"tests_integration_tests_graphs_test_neo4j_py_test_enhanced_schema_exception","_id":"nodes/tests_integration_tests_graphs_test_neo4j_py_test_enhanced_schema_exception","_rev":"_jzRpLDu---","type":"function","name":"test_enhanced_schema_exception","defined_in":"tests_integration_tests_graphs_test_neo4j_py","lineno":322,"source":"def test_enhanced_schema_exception(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test no error with weird schema.\"\"\"\n    graph = Neo4jGraph(enhanced_schema=True, refresh_schema=False, **neo4j_credentials)\n    graph.query(\"MATCH (n) DETACH DELETE n\")\n    graph.query(\n        \"CREATE (:Node {foo: 'bar'}), (:Node {foo: 1}), (:Node {foo: [1,2]}), \"\n        \"(: EmptyNode)\"\n    )\n    graph.query(\n        \"MATCH (a:Node {foo: 'bar'}), (b:Node {foo: 1}), \"\n        \"(c:Node {foo: [1,2]}), (d: EmptyNode) \"\n        \"CREATE (a)-[:REL {foo: 'bar'}]->(b), (b)-[:REL {foo: 1}]->(c), \"\n        \"(c)-[:REL {foo: [1,2]}]->(a), (d)-[:EMPTY_REL {}]->(d)\"\n    )\n    graph.refresh_schema()\n    expected_output = {\n        \"node_props\": {\"Node\": [{\"property\": \"foo\", \"type\": \"STRING\"}]},\n        \"rel_props\": {\"REL\": [{\"property\": \"foo\", \"type\": \"STRING\"}]},\n        \"relationships\": [\n            {\n                \"end\": \"Node\",\n                \"start\": \"Node\",\n                \"type\": \"REL\",\n            },\n            {\"end\": \"EmptyNode\", \"start\": \"EmptyNode\", \"type\": \"EMPTY_REL\"},\n        ],\n    }\n\n    # remove metadata portion of schema\n    del graph.structured_schema[\"metadata\"]\n    assert graph.structured_schema == expected_output","docstring":"Test no error with weird schema.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason":"it is about schema creation with arbitrary data insertion, refreshing the schema, and finally comparing the generated schema structure to an expected output without metadata to verify correctness","reason_kor":"임의 데이터를 삽입하여 스키마를 생성하고 스키마를 갱신한 후, 메타데이터 없이 생성된 스키마 구조를 기대 출력과 비교하여 정확성을 검증합니다."},{"_key":"tests_integration_tests_graphs_test_neo4j_py_test_invalid_credentials","_id":"nodes/tests_integration_tests_graphs_test_neo4j_py_test_invalid_credentials","_rev":"_jzRpLD6---","type":"function","name":"test_invalid_credentials","defined_in":"tests_integration_tests_graphs_test_neo4j_py","lineno":516,"source":"def test_invalid_credentials(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test initializing with invalid credentials raises ValueError.\"\"\"\n\n    with pytest.raises(ValueError) as exc_info:\n        Neo4jGraph(\n            url=neo4j_credentials[\"url\"],\n            username=\"invalid_username\",\n            password=\"invalid_password\",\n        )\n    assert \"Please ensure that the username and password are correct\" in str(\n        exc_info.value\n    )","docstring":"Test initializing with invalid credentials raises ValueError.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason":"it is about a test function that attempts to initialize a Neo4jGraph with invalid credentials, expecting a ValueError to be raised, and then verifies that the error message contains a specific message indicating incorrect username or password.","reason_kor":"잘못된 자격 증명으로 Neo4jGraph 초기화를 시도하여 ValueError 발생을 기대하고, 오류 메시지에 잘못된 사용자 이름 또는 비밀번호가 포함되었는지 검증합니다."},{"_key":"tests_integration_tests_graphs_test_neo4j_py_test_invalid_url","_id":"nodes/tests_integration_tests_graphs_test_neo4j_py_test_invalid_url","_rev":"_jzRpLEG---","type":"function","name":"test_invalid_url","defined_in":"tests_integration_tests_graphs_test_neo4j_py","lineno":494,"source":"def test_invalid_url(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test initializing with invalid credentials raises ValueError.\"\"\"\n    # Parse the original URL\n    parsed_url = urllib.parse.urlparse(neo4j_credentials[\"url\"])\n    # Increment the port number by 1 and wrap around if necessary\n    original_port = parsed_url.port or 7687\n    new_port = (original_port + 1) % 65535 or 1\n    # Reconstruct the netloc (hostname:port)\n    new_netloc = f\"{parsed_url.hostname}:{new_port}\"\n    # Rebuild the URL with the new netloc\n    new_url = parsed_url._replace(netloc=new_netloc).geturl()\n\n    with pytest.raises(ValueError) as exc_info:\n        Neo4jGraph(\n            url=new_url,\n            username=neo4j_credentials[\"username\"],\n            password=neo4j_credentials[\"password\"],\n        )\n    assert \"Please ensure that the url is correct\" in str(exc_info.value)","docstring":"Test initializing with invalid credentials raises ValueError.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason":"it is about URL parsing, port modification, URL reconstruction, and exception testing to verify that initializing Neo4jGraph with an invalid URL raises a ValueError with an appropriate message","reason_kor":"URL 파싱, 포트 수정, URL 재구성 및 예외 테스트를 수행하여 잘못된 URL로 Neo4jGraph 초기화 시 적절한 메시지의 ValueError가 발생하는지 확인합니다."},{"_key":"tests_integration_tests_graphs_test_neo4j_py_test_neo4j_add_data","_id":"nodes/tests_integration_tests_graphs_test_neo4j_py_test_neo4j_add_data","_rev":"_jzRpLEW---","type":"function","name":"test_neo4j_add_data","defined_in":"tests_integration_tests_graphs_test_neo4j_py","lineno":162,"source":"def test_neo4j_add_data(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test that neo4j correctly import graph document.\"\"\"\n    graph = Neo4jGraph(sanitize=True, **neo4j_credentials)\n    # Delete all nodes in the graph\n    graph.query(\"MATCH (n) DETACH DELETE n\")\n    # Remove all constraints\n    graph.query(\"CALL apoc.schema.assert({}, {})\")\n    graph.refresh_schema()\n    # Create two nodes and a relationship\n    graph.add_graph_documents(test_data)\n    output = graph.query(\n        \"MATCH (n) RETURN labels(n) AS label, count(*) AS count ORDER BY label\"\n    )\n    assert output == [{\"label\": [\"bar\"], \"count\": 1}, {\"label\": [\"foo\"], \"count\": 1}]\n    assert graph.structured_schema[\"metadata\"][\"constraint\"] == []","docstring":"Test that neo4j correctly import graph document.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason":"it is about the setup and testing of a Neo4j graph database by initializing the graph, clearing existing data and constraints, importing test data, executing a query to verify node labels and counts, and asserting the expected results to ensure correct data import and schema constraints.","reason_kor":"Neo4j 그래프 데이터베이스 설정과 테스트 수행: 그래프 초기화, 기존 데이터 및 제약 조건 삭제, 테스트 데이터 가져오기, 노드 라벨 및 개수 검증 쿼리 실행, 기대 결과 단언을 포함하여 데이터 가져오기 및 스키마 제약 조건이 올바른지 확인합니다."},{"_key":"tests_integration_tests_graphs_test_neo4j_py_test_neo4j_add_data_base","_id":"nodes/tests_integration_tests_graphs_test_neo4j_py_test_neo4j_add_data_base","_rev":"_jzRpLEi---","type":"function","name":"test_neo4j_add_data_base","defined_in":"tests_integration_tests_graphs_test_neo4j_py","lineno":202,"source":"def test_neo4j_add_data_base(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test that neo4j correctly import graph document with base_entity.\"\"\"\n    graph = Neo4jGraph(sanitize=True, **neo4j_credentials)\n    # Delete all nodes in the graph\n    graph.query(\"MATCH (n) DETACH DELETE n\")\n    # Remove all constraints\n    graph.query(\"CALL apoc.schema.assert({}, {})\")\n    graph.refresh_schema()\n    # Create two nodes and a relationship\n    graph.add_graph_documents(test_data, baseEntityLabel=True)\n    output = graph.query(\n        \"MATCH (n) RETURN apoc.coll.sort(labels(n)) AS label, \"\n        \"count(*) AS count ORDER BY label\"\n    )\n    assert output == [\n        {\"label\": [BASE_ENTITY_LABEL, \"bar\"], \"count\": 1},\n        {\"label\": [BASE_ENTITY_LABEL, \"foo\"], \"count\": 1},\n    ]\n    assert graph.structured_schema[\"metadata\"][\"constraint\"] != []","docstring":"Test that neo4j correctly import graph document with base_entity.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason":"it is about the creation and cleanup of the Neo4j graph database with schema assertions and data insertion, then verified that the data was correctly added by querying node labels and counts, and checked that constraints exist in the structured schema.","reason_kor":"Neo4j 그래프 데이터베이스 생성 및 정리, 스키마 단언과 데이터 삽입을 수행하며, 노드 라벨 및 개수 쿼리로 데이터가 올바르게 추가되었음을 확인하고, 구조화된 스키마 내 제약 조건 존재 여부를 점검합니다."},{"_key":"tests_integration_tests_graphs_test_neo4j_py_test_neo4j_add_data_base_source","_id":"nodes/tests_integration_tests_graphs_test_neo4j_py_test_neo4j_add_data_base_source","_rev":"_jzRpLEu---","type":"function","name":"test_neo4j_add_data_base_source","defined_in":"tests_integration_tests_graphs_test_neo4j_py","lineno":224,"source":"def test_neo4j_add_data_base_source(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test that neo4j correctly import graph document with base_entity and source.\"\"\"\n    graph = Neo4jGraph(sanitize=True, **neo4j_credentials)\n    # Delete all nodes in the graph\n    graph.query(\"MATCH (n) DETACH DELETE n\")\n    # Remove all constraints\n    graph.query(\"CALL apoc.schema.assert({}, {})\")\n    graph.refresh_schema()\n    # Create two nodes and a relationship\n    graph.add_graph_documents(test_data, baseEntityLabel=True, include_source=True)\n    output = graph.query(\n        \"MATCH (n) RETURN apoc.coll.sort(labels(n)) AS label, \"\n        \"count(*) AS count ORDER BY label\"\n    )\n    assert output == [\n        {\"label\": [\"Document\"], \"count\": 1},\n        {\"label\": [BASE_ENTITY_LABEL, \"bar\"], \"count\": 1},\n        {\"label\": [BASE_ENTITY_LABEL, \"foo\"], \"count\": 1},\n    ]\n    assert graph.structured_schema[\"metadata\"][\"constraint\"] != []","docstring":"Test that neo4j correctly import graph document with base_entity and source.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason":"it is about the setup of a Neo4j graph database with data cleanup, schema reset, data insertion, and verification steps to ensure correct import of data and schema constraints","reason_kor":"데이터 정리, 스키마 초기화, 데이터 삽입, 검증 단계를 포함하는 Neo4j 그래프 데이터베이스 설정을 수행하여 데이터 및 스키마 제약 조건의 올바른 가져오기를 보장합니다."},{"_key":"tests_integration_tests_graphs_test_neo4j_py_test_neo4j_add_data_source","_id":"nodes/tests_integration_tests_graphs_test_neo4j_py_test_neo4j_add_data_source","_rev":"_jzRpLE6---","type":"function","name":"test_neo4j_add_data_source","defined_in":"tests_integration_tests_graphs_test_neo4j_py","lineno":180,"source":"def test_neo4j_add_data_source(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test that neo4j correctly import graph document with source.\"\"\"\n    graph = Neo4jGraph(sanitize=True, **neo4j_credentials)\n    # Delete all nodes in the graph\n    graph.query(\"MATCH (n) DETACH DELETE n\")\n    # Remove all constraints\n    graph.query(\"CALL apoc.schema.assert({}, {})\")\n    graph.refresh_schema()\n    # Create two nodes and a relationship\n    graph.add_graph_documents(test_data, include_source=True)\n    output = graph.query(\n        \"MATCH (n) RETURN labels(n) AS label, count(*) AS count ORDER BY label\"\n    )\n    assert output == [\n        {\"label\": [\"Document\"], \"count\": 1},\n        {\"label\": [\"bar\"], \"count\": 1},\n        {\"label\": [\"foo\"], \"count\": 1},\n    ]\n    assert graph.structured_schema[\"metadata\"][\"constraint\"] == []","docstring":"Test that neo4j correctly import graph document with source.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason":"it is about setting up a Neo4j graph, clearing existing data and constraints, importing new data with source information, validating the imported nodes with a query, and checking that no constraints remain in the schema","reason_kor":"Neo4j 그래프를 설정하고 기존 데이터 및 제약 조건을 삭제하며, 소스 정보를 포함한 새 데이터를 가져오고, 쿼리를 통해 가져온 노드를 검증하고 스키마에 제약 조건이 남아있지 않은지 확인합니다."},{"_key":"tests_integration_tests_graphs_test_neo4j_py_test_neo4j_concurrent_connections","_id":"nodes/tests_integration_tests_graphs_test_neo4j_py_test_neo4j_concurrent_connections","_rev":"_jzRpLFG---","type":"function","name":"test_neo4j_concurrent_connections","defined_in":"tests_integration_tests_graphs_test_neo4j_py","lineno":433,"source":"def test_neo4j_concurrent_connections(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test that multiple Neo4jGraph instances can be used independently.\"\"\"\n    graph1 = Neo4jGraph(**neo4j_credentials)\n    graph2 = Neo4jGraph(**neo4j_credentials)\n\n    # Both connections should work independently\n    assert graph1.query(\"RETURN 1 as n\") == [{\"n\": 1}]\n    assert graph2.query(\"RETURN 2 as n\") == [{\"n\": 2}]\n\n    # Closing one shouldn't affect the other\n    graph1.close()\n    try:\n        graph1.query(\"RETURN 1\")\n        assert False, \"Expected RuntimeError when using closed connection\"\n    except RuntimeError:\n        pass\n    assert graph2.query(\"RETURN 2 as n\") == [{\"n\": 2}]\n\n    graph2.close()","docstring":"Test that multiple Neo4jGraph instances can be used independently.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[{"type":"try","lineno":444}],"reason":"it is about the creation of two Neo4jGraph instances with the same credentials, tested independent queries on both, and verified that closing one does not affect the other, ensuring concurrent connection independence","reason_kor":"동일한 자격 증명을 가진 두 Neo4jGraph 인스턴스를 생성하고, 각각 독립적으로 쿼리를 실행하며, 하나를 닫아도 다른 하나에 영향을 미치지 않아 동시 연결 독립성을 검증합니다."},{"_key":"tests_integration_tests_graphs_test_neo4j_py_test_neo4j_context_manager","_id":"nodes/tests_integration_tests_graphs_test_neo4j_py_test_neo4j_context_manager","_rev":"_jzRpLFS---","type":"function","name":"test_neo4j_context_manager","defined_in":"tests_integration_tests_graphs_test_neo4j_py","lineno":371,"source":"def test_neo4j_context_manager(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test that Neo4jGraph works correctly with context manager.\"\"\"\n    with Neo4jGraph(**neo4j_credentials) as graph:\n        # Test that the connection is working\n        graph.query(\"RETURN 1 as n\")\n\n    # Test that the connection is closed after exiting context\n    try:\n        graph.query(\"RETURN 1 as n\")\n        assert False, \"Expected RuntimeError when using closed connection\"\n    except RuntimeError:\n        pass","docstring":"Test that Neo4jGraph works correctly with context manager.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[{"type":"try","lineno":378}],"reason":"it is about the use of a context manager to ensure proper opening and closing of the Neo4j connection, with a test to verify that the connection is closed after exiting the context, ensuring resource management and error handling.","reason_kor":"Neo4j 연결의 적절한 열기 및 닫기를 보장하기 위해 컨텍스트 매니저를 사용하며, 컨텍스트 종료 후 연결이 닫혔는지 확인하는 테스트를 수행하여 리소스 관리 및 오류 처리를 보장합니다."},{"_key":"tests_integration_tests_graphs_test_neo4j_py_test_neo4j_error_after_close","_id":"nodes/tests_integration_tests_graphs_test_neo4j_py_test_neo4j_error_after_close","_rev":"_jzRpLFe---","type":"function","name":"test_neo4j_error_after_close","defined_in":"tests_integration_tests_graphs_test_neo4j_py","lineno":404,"source":"def test_neo4j_error_after_close(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test that Neo4jGraph operations raise proper errors after closing.\"\"\"\n    graph = Neo4jGraph(**neo4j_credentials)\n    graph.query(\"RETURN 1\")  # Should work\n    graph.close()\n\n    # Test various operations after close\n    try:\n        graph.refresh_schema()\n        assert (\n            False\n        ), \"Expected RuntimeError when refreshing schema on closed connection\"\n    except RuntimeError as e:\n        assert \"connection has been closed\" in str(e)\n\n    try:\n        graph.query(\"RETURN 1\")\n        assert False, \"Expected RuntimeError when querying closed connection\"\n    except RuntimeError as e:\n        assert \"connection has been closed\" in str(e)\n\n    try:\n        graph.add_graph_documents([test_data[0]])\n        assert False, \"Expected RuntimeError when adding documents to closed connection\"\n    except RuntimeError as e:\n        assert \"connection has been closed\" in str(e)","docstring":"Test that Neo4jGraph operations raise proper errors after closing.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[{"type":"try","lineno":411},{"type":"try","lineno":419},{"type":"try","lineno":425}],"reason":"it is about a testing function that verifies proper error handling in Neo4jGraph after closing the connection, by performing various operations post-close and asserting that they raise RuntimeError with appropriate messages","reason_kor":"Neo4jGraph의 닫기 후 적절한 오류 처리를 검증하는 테스트 함수로, 닫은 후 다양한 작업 수행 시 RuntimeError가 적절한 메시지와 함께 발생하는지 단언합니다."},{"_key":"tests_integration_tests_graphs_test_neo4j_py_test_neo4j_explicit_close","_id":"nodes/tests_integration_tests_graphs_test_neo4j_py_test_neo4j_explicit_close","_rev":"_jzRpLFm---","type":"function","name":"test_neo4j_explicit_close","defined_in":"tests_integration_tests_graphs_test_neo4j_py","lineno":386,"source":"def test_neo4j_explicit_close(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test that Neo4jGraph can be explicitly closed.\"\"\"\n    graph = Neo4jGraph(**neo4j_credentials)\n    # Test that the connection is working\n    graph.query(\"RETURN 1 as n\")\n\n    # Close the connection\n    graph.close()\n\n    # Test that the connection is closed\n    try:\n        graph.query(\"RETURN 1 as n\")\n        assert False, \"Expected RuntimeError when using closed connection\"\n    except RuntimeError:\n        pass","docstring":"Test that Neo4jGraph can be explicitly closed.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[{"type":"try","lineno":396}],"reason":"it is about creating a Neo4jGraph instance, connecting to the database, executing a query, closing the connection explicitly, and then verifying that subsequent queries raise a RuntimeError due to the closed connection","reason_kor":"Neo4jGraph 인스턴스를 생성하고 데이터베이스에 연결, 쿼리를 실행한 후 명시적으로 연결을 닫고, 이후 쿼리 실행 시 연결 종료로 인한 RuntimeError 발생을 확인합니다."},{"_key":"tests_integration_tests_graphs_test_neo4j_py_test_neo4j_filtering_labels","_id":"nodes/tests_integration_tests_graphs_test_neo4j_py_test_neo4j_filtering_labels","_rev":"_jzRpLFy---","type":"function","name":"test_neo4j_filtering_labels","defined_in":"tests_integration_tests_graphs_test_neo4j_py","lineno":247,"source":"def test_neo4j_filtering_labels(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test that neo4j correctly filters excluded labels.\"\"\"\n    graph = Neo4jGraph(sanitize=True, **neo4j_credentials)\n    # Delete all nodes in the graph\n    graph.query(\"MATCH (n) DETACH DELETE n\")\n    # Remove all constraints\n    graph.query(\"CALL apoc.schema.assert({}, {})\")\n    graph.query(\n        \"\"\"\n        CREATE (:_Bloom_Scene_ {property_a: 'a'})\n        -[:_Bloom_HAS_SCENE_ {property_b: 'b'}]\n        ->(:_Bloom_Perspective_)\n        \"\"\"\n    )\n    graph.refresh_schema()\n\n    # Assert all are empty\n    assert graph.structured_schema[\"node_props\"] == {}\n    assert graph.structured_schema[\"rel_props\"] == {}\n    assert graph.structured_schema[\"relationships\"] == []","docstring":"Test that neo4j correctly filters excluded labels.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason":"it is about setup of testing environment by clearing existing data and constraints, creating specific nodes and relationships with labels and properties, refreshing the schema, and verifying that no residual schema data remains after setup, thereby ensuring neo4j's filtering by labels functions correctly","reason_kor":"테스트 환경 설정: 기존 데이터 및 제약 조건 삭제, 특정 라벨과 속성을 가진 노드 및 관계 생성, 스키마 갱신 후 잔여 스키마 데이터가 없음을 검증하여 Neo4j의 라벨 필터링 기능이 올바르게 작동함을 보장합니다."},{"_key":"tests_integration_tests_graphs_test_neo4j_py_test_neo4j_multiple_close","_id":"nodes/tests_integration_tests_graphs_test_neo4j_py_test_neo4j_multiple_close","_rev":"_jzRpLG----","type":"function","name":"test_neo4j_multiple_close","defined_in":"tests_integration_tests_graphs_test_neo4j_py","lineno":485,"source":"def test_neo4j_multiple_close(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test that Neo4jGraph can be closed multiple times without error.\"\"\"\n    graph = Neo4jGraph(**neo4j_credentials)\n    # Test that multiple closes don't raise errors\n    graph.close()\n    graph.close()","docstring":"Test that Neo4jGraph can be closed multiple times without error.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason_kor":"주어진 자격 증명으로 Neo4jGraph 인스턴스를 생성하고 닫기 메서드를 두 번 호출하여 여러 번 닫아도 오류가 발생하지 않는지 확인합니다.","reason":"it is about creating an instance of Neo4jGraph with given credentials and then calling its close method twice to ensure no errors occur when closing multiple times"},{"_key":"tests_integration_tests_graphs_test_neo4j_py_test_neo4j_nested_context_managers","_id":"nodes/tests_integration_tests_graphs_test_neo4j_py_test_neo4j_nested_context_managers","_rev":"_jzRpLGK---","type":"function","name":"test_neo4j_nested_context_managers","defined_in":"tests_integration_tests_graphs_test_neo4j_py","lineno":455,"source":"def test_neo4j_nested_context_managers(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test that nested context managers work correctly.\"\"\"\n    with Neo4jGraph(**neo4j_credentials) as graph1:\n        with Neo4jGraph(**neo4j_credentials) as graph2:\n            # Both connections should work\n            assert graph1.query(\"RETURN 1 as n\") == [{\"n\": 1}]\n            assert graph2.query(\"RETURN 2 as n\") == [{\"n\": 2}]\n\n        # Inner connection should be closed, outer still works\n        try:\n            graph2.query(\"RETURN 2\")\n            assert False, \"Expected RuntimeError when using closed connection\"\n        except RuntimeError:\n            pass\n        assert graph1.query(\"RETURN 1 as n\") == [{\"n\": 1}]\n\n    # Both connections should be closed\n    try:\n        graph1.query(\"RETURN 1\")\n        assert False, \"Expected RuntimeError when using closed connection\"\n    except RuntimeError:\n        pass\n    try:\n        graph2.query(\"RETURN 2\")\n        assert False, \"Expected RuntimeError when using closed connection\"\n    except RuntimeError:\n        pass","docstring":"Test that nested context managers work correctly.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[{"type":"try","lineno":464},{"type":"try","lineno":472},{"type":"try","lineno":477}],"reason_kor":"중첩 컨텍스트 매니저를 사용한 Neo4jGraph 연결 처리 및 테스트를 수행하며, 내부 'with' 블록 내 각 인스턴스가 쿼리를 정상 실행하는지 확인하고, 내부 컨텍스트 종료 후 연결이 닫혔음을 RuntimeError 발생으로 검증함. 외부 연결은 블록 종료 시까지 정상 동작하는지 단언하여 자원 관리 및 정상 닫기를 보장합니다.","reason":"it is about nested context managers for Neo4jGraph to ensure proper connection handling and testing. Inside the nested 'with' statements, it verifies that each Neo4jGraph instance can execute queries correctly, and after exiting the inner context, it confirms the connection is closed by expecting RuntimeErrors. It further asserts that outer connections remain functional until their block ends, ensuring resources are correctly managed and closed as expected."},{"_key":"tests_integration_tests_graphs_test_neo4j_py_test_neo4j_sanitize_values","_id":"nodes/tests_integration_tests_graphs_test_neo4j_py_test_neo4j_sanitize_values","_rev":"_jzRpLGW---","type":"function","name":"test_neo4j_sanitize_values","defined_in":"tests_integration_tests_graphs_test_neo4j_py","lineno":140,"source":"def test_neo4j_sanitize_values(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test that lists with more than 128 elements are removed from the results.\"\"\"\n    graph = Neo4jGraph(sanitize=True, **neo4j_credentials)\n    # Delete all nodes in the graph\n    graph.query(\"MATCH (n) DETACH DELETE n\")\n    # Create two nodes and a relationship\n    graph.query(\n        \"\"\"\n        CREATE (la:LabelA {property_a: 'a'})\n        CREATE (lb:LabelB)\n        CREATE (lc:LabelC)\n        MERGE (la)-[:REL_TYPE]-> (lb)\n        MERGE (la)-[:REL_TYPE {rel_prop: 'abc'}]-> (lc)\n        \"\"\"\n    )\n    graph.refresh_schema()\n\n    output = graph.query(\"RETURN range(0,130,1) AS result\")\n    assert output == [{}]","docstring":"Test that lists with more than 128 elements are removed from the results.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason_kor":"특정 노드 및 관계가 포함된 Neo4j 그래프를 설정하고, 범위 내 숫자를 조회하는 쿼리를 실행하여 출력이 기대치와 일치하는지 확인함으로써 대용량 리스트 처리 기능을 간접적으로 테스트합니다.","reason":"it is about the setup of a Neo4j graph with specific nodes and relationships, then executed a query to retrieve a range of numbers, and ensured that the output matched expectations, indirectly testing the database's handling of large lists."},{"_key":"tests_integration_tests_graphs_test_neo4j_py_test_neo4j_timeout","_id":"nodes/tests_integration_tests_graphs_test_neo4j_py_test_neo4j_timeout","_rev":"_jzRpLGi---","type":"function","name":"test_neo4j_timeout","defined_in":"tests_integration_tests_graphs_test_neo4j_py","lineno":126,"source":"def test_neo4j_timeout(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test that neo4j uses the timeout correctly.\"\"\"\n    graph = Neo4jGraph(timeout=0.1, **neo4j_credentials)\n    try:\n        graph.query(\"UNWIND range(0,100000,1) AS i MERGE (:Foo {id:i})\")\n    except Exception as e:\n        assert hasattr(e, \"code\")\n        assert (\n            e.code\n            == \"Neo.ClientError.Transaction.TransactionTimedOutClientConfiguration\"\n        )","docstring":"Test that neo4j uses the timeout correctly.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[{"type":"try","lineno":129}],"reason_kor":"짧은 타임아웃이 설정된 Neo4jGraph 인스턴스를 생성하고, 대용량 쿼리를 실행해 타임아웃을 유발시키며, 예외가 예상된 트랜잭션 타임아웃 코드와 함께 발생하는지 확인합니다.","reason":"it is about creating a Neo4jGraph instance with a short timeout, executing a large query to trigger timeout behavior, and verifying that the exception raised has the expected error code indicating a transaction timeout."},{"_key":"tests_integration_tests_test_compile_py","_id":"nodes/tests_integration_tests_test_compile_py","_rev":"_jzRpBUS---","type":"file","name":"test_compile.py","path":"C:\\workspace\\langchain-neo4j\\tests\\integration_tests\\test_compile.py"},{"_key":"tests_integration_tests_test_compile_py_test_placeholder","_id":"nodes/tests_integration_tests_test_compile_py_test_placeholder","_rev":"_jzRpLGu---","type":"function","name":"test_placeholder","defined_in":"tests_integration_tests_test_compile_py","lineno":5,"source":"def test_placeholder() -> None:\n    \"\"\"Used for compiling integration tests without running any real tests.\"\"\"\n    pass","docstring":"Used for compiling integration tests without running any real tests.","args":[],"return_type":"None","control_flow":[],"reason_kor":"실제 테스트를 실행하지 않고 통합 테스트 컴파일을 가능하게 하는 플레이스홀더 테스트 함수입니다.","reason":"Placeholder test function included to enable integration test compilation without running actual tests."},{"_key":"tests_integration_tests_utils_py","_id":"nodes/tests_integration_tests_utils_py","_rev":"_jzRpBVS---","type":"file","name":"utils.py","path":"C:\\workspace\\langchain-neo4j\\tests\\integration_tests\\utils.py"},{"_key":"tests_integration_tests_utils_py_Neo4jCredentials","_id":"nodes/tests_integration_tests_utils_py_Neo4jCredentials","_rev":"_jzRpLG6---","type":"class","name":"Neo4jCredentials","defined_in":"tests_integration_tests_utils_py","lineno":4,"docstring":null,"source":"class Neo4jCredentials(TypedDict):\n    url: str\n    username: str\n    password: str","inst_variables":[],"reason_kor":"Neo4j 접속 정보를 나타내는 URL, 사용자명, 비밀번호 필드를 포함한 타입 딕셔너리 정의입니다.","reason":"Typed dictionary defining the structure of Neo4j connection credentials including URL, username, and password."},{"_key":"tests_integration_tests_vectorstores","_id":"nodes/tests_integration_tests_vectorstores","_rev":"_jzRpCGW---","type":"directory","name":"vectorstores","path":"C:\\workspace\\langchain-neo4j\\tests\\integration_tests\\vectorstores"},{"_key":"tests_integration_tests_vectorstores___init___py","_id":"nodes/tests_integration_tests_vectorstores___init___py","_rev":"_jzRpDQu---","type":"file","name":"__init__.py","path":"C:\\workspace\\langchain-neo4j\\tests\\integration_tests\\vectorstores\\__init__.py"},{"_key":"tests_integration_tests_vectorstores_fake_embeddings_py","_id":"nodes/tests_integration_tests_vectorstores_fake_embeddings_py","_rev":"_jzRpCGu---","type":"file","name":"fake_embeddings.py","path":"C:\\workspace\\langchain-neo4j\\tests\\integration_tests\\vectorstores\\fake_embeddings.py"},{"_key":"tests_integration_tests_vectorstores_fake_embeddings_py_AngularTwoDimensionalEmbeddings","_id":"nodes/tests_integration_tests_vectorstores_fake_embeddings_py_AngularTwoDimensionalEmbeddings","_rev":"_jzRpLHG---","type":"class","name":"AngularTwoDimensionalEmbeddings","defined_in":"tests_integration_tests_vectorstores_fake_embeddings_py","lineno":59,"docstring":"From angles (as strings in units of pi) to unit embedding vectors on a circle.","source":"class AngularTwoDimensionalEmbeddings(Embeddings):\n    \"\"\"\n    From angles (as strings in units of pi) to unit embedding vectors on a circle.\n    \"\"\"\n\n    def embed_documents(self, texts: List[str]) -> List[List[float]]:\n        \"\"\"\n        Make a list of texts into a list of embedding vectors.\n        \"\"\"\n        return [self.embed_query(text) for text in texts]\n\n    def embed_query(self, text: str) -> List[float]:\n        \"\"\"\n        Convert input text to a 'vector' (list of floats).\n        If the text is a number, use it as the angle for the\n        unit vector in units of pi.\n        Any other input text becomes the singular result [0, 0] !\n        \"\"\"\n        try:\n            angle = float(text)\n            return [math.cos(angle * math.pi), math.sin(angle * math.pi)]\n        except ValueError:\n            # Assume: just test string, no attention is paid to values.\n            return [0.0, 0.0]","inst_variables":[],"reason_kor":"입력 문자열(파이 단위 각도)을 2차원 원 위 단위 벡터로 변환하는 임베딩 클래스; 숫자가 아니면 [0,0] 반환.","reason":"Embedding class that converts input strings representing angles (in units of pi) into 2D unit vectors on a circle; non-numeric inputs yield [0,0]."},{"_key":"tests_integration_tests_vectorstores_fake_embeddings_py_ConsistentFakeEmbeddings","_id":"nodes/tests_integration_tests_vectorstores_fake_embeddings_py_ConsistentFakeEmbeddings","_rev":"_jzRpLHO---","type":"class","name":"ConsistentFakeEmbeddings","defined_in":"tests_integration_tests_vectorstores_fake_embeddings_py","lineno":33,"docstring":"Fake embeddings which remember all the texts seen so far to return consistent\nvectors for the same texts.","source":"class ConsistentFakeEmbeddings(FakeEmbeddings):\n    \"\"\"Fake embeddings which remember all the texts seen so far to return consistent\n    vectors for the same texts.\"\"\"\n\n    def __init__(self, dimensionality: int = 10) -> None:\n        self.known_texts: List[str] = []\n        self.dimensionality = dimensionality\n\n    def embed_documents(self, texts: List[str]) -> List[List[float]]:\n        \"\"\"Return consistent embeddings for each text seen so far.\"\"\"\n        out_vectors = []\n        for text in texts:\n            if text not in self.known_texts:\n                self.known_texts.append(text)\n            vector = [float(1.0)] * (self.dimensionality - 1) + [\n                float(self.known_texts.index(text))\n            ]\n            out_vectors.append(vector)\n        return out_vectors\n\n    def embed_query(self, text: str) -> List[float]:\n        \"\"\"Return consistent embeddings for the text, if seen before, or a constant\n        one if the text is unknown.\"\"\"\n        return self.embed_documents([text])[0]","inst_variables":[{"var":"dimensionality","type":null,"value":"dimensionality","lineno":39}],"reason_kor":"지금까지 본 텍스트를 기억해 같은 텍스트에 일관된 벡터를 반환하는 테스트용 임베딩 클래스.","reason":"Fake embedding class that produces consistent vector embeddings by remembering all previously seen texts, ensuring same text gets the same vector."},{"_key":"tests_integration_tests_vectorstores_fake_embeddings_py_FakeEmbeddings","_id":"nodes/tests_integration_tests_vectorstores_fake_embeddings_py_FakeEmbeddings","_rev":"_jzRpLHa---","type":"class","name":"FakeEmbeddings","defined_in":"tests_integration_tests_vectorstores_fake_embeddings_py","lineno":11,"docstring":"Fake embeddings functionality for testing.","source":"class FakeEmbeddings(Embeddings):\n    \"\"\"Fake embeddings functionality for testing.\"\"\"\n\n    def embed_documents(self, texts: List[str]) -> List[List[float]]:\n        \"\"\"Return simple embeddings.\n        Embeddings encode each text as its index.\"\"\"\n        return [[float(1.0)] * 9 + [float(i)] for i in range(len(texts))]\n\n    async def aembed_documents(self, texts: List[str]) -> List[List[float]]:\n        return self.embed_documents(texts)\n\n    def embed_query(self, text: str) -> List[float]:\n        \"\"\"Return constant query embeddings.\n        Embeddings are identical to embed_documents(texts)[0].\n        Distance to each text will be that text's index,\n        as it was passed to embed_documents.\"\"\"\n        return [float(1.0)] * 9 + [float(0.0)]\n\n    async def aembed_query(self, text: str) -> List[float]:\n        return self.embed_query(text)","inst_variables":[],"reason_kor":"텍스트 인덱스를 간단히 인코딩한 임베딩을 반환하는 테스트용 기본 임베딩 클래스(동기/비동기 지원).","reason":"Basic fake embedding class for testing, which returns simple embeddings encoding each text's index; supports synchronous and async methods."},{"_key":"tests_integration_tests_vectorstores_fake_embeddings_py___init__","_id":"nodes/tests_integration_tests_vectorstores_fake_embeddings_py___init__","_rev":"_jzRpLHm---","type":"function","name":"__init__","defined_in":"tests_integration_tests_vectorstores_fake_embeddings_py","lineno":37,"source":"def __init__(self, dimensionality: int = 10) -> None:\n        self.known_texts: List[str] = []\n        self.dimensionality = dimensionality","docstring":null,"args":[{"arg":"self","type":null},{"arg":"dimensionality","type":"int"}],"return_type":"None","control_flow":[],"reason_kor":"임베딩 차원을 설정하고 이미 본 텍스트 목록을 초기화하는 가짜 임베딩 클래스의 초기화 메서드.","reason":"Initializer for a fake embeddings class that sets the embedding dimensionality and initializes known texts list."},{"_key":"tests_integration_tests_vectorstores_fake_embeddings_py_embed_documents","_id":"nodes/tests_integration_tests_vectorstores_fake_embeddings_py_embed_documents","_rev":"_jzRpLHy---","type":"function","name":"embed_documents","defined_in":"tests_integration_tests_vectorstores_fake_embeddings_py","lineno":64,"source":"def embed_documents(self, texts: List[str]) -> List[List[float]]:\n        \"\"\"\n        Make a list of texts into a list of embedding vectors.\n        \"\"\"\n        return [self.embed_query(text) for text in texts]","docstring":"Make a list of texts into a list of embedding vectors.","args":[{"arg":"self","type":null},{"arg":"texts","type":"List[str]"}],"return_type":"List[List[float]]","control_flow":[],"reason_kor":"입력 리스트 내 각 텍스트에 대해 self.embed_query를 호출하는 리스트 컴프리헨션을 사용해 텍스트 리스트를 임베딩 벡터 리스트로 변환합니다.","reason":"it is about a list comprehension with the call to self.embed_query for each text in the input list, transforming a list of texts into a list of corresponding embedding vectors."},{"_key":"tests_integration_tests_vectorstores_fake_embeddings_py_embed_query","_id":"nodes/tests_integration_tests_vectorstores_fake_embeddings_py_embed_query","_rev":"_jzRpLI----","type":"function","name":"embed_query","defined_in":"tests_integration_tests_vectorstores_fake_embeddings_py","lineno":70,"source":"def embed_query(self, text: str) -> List[float]:\n        \"\"\"\n        Convert input text to a 'vector' (list of floats).\n        If the text is a number, use it as the angle for the\n        unit vector in units of pi.\n        Any other input text becomes the singular result [0, 0] !\n        \"\"\"\n        try:\n            angle = float(text)\n            return [math.cos(angle * math.pi), math.sin(angle * math.pi)]\n        except ValueError:\n            # Assume: just test string, no attention is paid to values.\n            return [0.0, 0.0]","docstring":"Convert input text to a 'vector' (list of floats).\nIf the text is a number, use it as the angle for the\nunit vector in units of pi.\nAny other input text becomes the singular result [0, 0] !","args":[{"arg":"self","type":null},{"arg":"text","type":"str"}],"return_type":"List[float]","control_flow":[{"type":"try","lineno":77}],"reason_kor":"입력 텍스트가 float으로 변환 가능한지 조건 검사 후, 변환 가능하면 pi 단위 각도로 벡터 생성, 그렇지 않으면 기본 벡터 [0.0, 0.0]을 생성하는 타입 변환과 조건부 로직을 결합합니다.","reason":"it is about type conversion with conditional logic to generate a vector based on whether the input text can be converted to a float, representing an angle in units of pi, or defaulting to a placeholder vector [0.0, 0.0]."},{"_key":"tests_integration_tests_vectorstores_fixtures","_id":"nodes/tests_integration_tests_vectorstores_fixtures","_rev":"_jzRpDRK---","type":"directory","name":"fixtures","path":"C:\\workspace\\langchain-neo4j\\tests\\integration_tests\\vectorstores\\fixtures"},{"_key":"tests_integration_tests_vectorstores_fixtures___init___py","_id":"nodes/tests_integration_tests_vectorstores_fixtures___init___py","_rev":"_jzRpDSG---","type":"file","name":"__init__.py","path":"C:\\workspace\\langchain-neo4j\\tests\\integration_tests\\vectorstores\\fixtures\\__init__.py"},{"_key":"tests_integration_tests_vectorstores_fixtures_filtering_test_cases_py","_id":"nodes/tests_integration_tests_vectorstores_fixtures_filtering_test_cases_py","_rev":"_jzRpDRi---","type":"file","name":"filtering_test_cases.py","path":"C:\\workspace\\langchain-neo4j\\tests\\integration_tests\\vectorstores\\fixtures\\filtering_test_cases.py"},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py","_rev":"_jzRpCNS---","type":"file","name":"test_neo4jvector.py","path":"C:\\workspace\\langchain-neo4j\\tests\\integration_tests\\vectorstores\\test_neo4jvector.py"},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_FakeEmbeddingsWithOsDimension","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_FakeEmbeddingsWithOsDimension","_rev":"_jzRpLIK---","type":"class","name":"FakeEmbeddingsWithOsDimension","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":53,"docstring":"Fake embeddings functionality for testing.","source":"class FakeEmbeddingsWithOsDimension(FakeEmbeddings):\n    \"\"\"Fake embeddings functionality for testing.\"\"\"\n\n    def embed_documents(self, embedding_texts: List[str]) -> List[List[float]]:\n        \"\"\"Return simple embeddings.\"\"\"\n        embedding = [\n            [float(1.0)] * (OS_TOKEN_COUNT - 1) + [100 * float(i + 1)]\n            for i in range(len(embedding_texts))\n        ]\n        return embedding\n\n    def embed_query(self, text: str) -> List[float]:\n        \"\"\"Return simple embeddings.\"\"\"\n        embedding = [float(1.0)] * (OS_TOKEN_COUNT - 1) + [\n            100 * float(texts.index(text) + 1)\n        ]\n        return embedding","inst_variables":[],"reason_kor":"고정된 OS 토큰 차원과 스케일된 값을 사용하는 테스트용 임베딩 클래스 변형.","reason":"Fake embedding class variant using a fixed OS token count dimension and scaled values for embeddings, for testing purposes."},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_drop_vector_indexes","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_drop_vector_indexes","_rev":"_jzRpLIS---","type":"function","name":"drop_vector_indexes","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":38,"source":"def drop_vector_indexes(store: Neo4jVector) -> None:\n    \"\"\"Cleanup all vector indexes\"\"\"\n    all_indexes = store.query(\n        \"\"\"\n            SHOW INDEXES YIELD name, type\n            WHERE type IN [\"VECTOR\", \"FULLTEXT\"]\n            RETURN name\n                              \"\"\"\n    )\n    for index in all_indexes:\n        store.query(f\"DROP INDEX `{index['name']}`\")\n\n    store.query(\"MATCH (n) DETACH DELETE n;\")","docstring":"Cleanup all vector indexes","args":[{"arg":"store","type":"Neo4jVector"}],"return_type":"None","control_flow":[{"type":"for","lineno":47}],"reason_kor":"Neo4jVector 스토어에서 모든 벡터 및 전체 텍스트 인덱스를 삭제하고 모든 노드를 제거하는 정리용 함수.","reason":"Utility function to drop all vector and fulltext indexes and delete all nodes in a Neo4jVector store for cleanup."},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_embed_documents","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_embed_documents","_rev":"_jzRpLIe---","type":"function","name":"embed_documents","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":56,"source":"def embed_documents(self, embedding_texts: List[str]) -> List[List[float]]:\n        \"\"\"Return simple embeddings.\"\"\"\n        embedding = [\n            [float(1.0)] * (OS_TOKEN_COUNT - 1) + [100 * float(i + 1)]\n            for i in range(len(embedding_texts))\n        ]\n        return embedding","docstring":"Return simple embeddings.","args":[{"arg":"self","type":null},{"arg":"embedding_texts","type":"List[str]"}],"return_type":"List[List[float]]","control_flow":[],"reason_kor":"OS_TOKEN_COUNT-1 만큼 1.0을 채우고, 마지막 원소를 인덱스에 따른 스케일 값(100 × 인덱스 + 1)으로 설정한 부동소수점 리스트를 생성하는 리스트 컴프리헨션을 결합합니다.","reason":"It is about a list comprehension to generate a list of embeddings, where each embedding is a list of floats consisting of OS_TOKEN_COUNT - 1 times the value 1.0, followed by a scaled value (100 times the index + 1)."},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_embed_query","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_embed_query","_rev":"_jzRpLIq---","type":"function","name":"embed_query","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":64,"source":"def embed_query(self, text: str) -> List[float]:\n        \"\"\"Return simple embeddings.\"\"\"\n        embedding = [float(1.0)] * (OS_TOKEN_COUNT - 1) + [\n            100 * float(texts.index(text) + 1)\n        ]\n        return embedding","docstring":"Return simple embeddings.","args":[{"arg":"self","type":null},{"arg":"text","type":"str"}],"return_type":"List[float]","control_flow":[],"reason_kor":"1.0로 채워진 부동소수점 리스트이며, 마지막 원소는 'texts' 내 입력 텍스트의 인덱스를 스케일링한 값으로, 텍스트 위치 기반의 간단한 임베딩을 생성합니다.","reason":"it is about a list of floating-point values filled with 1.0s, with the last element being a scaled index of the input text within the 'texts' list, effectively creating a simple embedding based on text position."},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_test_custom_return_neo4jvector","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_test_custom_return_neo4jvector","_rev":"_jzRpLI2---","type":"function","name":"test_custom_return_neo4jvector","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":264,"source":"def test_custom_return_neo4jvector(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test end to end construction and search.\"\"\"\n    docsearch = Neo4jVector.from_texts(\n        texts=[\"test\"],\n        embedding=FakeEmbeddingsWithOsDimension(),\n        pre_delete_collection=True,\n        retrieval_query=\"RETURN 'foo' AS text, score, {test: 'test'} AS metadata\",\n        **neo4j_credentials,\n    )\n    output = docsearch.similarity_search(\"foo\", k=1)\n    assert output == [Document(page_content=\"foo\", metadata={\"test\": \"test\"})]\n\n    drop_vector_indexes(docsearch)","docstring":"Test end to end construction and search.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason_kor":"클래스 메서드로부터 객체를 생성하고, 유사도 검색을 수행하여 기대 결과를 단언한 후, 벡터 인덱스를 삭제하는 정리 함수를 호출합니다.","reason":"it is about object instantiation from a class method with parameters, calling a method to perform a similarity search, asserting the expected result, and finally invoking a cleanup function to drop vector indexes."},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_test_hybrid_score_normalization","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_test_hybrid_score_normalization","_rev":"_jzRpLJC---","type":"function","name":"test_hybrid_score_normalization","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":649,"source":"def test_hybrid_score_normalization(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test if we can get two 1.0 documents with RRF\"\"\"\n    text_embeddings = FakeEmbeddingsWithOsDimension().embed_documents(texts)\n    text_embedding_pairs = list(zip([\"foo\"], text_embeddings))\n    docsearch = Neo4jVector.from_embeddings(\n        text_embeddings=text_embedding_pairs,\n        embedding=FakeEmbeddingsWithOsDimension(),\n        pre_delete_collection=True,\n        search_type=SearchType.HYBRID,\n        **neo4j_credentials,\n    )\n    # Remove deduplication part of the query\n    rrf_query = (\n        _get_hybrid_query(neo4j_version_is_5_23_or_above=False)\n        .rstrip(\"WITH node, max(score) AS score ORDER BY score DESC LIMIT $top_k\")\n        .replace(\"UNION\", \"UNION ALL\")\n        + \"RETURN node.text AS text, score LIMIT 2\"\n    )\n\n    output = docsearch.query(\n        rrf_query,\n        params={\n            \"vector_index_name\": \"vector\",\n            \"top_k\": 1,\n            \"query_vector\": FakeEmbeddingsWithOsDimension().embed_query(\"foo\"),\n            \"effective_search_ratio\": 1,\n            \"query_text\": \"foo\",\n            \"fulltext_index_name\": \"keyword\",\n        },\n    )\n    # Both FT and Vector must return 1.0 score\n    assert output == [{\"text\": \"foo\", \"score\": 1.0}, {\"text\": \"foo\", \"score\": 1.0}]\n    drop_vector_indexes(docsearch)","docstring":"Test if we can get two 1.0 documents with RRF","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason_kor":"텍스트 임베딩을 생성하고 문자열 라벨과 쌍으로 만든 후, 하이브리드 검색 타입으로 Neo4j 벡터 검색을 초기화, 중복 제거 제거 및 점수 강제 적용을 위해 쿼리를 수정하고, 최상위 결과를 조회하여 전체 텍스트 검색과 벡터 검색이 동일한 최대 점수를 반환하는지 검증합니다.","reason":"it is about the creation of text embeddings and their pairing with a string label, then initialized a Neo4j vector search using hybrid search type, modified the query to remove deduplication and enforce scoring, and finally queried for top results ensuring that both full-text and vector searches return identical maximum scores for the same document."},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_test_index_fetching","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_test_index_fetching","_rev":"_jzRpLJO---","type":"function","name":"test_index_fetching","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":685,"source":"def test_index_fetching(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"testing correct index creation and fetching\"\"\"\n    embeddings = FakeEmbeddings()\n\n    def create_store(\n        node_label: str, index: str, text_properties: List[str]\n    ) -> Neo4jVector:\n        return Neo4jVector.from_existing_graph(\n            embedding=embeddings,\n            index_name=index,\n            node_label=node_label,\n            text_node_properties=text_properties,\n            embedding_node_property=\"embedding\",\n            **neo4j_credentials,\n        )\n\n    def fetch_store(index_name: str) -> Neo4jVector:\n        store = Neo4jVector.from_existing_index(\n            embedding=embeddings,\n            index_name=index_name,\n            **neo4j_credentials,\n        )\n        return store\n\n    # create index 0\n    index_0_str = \"index0\"\n    create_store(\"label0\", index_0_str, [\"text\"])\n\n    # create index 1\n    index_1_str = \"index1\"\n    create_store(\"label1\", index_1_str, [\"text\"])\n\n    index_1_store = fetch_store(index_1_str)\n    assert index_1_store.index_name == index_1_str\n\n    index_0_store = fetch_store(index_0_str)\n    assert index_0_store.index_name == index_0_str\n    drop_vector_indexes(index_1_store)\n    drop_vector_indexes(index_0_store)","docstring":"testing correct index creation and fetching","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason_kor":"특정 라벨과 속성을 가진 벡터 스토어 생성 및 조회용 헬퍼 함수 정의, 여러 인덱스 생성 및 검증, 이후 인덱스 삭제로 정리합니다.","reason":"it is about defining helper functions to create and fetch vector stores with specified labels and properties, then used these functions to create multiple indexes, verified their correctness by assertions, and finally dropped the created indexes to clean up."},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_test_metadata_filters_type1","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_test_metadata_filters_type1","_rev":"_jzRpLJW---","type":"function","name":"test_metadata_filters_type1","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":787,"source":"def test_metadata_filters_type1(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test metadata filters\"\"\"\n    docsearch = Neo4jVector.from_documents(\n        DOCUMENTS,\n        embedding=FakeEmbeddings(),\n        pre_delete_collection=True,\n        **neo4j_credentials,\n    )\n    # We don't test type 5, because LIKE has very SQL specific examples\n    for example in (\n        TYPE_1_FILTERING_TEST_CASES\n        + TYPE_2_FILTERING_TEST_CASES\n        + TYPE_3_FILTERING_TEST_CASES\n        + TYPE_4_FILTERING_TEST_CASES\n    ):\n        filter_dict = cast(Dict[str, Any], example[0])\n        output = docsearch.similarity_search(\"Foo\", filter=filter_dict)\n        indices = cast(List[int], example[1])\n        adjusted_indices = [index - 1 for index in indices]\n        expected_output = [DOCUMENTS[index] for index in adjusted_indices]\n        # We don't return id properties from similarity search by default\n        # Also remove any key where the value is None\n        for doc in expected_output:\n            if \"id\" in doc.metadata:\n                del doc.metadata[\"id\"]\n            keys_with_none = [\n                key for key, value in doc.metadata.items() if value is None\n            ]\n            for key in keys_with_none:\n                del doc.metadata[key]\n\n        assert output == expected_output\n    drop_vector_indexes(docsearch)","docstring":"Test metadata filters","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[{"type":"for","lineno":796},{"type":"for","lineno":809},{"type":"if","lineno":810},{"type":"for","lineno":815}],"reason_kor":"특정 자격 증명으로 문서 검색 객체를 생성하고, 여러 테스트 케이스를 순회하며 다양한 필터 조건에 따른 유사도 검색 결과를 검증, 예상 문서 처리 및 특정 메타데이터 키 제거, 검색 출력이 기대 결과와 일치함을 단언한 후 인덱스를 정리합니다.","reason":"it is about creating a document search object with specific credentials, then iterated over multiple test cases to verify similarity search results based on different filter criteria, processed expected documents by adjusting indices and removing specific metadata keys, and finally asserted that the search output matched expectations, followed by cleaning up indexes."},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4j_max_marginal_relevance_search","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4j_max_marginal_relevance_search","_rev":"_jzRpLJi---","type":"function","name":"test_neo4j_max_marginal_relevance_search","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":916,"source":"def test_neo4j_max_marginal_relevance_search(\n    neo4j_credentials: Neo4jCredentials,\n) -> None:\n    \"\"\"\n    Test end to end construction and MMR search.\n    The embedding function used here ensures `texts` become\n    the following vectors on a circle (numbered v0 through v3):\n\n           ______ v2\n          /      \\\n         /        |  v1\n    v3  |     .    | query\n         |        /  v0\n          |______/                 (N.B. very crude drawing)\n\n    With fetch_k==3 and k==2, when query is at (1, ),\n    one expects that v2 and v0 are returned (in some order).\n    \"\"\"\n    texts = [\"-0.124\", \"+0.127\", \"+0.25\", \"+1.0\"]\n    metadatas = [{\"page\": i} for i in range(len(texts))]\n    docsearch = Neo4jVector.from_texts(\n        texts,\n        metadatas=metadatas,\n        embedding=AngularTwoDimensionalEmbeddings(),\n        pre_delete_collection=True,\n        **neo4j_credentials,\n    )\n\n    expected_set = {\n        (\"+0.25\", 2),\n        (\"-0.124\", 0),\n    }\n\n    output = docsearch.max_marginal_relevance_search(\"0.0\", k=2, fetch_k=3)\n    output_set = {\n        (mmr_doc.page_content, mmr_doc.metadata[\"page\"]) for mmr_doc in output\n    }\n    assert output_set == expected_set\n\n    drop_vector_indexes(docsearch)","docstring":"Test end to end construction and MMR search.\nThe embedding function used here ensures `texts` become\nthe following vectors on a circle (numbered v0 through v3):\n\n       ______ v2\n      /               /        |  v1\nv3  |     .    | query\n     |        /  v0\n      |______/                 (N.B. very crude drawing)\n\nWith fetch_k==3 and k==2, when query is at (1, ),\none expects that v2 and v0 are returned (in some order).","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason_kor":"특정 텍스트 임베딩으로 시뮬레이션된 2D 벡터 공간을 설정하고 Max Marginal Relevance (MMR) 검색 기능을 테스트, 사전 정의된 임베딩으로 Neo4j 벡터 인덱스를 구성, 지정된 파라미터로 MMR 검색을 수행하며 반환된 집합이 시뮬레이션 위치에 따른 기대 문서와 일치하는지 검증합니다.","reason":"it is about the setup of a simulated 2D vector space with specific text embeddings to test the Max Marginal Relevance (MMR) search function. It constructs a Neo4j vector index with predefined embeddings, performs an MMR search with specified parameters, and verifies that the returned set matches the expected documents based on their simulated positions."},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector","_rev":"_jzRpLJu---","type":"function","name":"test_neo4jvector","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":73,"source":"def test_neo4jvector() -> None:\n    \"\"\"Test end to end construction and search with environment variable credentials.\"\"\"\n    assert os.environ.get(\"NEO4J_URI\") is not None\n    assert os.environ.get(\"NEO4J_USERNAME\") is not None\n    assert os.environ.get(\"NEO4J_PASSWORD\") is not None\n    docsearch = Neo4jVector.from_texts(\n        texts=texts,\n        embedding=FakeEmbeddingsWithOsDimension(),\n        pre_delete_collection=True,\n    )\n    output = docsearch.similarity_search(\"foo\", k=1)\n    assert output == [Document(page_content=\"foo\")]\n\n    drop_vector_indexes(docsearch)","docstring":"Test end to end construction and search with environment variable credentials.","args":[],"return_type":"None","control_flow":[],"reason_kor":"데이터베이스 자격 증명에 대한 환경 변수 확인, 텍스트와 가짜 임베딩으로 벡터 검색 객체 초기화, 쿼리에 대한 유사도 검색 수행 및 결과가 기대치와 일치하는지 검증 후 인덱스 정리합니다.","reason":"it is about environment variable checks for database credentials, initializes a vector search object with texts and fake embeddings, performs a similarity search for a query, and then verifies the output matches expected results before cleaning up indexes."},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_catch_wrong_index_name","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_catch_wrong_index_name","_rev":"_jzRpLJ6---","type":"function","name":"test_neo4jvector_catch_wrong_index_name","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":123,"source":"def test_neo4jvector_catch_wrong_index_name(\n    neo4j_credentials: Neo4jCredentials,\n) -> None:\n    \"\"\"Test if index name is misspelled, but node label and property are correct.\"\"\"\n    text_embeddings = FakeEmbeddingsWithOsDimension().embed_documents(texts)\n    text_embedding_pairs = list(zip(texts, text_embeddings))\n    Neo4jVector.from_embeddings(\n        text_embeddings=text_embedding_pairs,\n        embedding=FakeEmbeddingsWithOsDimension(),\n        pre_delete_collection=True,\n        **neo4j_credentials,\n    )\n    existing = Neo4jVector.from_existing_index(\n        embedding=FakeEmbeddingsWithOsDimension(),\n        index_name=\"test\",\n        **neo4j_credentials,\n    )\n    output = existing.similarity_search(\"foo\", k=1)\n    assert output == [Document(page_content=\"foo\")]\n\n    drop_vector_indexes(existing)","docstring":"Test if index name is misspelled, but node label and property are correct.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason_kor":"잘못된 인덱스 이름 사용 시 Neo4j 벡터 연산 테스트 함수로, 임베딩 생성 및 삽입 후 오타가 있을 수 있는 인덱스를 사용해 검색을 시도하고, 기대 결과를 단언합니다.","reason":"it is about a test function for Neo4j vector operations that verifies behavior when an incorrect index name is used, by creating embeddings, inserting them into Neo4j, attempting to search with a possibly misspelled index, and asserting the expected result."},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_catch_wrong_node_label","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_catch_wrong_node_label","_rev":"_jzRpLKG---","type":"function","name":"test_neo4jvector_catch_wrong_node_label","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":147,"source":"def test_neo4jvector_catch_wrong_node_label(\n    neo4j_credentials: Neo4jCredentials,\n) -> None:\n    \"\"\"Test if node label is misspelled, but index name is correct.\"\"\"\n    text_embeddings = FakeEmbeddingsWithOsDimension().embed_documents(texts)\n    text_embedding_pairs = list(zip(texts, text_embeddings))\n    Neo4jVector.from_embeddings(\n        text_embeddings=text_embedding_pairs,\n        embedding=FakeEmbeddingsWithOsDimension(),\n        pre_delete_collection=True,\n        **neo4j_credentials,\n    )\n    existing = Neo4jVector.from_existing_index(\n        embedding=FakeEmbeddingsWithOsDimension(),\n        index_name=\"vector\",\n        node_label=\"test\",\n        **neo4j_credentials,\n    )\n    output = existing.similarity_search(\"foo\", k=1)\n    assert output == [Document(page_content=\"foo\")]\n\n    drop_vector_indexes(existing)","docstring":"Test if node label is misspelled, but index name is correct.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason_kor":"가짜 텍스트 임베딩 설정, 특정 자격 증명으로 Neo4j 벡터 생성, 주어진 노드 라벨로 유사도 검색 기능 점검 후 인덱스 정리합니다.","reason":"it is about setting up fake text embeddings, creating Neo4j vectors with specific credentials, checking similarity search functionality with a given node label, and finally dropping the indexes to clean up."},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_effective_search_ratio","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_effective_search_ratio","_rev":"_jzRpLKO---","type":"function","name":"test_neo4jvector_effective_search_ratio","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":959,"source":"def test_neo4jvector_effective_search_ratio(\n    neo4j_credentials: Neo4jCredentials,\n) -> None:\n    \"\"\"Test effective search parameter.\"\"\"\n    docsearch = Neo4jVector.from_texts(\n        texts=texts,\n        embedding=FakeEmbeddingsWithOsDimension(),\n        pre_delete_collection=True,\n        **neo4j_credentials,\n    )\n    output = docsearch.similarity_search(\"foo\", k=2, effective_search_ratio=2)\n    assert len(output) == 2\n\n    output1 = docsearch.similarity_search_with_score(\n        \"foo\", k=2, effective_search_ratio=2\n    )\n    assert len(output1) == 2\n    # Assert ordered by score\n    assert output1[0][1] > output1[1][1]\n    drop_vector_indexes(docsearch)","docstring":"Test effective search parameter.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason_kor":"여러 유사도 검색 방법을 가진 Neo4j 벡터 검색 객체 생성, 'k'와 'effective_search_ratio' 등 파라미터를 활용해 검색을 수행하고 결과 검증, 이후 리소스 정리합니다.","reason":"it is about the creation of a Neo4j vector search object with multiple similarity search methods, utilizing parameters like 'k' and 'effective_search_ratio' to perform and validate search results, including score-based ordering, then cleans up resources."},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_embeddings","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_embeddings","_rev":"_jzRpLKa---","type":"function","name":"test_neo4jvector_embeddings","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":106,"source":"def test_neo4jvector_embeddings(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test end to end construction with embeddings and search.\"\"\"\n    text_embeddings = FakeEmbeddingsWithOsDimension().embed_documents(texts)\n    text_embedding_pairs = list(zip(texts, text_embeddings))\n    docsearch = Neo4jVector.from_embeddings(\n        text_embeddings=text_embedding_pairs,\n        embedding=FakeEmbeddingsWithOsDimension(),\n        pre_delete_collection=True,\n        **neo4j_credentials,\n    )\n    output = docsearch.similarity_search(\"foo\", k=1)\n    assert output == [Document(page_content=\"foo\")]\n\n    drop_vector_indexes(docsearch)","docstring":"Test end to end construction with embeddings and search.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason_kor":"Neo4j 데이터베이스에 임베딩 생성 및 삽입, 유사도 검색 수행으로 검색 기능 검증, 마지막으로 벡터 인덱스 삭제로 정리합니다.","reason":"it is about embedding generation with Neo4j database insertion, then performed a similarity search to validate the search functionality, and finally dropped vector indexes to clean up."},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_euclidean","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_euclidean","_rev":"_jzRpLKm---","type":"function","name":"test_neo4jvector_euclidean","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":90,"source":"def test_neo4jvector_euclidean(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test euclidean distance\"\"\"\n    docsearch = Neo4jVector.from_texts(\n        texts=texts,\n        embedding=FakeEmbeddingsWithOsDimension(),\n        pre_delete_collection=True,\n        distance_strategy=DistanceStrategy.EUCLIDEAN_DISTANCE,\n        **neo4j_credentials,\n    )\n    output = docsearch.similarity_search(\"foo\", k=1)\n    assert output == [Document(page_content=\"foo\")]\n\n    drop_vector_indexes(docsearch)","docstring":"Test euclidean distance","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason_kor":"Euclidean 거리 전략으로 Neo4j 벡터 검색 인스턴스를 생성, 'foo' 입력으로 유사도 검색 수행, 출력 확인 및 인덱스 삭제","reason":"it is about the creation of a vector search instance with specified Euclidean distance strategy using Neo4j credentials, performed a similarity search with input 'foo', checked the output, and then dropped the vector indexes"},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_from_existing_graph","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_from_existing_graph","_rev":"_jzRpLKy---","type":"function","name":"test_neo4jvector_from_existing_graph","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":487,"source":"def test_neo4jvector_from_existing_graph(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test from_existing_graph with a single property.\"\"\"\n    graph = Neo4jVector.from_texts(\n        texts=[\"test\"],\n        embedding=FakeEmbeddingsWithOsDimension(),\n        index_name=\"foo\",\n        node_label=\"Foo\",\n        embedding_node_property=\"vector\",\n        text_node_property=\"info\",\n        pre_delete_collection=True,\n        **neo4j_credentials,\n    )\n\n    graph.query(\"MATCH (n) DETACH DELETE n\")\n\n    graph.query(\"CREATE (:Test {name:'Foo'}),\" \"(:Test {name:'Bar'})\")\n\n    existing = Neo4jVector.from_existing_graph(\n        embedding=FakeEmbeddingsWithOsDimension(),\n        index_name=\"vector\",\n        node_label=\"Test\",\n        text_node_properties=[\"name\"],\n        embedding_node_property=\"embedding\",\n        **neo4j_credentials,\n    )\n\n    output = existing.similarity_search(\"foo\", k=1)\n    assert output == [Document(page_content=\"\\nname: Foo\")]\n\n    drop_vector_indexes(existing)","docstring":"Test from_existing_graph with a single property.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason_kor":"텍스트 임베딩과 함께 Neo4j 그래프 생성, 그래프에서 유사도 검색 쿼리 실행, 이후 인덱스 정리 과정을 포함해 기존 그래프 데이터를 활용한 Neo4j 내 벡터 유사도 검색을 시연합니다.","reason":"it is about the creation of a Neo4j graph with text embeddings, querying the graph for similarity search, and then cleaning up indexes, demonstrating how to use existing graph data for vector similarity search in Neo4j."},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_from_existing_graph_hybrid","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_from_existing_graph_hybrid","_rev":"_jzRpLL----","type":"function","name":"test_neo4jvector_from_existing_graph_hybrid","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":520,"source":"def test_neo4jvector_from_existing_graph_hybrid(\n    neo4j_credentials: Neo4jCredentials,\n) -> None:\n    \"\"\"Test from_existing_graph hybrid with a single property.\"\"\"\n    graph = Neo4jVector.from_texts(\n        texts=[\"test\"],\n        embedding=FakeEmbeddingsWithOsDimension(),\n        index_name=\"foo\",\n        node_label=\"Foo\",\n        embedding_node_property=\"vector\",\n        text_node_property=\"info\",\n        pre_delete_collection=True,\n        **neo4j_credentials,\n    )\n\n    graph.query(\"MATCH (n) DETACH DELETE n\")\n\n    graph.query(\"CREATE (:Test {name:'foo'}),\" \"(:Test {name:'Bar'})\")\n\n    existing = Neo4jVector.from_existing_graph(\n        embedding=FakeEmbeddingsWithOsDimension(),\n        index_name=\"vector\",\n        node_label=\"Test\",\n        text_node_properties=[\"name\"],\n        embedding_node_property=\"embedding\",\n        search_type=SearchType.HYBRID,\n        **neo4j_credentials,\n    )\n\n    output = existing.similarity_search(\"foo\", k=1)\n    assert output == [Document(page_content=\"\\nname: foo\")]\n\n    drop_vector_indexes(existing)","docstring":"Test from_existing_graph hybrid with a single property.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason_kor":"텍스트 데이터로 그래프를 생성하고 기존 노드를 삭제한 후 새 노드를 생성, 지정된 속성과 검색 유형으로 기존 그래프에서 하이브리드 유사도 검색을 수행합니다.","reason":"it is about creating a graph with textual data, deleting existing nodes, creating new nodes, and then performing a hybrid similarity search on an existing graph using specified properties and search type."},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_from_existing_graph_multiple_properties","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_from_existing_graph_multiple_properties","_rev":"_jzRpLLK---","type":"function","name":"test_neo4jvector_from_existing_graph_multiple_properties","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":556,"source":"def test_neo4jvector_from_existing_graph_multiple_properties(\n    neo4j_credentials: Neo4jCredentials,\n) -> None:\n    \"\"\"Test from_existing_graph with a two property.\"\"\"\n    graph = Neo4jVector.from_texts(\n        texts=[\"test\"],\n        embedding=FakeEmbeddingsWithOsDimension(),\n        index_name=\"foo\",\n        node_label=\"Foo\",\n        embedding_node_property=\"vector\",\n        text_node_property=\"info\",\n        pre_delete_collection=True,\n        **neo4j_credentials,\n    )\n    graph.query(\"MATCH (n) DETACH DELETE n\")\n\n    graph.query(\"CREATE (:Test {name:'Foo', name2: 'Fooz'}),\" \"(:Test {name:'Bar'})\")\n\n    existing = Neo4jVector.from_existing_graph(\n        embedding=FakeEmbeddingsWithOsDimension(),\n        index_name=\"vector\",\n        node_label=\"Test\",\n        text_node_properties=[\"name\", \"name2\"],\n        embedding_node_property=\"embedding\",\n        **neo4j_credentials,\n    )\n\n    output = existing.similarity_search(\"foo\", k=1)\n    assert output == [Document(page_content=\"\\nname: Foo\\nname2: Fooz\")]\n\n    drop_vector_indexes(existing)","docstring":"Test from_existing_graph with a two property.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason_kor":"Neo4j로 텍스트 임베딩과 노드 속성을 가진 그래프를 생성하고, 여러 노드 속성 기반 유사도 검색 쿼리를 수행하며, 다중 속성 노드를 갖는 벡터 기반 그래프 데이터베이스의 초기화, 데이터 채우기, 쿼리 및 정리 과정을 시연합니다.","reason":"it is about the creation of a graph with text embeddings and node properties using Neo4j, then queried for similarity based on multiple node properties, demonstrating the process of initializing, populating, querying, and cleaning up a vector-based graph database with multi-property nodes."},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_from_existing_graph_multiple_properties_hybrid","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_from_existing_graph_multiple_properties_hybrid","_rev":"_jzRpLLW---","type":"function","name":"test_neo4jvector_from_existing_graph_multiple_properties_hybrid","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":590,"source":"def test_neo4jvector_from_existing_graph_multiple_properties_hybrid(\n    neo4j_credentials: Neo4jCredentials,\n) -> None:\n    \"\"\"Test from_existing_graph with a two property.\"\"\"\n    graph = Neo4jVector.from_texts(\n        texts=[\"test\"],\n        embedding=FakeEmbeddingsWithOsDimension(),\n        index_name=\"foo\",\n        node_label=\"Foo\",\n        embedding_node_property=\"vector\",\n        text_node_property=\"info\",\n        pre_delete_collection=True,\n        **neo4j_credentials,\n    )\n    graph.query(\"MATCH (n) DETACH DELETE n\")\n\n    graph.query(\"CREATE (:Test {name:'Foo', name2: 'Fooz'}),\" \"(:Test {name:'Bar'})\")\n\n    existing = Neo4jVector.from_existing_graph(\n        embedding=FakeEmbeddingsWithOsDimension(),\n        index_name=\"vector\",\n        node_label=\"Test\",\n        text_node_properties=[\"name\", \"name2\"],\n        embedding_node_property=\"embedding\",\n        search_type=SearchType.HYBRID,\n        **neo4j_credentials,\n    )\n\n    output = existing.similarity_search(\"foo\", k=1)\n    assert output == [Document(page_content=\"\\nname: Foo\\nname2: Fooz\")]\n\n    drop_vector_indexes(existing)","docstring":"Test from_existing_graph with a two property.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason_kor":"텍스트 데이터로 그래프를 생성한 후, 여러 속성을 사용한 하이브리드 검색 방식을 이용해 기존 그래프를 쿼리하고 유사도 검색 결과를 검증합니다.","reason":"it is about creating a graph with text data, then querying an existing graph with multiple properties using a hybrid search approach, and verifying the similarity search results"},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_hybrid","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_hybrid","_rev":"_jzRpLLe---","type":"function","name":"test_neo4jvector_hybrid","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":353,"source":"def test_neo4jvector_hybrid(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test end to end construction with hybrid search.\"\"\"\n    text_embeddings = FakeEmbeddingsWithOsDimension().embed_documents(texts)\n    text_embedding_pairs = list(zip(texts, text_embeddings))\n    docsearch = Neo4jVector.from_embeddings(\n        text_embeddings=text_embedding_pairs,\n        embedding=FakeEmbeddingsWithOsDimension(),\n        pre_delete_collection=True,\n        search_type=SearchType.HYBRID,\n        **neo4j_credentials,\n    )\n    output = docsearch.similarity_search(\"foo\", k=1)\n    assert output == [Document(page_content=\"foo\")]\n\n    drop_vector_indexes(docsearch)","docstring":"Test end to end construction with hybrid search.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason_kor":"하이브리드 검색 타입으로 Neo4j 벡터 검색 설정, 문서 임베딩, 벡터 인덱스 생성, 유사도 검색 수행, 인덱스 정리를 수행합니다.","reason":"it is about setting up a neo4j vector search with hybrid search type, embedding documents, creating a vector index, performing a similarity search, and then cleaning up indexes."},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_hybrid_deduplicate","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_hybrid_deduplicate","_rev":"_jzRpLLu---","type":"function","name":"test_neo4jvector_hybrid_deduplicate","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":371,"source":"def test_neo4jvector_hybrid_deduplicate(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test result deduplication with hybrid search.\"\"\"\n    text_embeddings = FakeEmbeddingsWithOsDimension().embed_documents(texts)\n    text_embedding_pairs = list(zip(texts, text_embeddings))\n    docsearch = Neo4jVector.from_embeddings(\n        text_embeddings=text_embedding_pairs,\n        embedding=FakeEmbeddingsWithOsDimension(),\n        pre_delete_collection=True,\n        search_type=SearchType.HYBRID,\n        **neo4j_credentials,\n    )\n    output = docsearch.similarity_search(\"foo\", k=3)\n\n    assert output == [\n        Document(page_content=\"foo\"),\n        Document(page_content=\"It is the end of the world. Take shelter!\"),\n        Document(page_content=\"baz\"),\n    ]\n\n    drop_vector_indexes(docsearch)","docstring":"Test result deduplication with hybrid search.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason_kor":"내장 문서 데이터가 포함된 Neo4j 벡터 데이터베이스를 설정하고, 하이브리드 검색 수행, 중복 제거를 보장하며 유사도 검색 결과를 검증합니다.","reason":"it is about setting up a Neo4j vector database with embedded document data, performing a hybrid search, and verifying the similarity search results to ensure deduplication."},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_hybrid_from_existing","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_hybrid_from_existing","_rev":"_jzRpLL2---","type":"function","name":"test_neo4jvector_hybrid_from_existing","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":461,"source":"def test_neo4jvector_hybrid_from_existing(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test hybrid search with missing keyword_index_search.\"\"\"\n    text_embeddings = FakeEmbeddingsWithOsDimension().embed_documents(texts)\n    text_embedding_pairs = list(zip(texts, text_embeddings))\n    Neo4jVector.from_embeddings(\n        text_embeddings=text_embedding_pairs,\n        embedding=FakeEmbeddingsWithOsDimension(),\n        pre_delete_collection=True,\n        search_type=SearchType.HYBRID,\n        **neo4j_credentials,\n    )\n    existing = Neo4jVector.from_existing_index(\n        embedding=FakeEmbeddingsWithOsDimension(),\n        index_name=\"vector\",\n        keyword_index_name=\"keyword\",\n        search_type=SearchType.HYBRID,\n        **neo4j_credentials,\n    )\n\n    output = existing.similarity_search(\"foo\", k=1)\n    assert output == [Document(page_content=\"foo\")]\n\n    drop_vector_indexes(existing)","docstring":"Test hybrid search with missing keyword_index_search.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason_kor":"특정 가짜 임베딩 클래스로 텍스트 임베딩 생성, 이 임베딩으로 Neo4j 벡터 인덱스(하이브리드 검색 타입) 채우기, 키워드 인덱스 누락 처리, 유사도 검색 수행 및 인덱스 정리","reason":"it is about the creation of text embeddings with a specific fake embedding class, then used these embeddings to populate a Neo4j vector index with a hybrid search type, including handling of missing keyword index, then performed a similarity search, and finally cleaned up the index."},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_hybrid_retrieval_query","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_hybrid_retrieval_query","_rev":"_jzRpLMG---","type":"function","name":"test_neo4jvector_hybrid_retrieval_query","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":394,"source":"def test_neo4jvector_hybrid_retrieval_query(\n    neo4j_credentials: Neo4jCredentials,\n) -> None:\n    \"\"\"Test custom retrieval_query with hybrid search.\"\"\"\n    text_embeddings = FakeEmbeddingsWithOsDimension().embed_documents(texts)\n    text_embedding_pairs = list(zip(texts, text_embeddings))\n    docsearch = Neo4jVector.from_embeddings(\n        text_embeddings=text_embedding_pairs,\n        embedding=FakeEmbeddingsWithOsDimension(),\n        pre_delete_collection=True,\n        search_type=SearchType.HYBRID,\n        retrieval_query=\"RETURN 'moo' AS text, score, {test: 'test'} AS metadata\",\n        **neo4j_credentials,\n    )\n    output = docsearch.similarity_search(\"foo\", k=1)\n    assert output == [Document(page_content=\"moo\", metadata={\"test\": \"test\"})]\n\n    drop_vector_indexes(docsearch)","docstring":"Test custom retrieval_query with hybrid search.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason_kor":"가짜 임베딩 클래스로 임베딩 생성 후 Neo4jVector의 from_embeddings 메서드를 사용해 하이브리드 검색 수행, 사용자 정의 검색 쿼리 이용, 검색 결과가 예상과 일치하는지 검증 후 인덱스 정리","reason":"it is about creating embeddings with a fake embedding class, then used these embeddings with Neo4jVector's from_embeddings method to perform a hybrid search using a custom retrieval query, and finally verified the search result matches the expected output before cleaning up the indexes."},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_hybrid_retrieval_query2","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_hybrid_retrieval_query2","_rev":"_jzRpLMS---","type":"function","name":"test_neo4jvector_hybrid_retrieval_query2","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":415,"source":"def test_neo4jvector_hybrid_retrieval_query2(\n    neo4j_credentials: Neo4jCredentials,\n) -> None:\n    \"\"\"Test custom retrieval_query with hybrid search.\"\"\"\n    text_embeddings = FakeEmbeddingsWithOsDimension().embed_documents(texts)\n    text_embedding_pairs = list(zip(texts, text_embeddings))\n    docsearch = Neo4jVector.from_embeddings(\n        text_embeddings=text_embedding_pairs,\n        embedding=FakeEmbeddingsWithOsDimension(),\n        pre_delete_collection=True,\n        search_type=SearchType.HYBRID,\n        retrieval_query=\"RETURN node.text AS text, score, {test: 'test'} AS metadata\",\n        **neo4j_credentials,\n    )\n    output = docsearch.similarity_search(\"foo\", k=1)\n    assert output == [Document(page_content=\"foo\", metadata={\"test\": \"test\"})]\n\n    drop_vector_indexes(docsearch)","docstring":"Test custom retrieval_query with hybrid search.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason":"it is about embedding generation, neo4j vector index creation with hybrid search type, custom retrieval query, similarity search, and cleanup of indexes","reason_kor":"임베딩 생성, Neo4j 벡터 인덱스 생성(하이브리드 검색 타입), 사용자 정의 검색 쿼리, 유사도 검색, 인덱스 정리를 결합합니다."},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_missing_keyword","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_missing_keyword","_rev":"_jzRpLMe---","type":"function","name":"test_neo4jvector_missing_keyword","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":436,"source":"def test_neo4jvector_missing_keyword(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test hybrid search with missing keyword_index_search.\"\"\"\n    text_embeddings = FakeEmbeddingsWithOsDimension().embed_documents(texts)\n    text_embedding_pairs = list(zip(texts, text_embeddings))\n    docsearch = Neo4jVector.from_embeddings(\n        text_embeddings=text_embedding_pairs,\n        embedding=FakeEmbeddingsWithOsDimension(),\n        pre_delete_collection=True,\n        **neo4j_credentials,\n    )\n    try:\n        Neo4jVector.from_existing_index(\n            embedding=FakeEmbeddingsWithOsDimension(),\n            index_name=\"vector\",\n            search_type=SearchType.HYBRID,\n            **neo4j_credentials,\n        )\n    except ValueError as e:\n        assert str(e) == (\n            \"keyword_index name has to be specified when \" \"using hybrid search option\"\n        )\n    drop_vector_indexes(docsearch)","docstring":"Test hybrid search with missing keyword_index_search.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[{"type":"try","lineno":446}],"reason_kor":"키워드 누락 상태에서 Neo4j 벡터 인덱싱 동작을 테스트하는 함수 정의, 임베딩 문서 생성, Neo4j 벡터 저장소 초기화, 하이브리드 검색으로 기존 인덱스 로드 시 키워드 누락으로 ValueError 발생 확인, 벡터 인덱스 삭제로 정리합니다.","reason":"it is about function definition for testing Neo4j vector indexing behavior with missing keyword, embedding document creation, Neo4j vector storage initialization with credentials, attempt to load existing index with hybrid search which triggers a ValueError if keyword is missing, and cleanup by dropping vector indexes"},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_passing_graph_object","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_passing_graph_object","_rev":"_jzRpLMq---","type":"function","name":"test_neo4jvector_passing_graph_object","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":982,"source":"def test_neo4jvector_passing_graph_object(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test end to end construction and search with passing graph object.\"\"\"\n    graph = Neo4jGraph(**neo4j_credentials)\n    # Rewrite env vars to make sure it fails if env is used\n    old_url = os.environ[\"NEO4J_URI\"]\n    os.environ[\"NEO4J_URI\"] = \"foo\"\n    docsearch = Neo4jVector.from_texts(\n        texts=texts,\n        embedding=FakeEmbeddingsWithOsDimension(),\n        graph=graph,\n        pre_delete_collection=True,\n        **neo4j_credentials,\n    )\n    output = docsearch.similarity_search(\"foo\", k=1)\n    assert output == [Document(page_content=\"foo\")]\n\n    drop_vector_indexes(docsearch)\n    os.environ[\"NEO4J_URI\"] = old_url","docstring":"Test end to end construction and search with passing graph object.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason":"it is about creating a Neo4jGraph object with credentials, modifying environment variables to test handling, constructing a Neo4jVector object with the graph and other parameters, performing a similarity search, asserting the expected output, and then cleaning up by dropping indexes and restoring environment variables.","reason_kor":"자격 증명과 함께 Neo4jGraph 객체 생성, 환경 변수 조작 테스트, 그래프 및 기타 파라미터로 Neo4jVector 객체 구성, 유사도 검색 수행, 예상 출력 단언, 인덱스 삭제 및 환경 변수 복구"},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_prefer_indexname","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_prefer_indexname","_rev":"_jzRpLM2---","type":"function","name":"test_neo4jvector_prefer_indexname","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":280,"source":"def test_neo4jvector_prefer_indexname(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test using when two indexes are found, prefer by index_name.\"\"\"\n    Neo4jVector.from_texts(\n        texts=[\"foo\"],\n        embedding=FakeEmbeddingsWithOsDimension(),\n        pre_delete_collection=True,\n        **neo4j_credentials,\n    )\n\n    Neo4jVector.from_texts(\n        texts=[\"bar\"],\n        embedding=FakeEmbeddingsWithOsDimension(),\n        index_name=\"foo\",\n        node_label=\"Test\",\n        embedding_node_property=\"vector\",\n        text_node_property=\"info\",\n        pre_delete_collection=True,\n        **neo4j_credentials,\n    )\n\n    existing_index = Neo4jVector.from_existing_index(\n        embedding=FakeEmbeddingsWithOsDimension(),\n        index_name=\"foo\",\n        text_node_property=\"info\",\n        **neo4j_credentials,\n    )\n\n    output = existing_index.similarity_search(\"bar\", k=1)\n    assert output == [Document(page_content=\"bar\", metadata={})]\n    drop_vector_indexes(existing_index)","docstring":"Test using when two indexes are found, prefer by index_name.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason":"it is about setup of two index creation methods with different parameters, then used a similarity search to verify that the index with the specified name ('foo') was preferred and utilized correctly, confirming index preference logic.","reason_kor":"두 가지 인덱스 생성 방법 설정 후 유사도 검색을 통해 'foo'라는 이름의 인덱스가 우선적으로 사용되는지 검증합니다."},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_prefer_indexname_insert","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_prefer_indexname_insert","_rev":"_jzRpLNC---","type":"function","name":"test_neo4jvector_prefer_indexname_insert","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":313,"source":"def test_neo4jvector_prefer_indexname_insert(\n    neo4j_credentials: Neo4jCredentials,\n) -> None:\n    \"\"\"Test using when two indexes are found, prefer by index_name.\"\"\"\n    Neo4jVector.from_texts(\n        texts=[\"baz\"],\n        embedding=FakeEmbeddingsWithOsDimension(),\n        pre_delete_collection=True,\n        **neo4j_credentials,\n    )\n\n    Neo4jVector.from_texts(\n        texts=[\"foo\"],\n        embedding=FakeEmbeddingsWithOsDimension(),\n        index_name=\"foo\",\n        node_label=\"Test\",\n        embedding_node_property=\"vector\",\n        text_node_property=\"info\",\n        pre_delete_collection=True,\n        **neo4j_credentials,\n    )\n\n    existing_index = Neo4jVector.from_existing_index(\n        embedding=FakeEmbeddingsWithOsDimension(),\n        index_name=\"foo\",\n        text_node_property=\"info\",\n        **neo4j_credentials,\n    )\n\n    existing_index.add_documents([Document(page_content=\"bar\", metadata={})])\n\n    output = existing_index.similarity_search(\"bar\", k=2)\n    assert output == [\n        Document(page_content=\"bar\", metadata={}),\n        Document(page_content=\"foo\", metadata={}),\n    ]\n    drop_vector_indexes(existing_index)","docstring":"Test using when two indexes are found, prefer by index_name.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason":"it is about setup of Neo4j vectors with multiple indexes, explicitly prefers index named 'foo', adds documents, performs similarity search, and verifies that the search returns expected documents based on the specified index preference.","reason_kor":"여러 인덱스를 가진 Neo4j 벡터 설정, 명시적으로 'foo'라는 이름의 인덱스 선호, 문서 추가, 유사도 검색 수행 및 인덱스 선호에 따른 예상 문서 반환 검증"},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_relationship_index","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_relationship_index","_rev":"_jzRpLNO---","type":"function","name":"test_neo4jvector_relationship_index","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":823,"source":"def test_neo4jvector_relationship_index(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test end to end construction and search.\"\"\"\n    embeddings = FakeEmbeddingsWithOsDimension()\n    docsearch = Neo4jVector.from_texts(\n        texts=texts,\n        embedding=embeddings,\n        pre_delete_collection=True,\n        **neo4j_credentials,\n    )\n    # Ingest data\n    docsearch.query(\n        (\n            \"CREATE ()-[:REL {text: 'foo', embedding: $e1}]->()\"\n            \", ()-[:REL {text: 'far', embedding: $e2}]->()\"\n        ),\n        params={\n            \"e1\": embeddings.embed_query(\"foo\"),\n            \"e2\": embeddings.embed_query(\"bar\"),\n        },\n    )\n    # Create relationship index\n    docsearch.query(\n        \"\"\"CREATE VECTOR INDEX `relationship`\nFOR ()-[r:REL]-() ON (r.embedding)\nOPTIONS {indexConfig: {\n `vector.dimensions`: 1536,\n `vector.similarity_function`: 'cosine'\n}}\n\"\"\"\n    )\n    relationship_index = Neo4jVector.from_existing_relationship_index(\n        embeddings,\n        index_name=\"relationship\",\n        **neo4j_credentials,\n    )\n\n    output = relationship_index.similarity_search(\"foo\", k=1)\n    assert output == [Document(page_content=\"foo\")]\n\n    drop_vector_indexes(docsearch)","docstring":"Test end to end construction and search.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason":"it is about end-to-end construction of a vector-based relationship index in Neo4j, data ingestion with embedded vectors and relationship creation, index creation for similarity search on relationships, and performing a cosine similarity search to retrieve the most relevant document.","reason_kor":"Neo4j에서 벡터 기반 관계 인덱스를 종단 간으로 구성, 임베딩된 벡터와 관계 생성, 관계 유사도 검색용 인덱스 생성, 코사인 유사도 검색 수행으로 가장 관련성 높은 문서 조회"},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_relationship_index_retrieval","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_relationship_index_retrieval","_rev":"_jzRpLNa---","type":"function","name":"test_neo4jvector_relationship_index_retrieval","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":866,"source":"def test_neo4jvector_relationship_index_retrieval(\n    neo4j_credentials: Neo4jCredentials,\n) -> None:\n    \"\"\"Test end to end construction and search.\"\"\"\n    embeddings = FakeEmbeddingsWithOsDimension()\n    docsearch = Neo4jVector.from_texts(\n        texts=texts,\n        embedding=embeddings,\n        pre_delete_collection=True,\n        **neo4j_credentials,\n    )\n    # Ingest data\n    docsearch.query(\n        (\n            \"CREATE ({node:'text'})-[:REL {text: 'foo', embedding: $e1}]->()\"\n            \", ({node:'text'})-[:REL {text: 'far', embedding: $e2}]->()\"\n        ),\n        params={\n            \"e1\": embeddings.embed_query(\"foo\"),\n            \"e2\": embeddings.embed_query(\"bar\"),\n        },\n    )\n    # Create relationship index\n    docsearch.query(\n        \"\"\"CREATE VECTOR INDEX `relationship`\nFOR ()-[r:REL]-() ON (r.embedding)\nOPTIONS {indexConfig: {\n `vector.dimensions`: 1536,\n `vector.similarity_function`: 'cosine'\n}}\n\"\"\"\n    )\n    retrieval_query = (\n        \"RETURN relationship.text + '-' + startNode(relationship).node \"\n        \"AS text, score, {foo:'bar'} AS metadata\"\n    )\n    relationship_index = Neo4jVector.from_existing_relationship_index(\n        embeddings,\n        index_name=\"relationship\",\n        retrieval_query=retrieval_query,\n        **neo4j_credentials,\n    )\n\n    output = relationship_index.similarity_search(\"foo\", k=1)\n    assert output == [Document(page_content=\"foo-text\", metadata={\"foo\": \"bar\"})]\n\n    drop_vector_indexes(docsearch)","docstring":"Test end to end construction and search.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason":"it is about end-to-end process of creating a vector index for relationships in Neo4j, ingesting data with embedded vectors, creating a vector index on relationships with specified configuration, retrieving similar relationships using a similarity search, and finally cleaning up indexes.","reason_kor":"Neo4j에서 관계 벡터 인덱스 생성 및 데이터 삽입, 지정된 구성으로 관계 벡터 인덱스 생성, 유사 관계 검색 수행 및 인덱스 정리"},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_relevance_score","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_relevance_score","_rev":"_jzRpLNq---","type":"function","name":"test_neo4jvector_relevance_score","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":211,"source":"def test_neo4jvector_relevance_score(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test to make sure the relevance score is scaled to 0-1.\"\"\"\n    metadatas = [{\"page\": str(i)} for i in range(len(texts))]\n    docsearch = Neo4jVector.from_texts(\n        texts=texts,\n        embedding=FakeEmbeddingsWithOsDimension(),\n        metadatas=metadatas,\n        pre_delete_collection=True,\n        **neo4j_credentials,\n    )\n\n    output = docsearch.similarity_search_with_relevance_scores(\"foo\", k=3)\n    output_texts = [doc.page_content for doc, _ in output]\n\n    expected_order = [\"foo\", \"It is the end of the world. Take shelter!\", \"baz\"]\n    assert output_texts == expected_order\n    relevance_scores = [score for _, score in output]\n    assert all(\n        earlier >= later\n        for earlier, later in zip(relevance_scores, relevance_scores[1:])\n    )\n\n    drop_vector_indexes(docsearch)","docstring":"Test to make sure the relevance score is scaled to 0-1.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason":"it is about function definitions, comment documentation, object initialization with parameters, similarity search, assertions to verify relevance score scaling between 0-1, and cleanup steps like drop_vector_indexes","reason_kor":"함수 정의, 주석 문서화, 파라미터로 객체 초기화, 유사도 검색, 점수 스케일(0-1) 검증, 벡터 인덱스 삭제 등 정리 단계 포합니다."},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_retriever_search_threshold","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_retriever_search_threshold","_rev":"_jzRpLN2---","type":"function","name":"test_neo4jvector_retriever_search_threshold","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":237,"source":"def test_neo4jvector_retriever_search_threshold(\n    neo4j_credentials: Neo4jCredentials,\n) -> None:\n    \"\"\"Test using retriever for searching with threshold.\"\"\"\n    metadatas = [{\"page\": str(i)} for i in range(len(texts))]\n    docsearch = Neo4jVector.from_texts(\n        texts=texts,\n        embedding=FakeEmbeddingsWithOsDimension(),\n        metadatas=metadatas,\n        pre_delete_collection=True,\n        **neo4j_credentials,\n    )\n\n    retriever = docsearch.as_retriever(\n        search_type=\"similarity_score_threshold\",\n        search_kwargs={\"k\": 3, \"score_threshold\": 0.999},\n    )\n    output = retriever.invoke(\"foo\")\n\n    assert output == [\n        Document(page_content=\"foo\", metadata={\"page\": \"0\"}),\n    ]\n\n    drop_vector_indexes(docsearch)","docstring":"Test using retriever for searching with threshold.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason":"it is about creation of a Neo4j vector store with texts and metadata, then configured a retriever to search based on similarity score threshold, invoked the retriever, and verified the output matches expected documents, finally cleaning up indexes.","reason_kor":"텍스트와 메타데이터를 포함한 Neo4j 벡터 스토어 생성, 유사도 점수 임계값에 따른 검색기 설정, 검색기 호출 및 예상 문서와 일치하는지 검증, 인덱스 정리"},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_special_character","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_special_character","_rev":"_jzRpLOC---","type":"function","name":"test_neo4jvector_special_character","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":625,"source":"def test_neo4jvector_special_character(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test removing lucene.\"\"\"\n    text_embeddings = FakeEmbeddingsWithOsDimension().embed_documents(texts)\n    text_embedding_pairs = list(zip(texts, text_embeddings))\n    docsearch = Neo4jVector.from_embeddings(\n        text_embeddings=text_embedding_pairs,\n        embedding=FakeEmbeddingsWithOsDimension(),\n        pre_delete_collection=True,\n        search_type=SearchType.HYBRID,\n        **neo4j_credentials,\n    )\n    output = docsearch.similarity_search(\n        \"It is the end of the world. Take shelter!\",\n        k=1,\n    )\n\n    assert output == [\n        Document(page_content=\"It is the end of the world. Take shelter!\", metadata={})\n    ]\n\n    drop_vector_indexes(docsearch)","docstring":"Test removing lucene.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason":"it is about the creation of text embeddings, initialization of a Neo4j vector search object with specific credentials and options, performing a similarity search with a query, asserting the expected output, and finally dropping vector indexes for cleanup.","reason_kor":"텍스트 임베딩 생성, 특정 자격 증명 및 옵션으로 Neo4j 벡터 검색 객체 초기화, 쿼리로 유사도 검색 수행, 예상 출력 단언, 인덱스 삭제"},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_with_metadatas","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_with_metadatas","_rev":"_jzRpLOO---","type":"function","name":"test_neo4jvector_with_metadatas","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":172,"source":"def test_neo4jvector_with_metadatas(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test end to end construction and search.\"\"\"\n    metadatas = [{\"page\": str(i)} for i in range(len(texts))]\n    docsearch = Neo4jVector.from_texts(\n        texts=texts,\n        embedding=FakeEmbeddingsWithOsDimension(),\n        metadatas=metadatas,\n        pre_delete_collection=True,\n        **neo4j_credentials,\n    )\n    output = docsearch.similarity_search(\"foo\", k=1)\n    assert output == [Document(page_content=\"foo\", metadata={\"page\": \"0\"})]\n\n    drop_vector_indexes(docsearch)","docstring":"Test end to end construction and search.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason":"It is about the setup of a Neo4j vector search with texts and metadatas, initializes a vector store, performs a similarity search, and asserts the expected output, then drops vector indexes.","reason_kor":"텍스트와 메타데이터를 포함한 Neo4j 벡터 검색 설정, 벡터 스토어 초기화, 유사도 검색 수행 및 예상 결과 단언 후 인덱스 삭제"},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_with_metadatas_with_scores","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_test_neo4jvector_with_metadatas_with_scores","_rev":"_jzRpLOa---","type":"function","name":"test_neo4jvector_with_metadatas_with_scores","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":189,"source":"def test_neo4jvector_with_metadatas_with_scores(\n    neo4j_credentials: Neo4jCredentials,\n) -> None:\n    \"\"\"Test end to end construction and search.\"\"\"\n    metadatas = [{\"page\": str(i)} for i in range(len(texts))]\n    docsearch = Neo4jVector.from_texts(\n        texts=texts,\n        embedding=FakeEmbeddingsWithOsDimension(),\n        metadatas=metadatas,\n        pre_delete_collection=True,\n        **neo4j_credentials,\n    )\n    output = [\n        (doc, round(score, 1))\n        for doc, score in docsearch.similarity_search_with_score(\"foo\", k=1)\n    ]\n    assert output == [(Document(page_content=\"foo\", metadata={\"page\": \"0\"}), 1.0)]\n\n    drop_vector_indexes(docsearch)","docstring":"Test end to end construction and search.","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason":"it is about the creation of a Neo4j vector index from texts and metadata with their embedding, performed a similarity search with score, and validated the output matches expected document and score.","reason_kor":"텍스트 및 메타데이터와 임베딩으로 Neo4j 벡터 인덱스를 생성, 점수 기반 유사도 검색 수행, 예상 문서 및 점수와 일치하는지 검증"},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_test_retrieval_dictionary","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_test_retrieval_dictionary","_rev":"_jzRpLOm---","type":"function","name":"test_retrieval_dictionary","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":750,"source":"def test_retrieval_dictionary(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test if we use parameters in retrieval query\"\"\"\n    docsearch = Neo4jVector.from_texts(\n        texts=texts,\n        embedding=FakeEmbeddings(),\n        pre_delete_collection=True,\n        retrieval_query=\"\"\"\n        RETURN {\n            name:'John', \n            age: 30,\n            skills: [\"Python\", \"Data Analysis\", \"Machine Learning\"]} as text, \n            score, {} AS metadata\n        \"\"\",\n        **neo4j_credentials,\n    )\n    expected_output = [\n        Document(\n            page_content=(\n                \"skills:\\n- Python\\n- Data Analysis\\n- \"\n                \"Machine Learning\\nage: 30\\nname: John\\n\"\n            )\n        )\n    ]\n\n    output = docsearch.similarity_search(\"Foo\", k=1)\n\n    def parse_document(doc: Document) -> Any:\n        return safe_load(doc.page_content)\n\n    parsed_expected = [parse_document(doc) for doc in expected_output]\n    parsed_output = [parse_document(doc) for doc in output]\n\n    assert parsed_output == parsed_expected\n    drop_vector_indexes(docsearch)","docstring":"Test if we use parameters in retrieval query","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason":"it is about a Neo4j vector search with a retrieval query that returns a structured dictionary containing a person's details and skills, then tested the similarity search's output against expected structured data by parsing the document content.","reason_kor":"사람의 세부 정보와 기술을 포함한 구조화된 딕셔너리를 반환하는 검색 쿼리가 포함된 Neo4j 벡터 검색, 문서 내용을 파싱해 유사도 검색 결과를 예상 구조화 데이터와 비교 검증"},{"_key":"tests_integration_tests_vectorstores_test_neo4jvector_py_test_retrieval_params","_id":"nodes/tests_integration_tests_vectorstores_test_neo4jvector_py_test_retrieval_params","_rev":"_jzRpLOy---","type":"function","name":"test_retrieval_params","defined_in":"tests_integration_tests_vectorstores_test_neo4jvector_py","lineno":727,"source":"def test_retrieval_params(neo4j_credentials: Neo4jCredentials) -> None:\n    \"\"\"Test if we use parameters in retrieval query\"\"\"\n    docsearch = Neo4jVector.from_texts(\n        texts=texts,\n        embedding=FakeEmbeddings(),\n        pre_delete_collection=True,\n        retrieval_query=\"\"\"\n        RETURN $test as text, score, {test: $test1} AS metadata\n        \"\"\",\n        **neo4j_credentials,\n    )\n\n    output = docsearch.similarity_search(\n        \"Foo\", k=2, params={\"test\": \"test\", \"test1\": \"test1\"}\n    )\n    assert output == [\n        Document(page_content=\"test\", metadata={\"test\": \"test1\"}),\n        Document(page_content=\"test\", metadata={\"test\": \"test1\"}),\n    ]\n    drop_vector_indexes(docsearch)","docstring":"Test if we use parameters in retrieval query","args":[{"arg":"neo4j_credentials","type":"Neo4jCredentials"}],"return_type":"None","control_flow":[],"reason":"it is about a test function that creates a Neo4j vector search object with text embeddings, sets a custom retrieval query using parameters, performs similarity search with specific parameters, asserts the expected output, and finally drops the indexes to clean up.","reason_kor":"텍스트 임베딩으로 Neo4j 벡터 검색 객체 생성, 매개변수로 사용자 정의 검색 쿼리 설정, 특정 파라미터로 유사도 검색 수행, 예상 결과 단언 및 인덱스 정리"},{"_key":"tests_llms","_id":"nodes/tests_llms","_rev":"_jzRpDSi---","type":"directory","name":"llms","path":"C:\\workspace\\langchain-neo4j\\tests\\llms"},{"_key":"tests_llms___init___py","_id":"nodes/tests_llms___init___py","_rev":"_jzRpDXq---","type":"file","name":"__init__.py","path":"C:\\workspace\\langchain-neo4j\\tests\\llms\\__init__.py"},{"_key":"tests_llms_fake_llm_py","_id":"nodes/tests_llms_fake_llm_py","_rev":"_jzRpDS2---","type":"file","name":"fake_llm.py","path":"C:\\workspace\\langchain-neo4j\\tests\\llms\\fake_llm.py"},{"_key":"tests_llms_fake_llm_py_FakeLLM","_id":"nodes/tests_llms_fake_llm_py_FakeLLM","_rev":"_jzRpLP----","type":"class","name":"FakeLLM","defined_in":"tests_llms_fake_llm_py","lineno":10,"docstring":"Fake LLM wrapper for testing purposes.","source":"class FakeLLM(LLM):\n    \"\"\"Fake LLM wrapper for testing purposes.\"\"\"\n\n    queries: Optional[Mapping] = None\n    sequential_responses: Optional[bool] = False\n    response_index: int = 0\n\n    @validator(\"queries\", always=True)\n    def check_queries_required(\n        cls, queries: Optional[Mapping], values: Mapping[str, Any]\n    ) -> Optional[Mapping]:\n        if values.get(\"sequential_response\") and not queries:\n            raise ValueError(\n                \"queries is required when sequential_response is set to True\"\n            )\n        return queries\n\n    def get_num_tokens(self, text: str) -> int:\n        \"\"\"Return number of tokens.\"\"\"\n        return len(text.split())\n\n    @property\n    def _llm_type(self) -> str:\n        \"\"\"Return type of llm.\"\"\"\n        return \"fake\"\n\n    def _call(\n        self,\n        prompt: str,\n        stop: Optional[List[str]] = None,\n        run_manager: Optional[CallbackManagerForLLMRun] = None,\n        **kwargs: Any,\n    ) -> str:\n        if self.sequential_responses:\n            return self._get_next_response_in_sequence\n        if self.queries is not None:\n            return self.queries[prompt]\n        if stop is None:\n            return \"foo\"\n        else:\n            return \"bar\"\n\n    @property\n    def _identifying_params(self) -> Dict[str, Any]:\n        return {}\n\n    @property\n    def _get_next_response_in_sequence(self) -> str:\n        queries = cast(Mapping, self.queries)\n        response = queries[list(queries.keys())[self.response_index]]\n        self.response_index = self.response_index + 1\n        return response\n\n    def bind_tools(self, tools: Any) -> None:\n        pass","inst_variables":[],"reason":"Fake LLM wrapper class for testing that can return predefined or sequential responses, count tokens, and simulate basic LLM behavior.","reason_kor":"사전 정의된 응답 또는 순차 응답을 반환하며 토큰 수 계산 등 기본 LLM 동작을 흉내내는 테스트용 페이크 LLM 래퍼 클래스."},{"_key":"tests_llms_fake_llm_py__call","_id":"nodes/tests_llms_fake_llm_py__call","_rev":"_jzRpLPG---","type":"function","name":"_call","defined_in":"tests_llms_fake_llm_py","lineno":36,"source":"def _call(\n        self,\n        prompt: str,\n        stop: Optional[List[str]] = None,\n        run_manager: Optional[CallbackManagerForLLMRun] = None,\n        **kwargs: Any,\n    ) -> str:\n        if self.sequential_responses:\n            return self._get_next_response_in_sequence\n        if self.queries is not None:\n            return self.queries[prompt]\n        if stop is None:\n            return \"foo\"\n        else:\n            return \"bar\"","docstring":null,"args":[{"arg":"self","type":null},{"arg":"prompt","type":"str"},{"arg":"stop","type":"Optional[List[str]]"},{"arg":"run_manager","type":"Optional[CallbackManagerForLLMRun]"}],"return_type":"str","control_flow":[{"type":"if","lineno":43},{"type":"if","lineno":45},{"type":"if","lineno":47}],"reason":"Fake LLM's call method returning preset or default responses based on prompt and stop conditions, supporting sequential responses.","reason_kor":"프롬프트와 stop 조건에 따라 미리 지정된 또는 기본 응답을 반환하는 가짜 LLM의 호출 메서드로, 순차적 응답도 지원."},{"_key":"tests_llms_fake_llm_py__get_next_response_in_sequence","_id":"nodes/tests_llms_fake_llm_py__get_next_response_in_sequence","_rev":"_jzRpLPS---","type":"function","name":"_get_next_response_in_sequence","defined_in":"tests_llms_fake_llm_py","lineno":57,"source":"def _get_next_response_in_sequence(self) -> str:\n        queries = cast(Mapping, self.queries)\n        response = queries[list(queries.keys())[self.response_index]]\n        self.response_index = self.response_index + 1\n        return response","docstring":null,"args":[{"arg":"self","type":null}],"return_type":"str","control_flow":[],"reason":"it is about accessing a collection of queries, retrieving a response based on the current index, then incrementing the index to prepare for the next call","reason_kor":"쿼리 모음에 접근해 현재 인덱스에 따른 응답을 검색하고, 다음 호출을 위해 인덱스를 증가시키는 기능 결합"},{"_key":"tests_llms_fake_llm_py__identifying_params","_id":"nodes/tests_llms_fake_llm_py__identifying_params","_rev":"_jzRpLPe---","type":"function","name":"_identifying_params","defined_in":"tests_llms_fake_llm_py","lineno":53,"source":"def _identifying_params(self) -> Dict[str, Any]:\n        return {}","docstring":null,"args":[{"arg":"self","type":null}],"return_type":"Dict[str, Any]","control_flow":[],"reason":"Returns an empty dictionary representing the identifying parameters of the fake LLM.","reason_kor":"가짜 LLM의 식별 파라미터로 빈 딕셔너리를 반환."},{"_key":"tests_llms_fake_llm_py__llm_type","_id":"nodes/tests_llms_fake_llm_py__llm_type","_rev":"_jzRpLPq---","type":"function","name":"_llm_type","defined_in":"tests_llms_fake_llm_py","lineno":32,"source":"def _llm_type(self) -> str:\n        \"\"\"Return type of llm.\"\"\"\n        return \"fake\"","docstring":"Return type of llm.","args":[{"arg":"self","type":null}],"return_type":"str","control_flow":[],"reason":"Returns the string 'fake' as the type identifier of the fake LLM.","reason_kor":"가짜 LLM의 유형 식별자로 문자열 'fake'를 반환."},{"_key":"tests_llms_fake_llm_py_bind_tools","_id":"nodes/tests_llms_fake_llm_py_bind_tools","_rev":"_jzRpLP2---","type":"function","name":"bind_tools","defined_in":"tests_llms_fake_llm_py","lineno":63,"source":"def bind_tools(self, tools: Any) -> None:\n        pass","docstring":null,"args":[{"arg":"self","type":null},{"arg":"tools","type":"Any"}],"return_type":"None","control_flow":[],"reason":"Empty method stub for binding tools to the FakeLLM; does nothing.","reason_kor":"FakeLLM에 툴을 바인딩하는 빈 메서드, 아무 동작도 하지 않음."},{"_key":"tests_llms_fake_llm_py_check_queries_required","_id":"nodes/tests_llms_fake_llm_py_check_queries_required","_rev":"_jzRpLQC---","type":"function","name":"check_queries_required","defined_in":"tests_llms_fake_llm_py","lineno":18,"source":"def check_queries_required(\n        cls, queries: Optional[Mapping], values: Mapping[str, Any]\n    ) -> Optional[Mapping]:\n        if values.get(\"sequential_response\") and not queries:\n            raise ValueError(\n                \"queries is required when sequential_response is set to True\"\n            )\n        return queries","docstring":null,"args":[{"arg":"cls","type":null},{"arg":"queries","type":"Optional[Mapping]"},{"arg":"values","type":"Mapping[str, Any]"}],"return_type":"Optional[Mapping]","control_flow":[{"type":"if","lineno":21}],"reason":"it is about checking if 'sequential_response' is set to True in 'values' and if 'queries' is provided, raising an error if 'queries' is missing while 'sequential_response' is True, otherwise returning 'queries'.","reason_kor":"'values'에서 'sequential_response'가 True이고 'queries'가 제공되었는지 확인, 'sequential_response'가 True인데 'queries'가 없으면 오류를 발생시키고, 그렇지 않으면 'queries' 반환"},{"_key":"tests_llms_fake_llm_py_get_num_tokens","_id":"nodes/tests_llms_fake_llm_py_get_num_tokens","_rev":"_jzRpLQO---","type":"function","name":"get_num_tokens","defined_in":"tests_llms_fake_llm_py","lineno":27,"source":"def get_num_tokens(self, text: str) -> int:\n        \"\"\"Return number of tokens.\"\"\"\n        return len(text.split())","docstring":"Return number of tokens.","args":[{"arg":"self","type":null},{"arg":"text","type":"str"}],"return_type":"int","control_flow":[],"reason":"it is about the input string by splitting it on whitespace characters and then calculated the length of the resulting list, which represents the number of tokens in the text.","reason_kor":"입력 문자열을 공백 문자 기준으로 분할한 후, 분할된 리스트의 길이를 계산하여 텍스트 내 토큰 수를 산출합니다."},{"_key":"tests_unit_tests","_id":"nodes/tests_unit_tests","_rev":"_jzRpDYC---","type":"directory","name":"unit_tests","path":"C:\\workspace\\langchain-neo4j\\tests\\unit_tests"},{"_key":"tests_unit_tests___init___py","_id":"nodes/tests_unit_tests___init___py","_rev":"_jzRpDZq---","type":"file","name":"__init__.py","path":"C:\\workspace\\langchain-neo4j\\tests\\unit_tests\\__init__.py"},{"_key":"tests_unit_tests_chains","_id":"nodes/tests_unit_tests_chains","_rev":"_jzRpDaC---","type":"directory","name":"chains","path":"C:\\workspace\\langchain-neo4j\\tests\\unit_tests\\chains"},{"_key":"tests_unit_tests_chains___init___py","_id":"nodes/tests_unit_tests_chains___init___py","_rev":"_jzRpEGS---","type":"file","name":"__init__.py","path":"C:\\workspace\\langchain-neo4j\\tests\\unit_tests\\chains\\__init__.py"},{"_key":"tests_unit_tests_chains_test_cypher_utils_py","_id":"nodes/tests_unit_tests_chains_test_cypher_utils_py","_rev":"_jzRpDaa---","type":"file","name":"test_cypher_utils.py","path":"C:\\workspace\\langchain-neo4j\\tests\\unit_tests\\chains\\test_cypher_utils.py"},{"_key":"tests_unit_tests_chains_test_cypher_utils_py_test_cypher_query_corrector","_id":"nodes/tests_unit_tests_chains_test_cypher_utils_py_test_cypher_query_corrector","_rev":"_jzRpLQa---","type":"function","name":"test_cypher_query_corrector","defined_in":"tests_unit_tests_chains_test_cypher_utils_py","lineno":34,"source":"def test_cypher_query_corrector(description: str, query: str, expected: str) -> None:\n    assert corrector.correct_query(query) == expected, f\"{description} failed\"","docstring":null,"args":[{"arg":"description","type":"str"},{"arg":"query","type":"str"},{"arg":"expected","type":"str"}],"return_type":"None","control_flow":[],"reason":"Test function verifying that a Cypher query corrector correctly transforms input queries to expected output queries.","reason_kor":"Cypher 쿼리 수정기가 입력 쿼리를 예상 결과 쿼리로 올바르게 변환하는지 검증하는 테스트 함수."},{"_key":"tests_unit_tests_chains_test_graph_qa_py","_id":"nodes/tests_unit_tests_chains_test_graph_qa_py","_rev":"_jzRpDbO---","type":"file","name":"test_graph_qa.py","path":"C:\\workspace\\langchain-neo4j\\tests\\unit_tests\\chains\\test_graph_qa.py"},{"_key":"tests_unit_tests_chains_test_graph_qa_py_FakeGraphStore","_id":"nodes/tests_unit_tests_chains_test_graph_qa_py_FakeGraphStore","_rev":"_jzRpLQi---","type":"class","name":"FakeGraphStore","defined_in":"tests_unit_tests_chains_test_graph_qa_py","lineno":39,"docstring":null,"source":"class FakeGraphStore:\n    @property\n    def get_schema(self) -> str:\n        \"\"\"Returns the schema of the Graph database\"\"\"\n        return \"\"\n\n    @property\n    def get_structured_schema(self) -> Dict[str, Any]:\n        \"\"\"Returns the schema of the Graph database\"\"\"\n        return {}\n\n    @property\n    def _enhanced_schema(self) -> bool:\n        \"\"\"Whether the schema is enhanced\"\"\"\n        return False\n\n    def query(self, query: str, params: dict = {}) -> List[Dict[str, Any]]:\n        \"\"\"Query the graph.\"\"\"\n        return []\n\n    def refresh_schema(self) -> None:\n        \"\"\"Refreshes the graph schema information.\"\"\"\n        pass\n\n    def add_graph_documents(\n        self, graph_documents: List[GraphDocument], include_source: bool = False\n    ) -> None:\n        \"\"\"Take GraphDocument as input as uses it to construct a graph.\"\"\"\n        pass","inst_variables":[],"reason":"Mock implementation of a GraphStore interface for testing, providing stub methods and properties with empty or default returns.","reason_kor":"테스트용 GraphStore 인터페이스의 모킹 구현체, 빈 또는 기본값 반환 메서드와 프로퍼티 포함."},{"_key":"tests_unit_tests_chains_test_graph_qa_py__enhanced_schema","_id":"nodes/tests_unit_tests_chains_test_graph_qa_py__enhanced_schema","_rev":"_jzRpLQy---","type":"function","name":"_enhanced_schema","defined_in":"tests_unit_tests_chains_test_graph_qa_py","lineno":51,"source":"def _enhanced_schema(self) -> bool:\n        \"\"\"Whether the schema is enhanced\"\"\"\n        return False","docstring":"Whether the schema is enhanced","args":[{"arg":"self","type":null}],"return_type":"bool","control_flow":[],"reason":"Stub method indicating whether the schema is enhanced, always returns False in test context.","reason_kor":"스키마가 확장되었는지 여부를 나타내는 테스트용 스텁 메서드, 항상 False 반환."},{"_key":"tests_unit_tests_chains_test_graph_qa_py_add_graph_documents","_id":"nodes/tests_unit_tests_chains_test_graph_qa_py_add_graph_documents","_rev":"_jzRpLR----","type":"function","name":"add_graph_documents","defined_in":"tests_unit_tests_chains_test_graph_qa_py","lineno":63,"source":"def add_graph_documents(\n        self, graph_documents: List[GraphDocument], include_source: bool = False\n    ) -> None:\n        \"\"\"Take GraphDocument as input as uses it to construct a graph.\"\"\"\n        pass","docstring":"Take GraphDocument as input as uses it to construct a graph.","args":[{"arg":"self","type":null},{"arg":"graph_documents","type":"List[GraphDocument]"},{"arg":"include_source","type":"bool"}],"return_type":"None","control_flow":[],"reason":"Stub method to add graph documents for testing; no operation performed.","reason_kor":"그래프 문서 추가용 테스트 스텁 메서드, 동작하지 않음."},{"_key":"tests_unit_tests_chains_test_graph_qa_py_get_schema","_id":"nodes/tests_unit_tests_chains_test_graph_qa_py_get_schema","_rev":"_jzRpLRK---","type":"function","name":"get_schema","defined_in":"tests_unit_tests_chains_test_graph_qa_py","lineno":41,"source":"def get_schema(self) -> str:\n        \"\"\"Returns the schema of the Graph database\"\"\"\n        return \"\"","docstring":"Returns the schema of the Graph database","args":[{"arg":"self","type":null}],"return_type":"str","control_flow":[],"reason":"Stub method returning an empty string as the graph database schema in test environment.","reason_kor":"테스트 환경에서 빈 문자열을 그래프 데이터베이스 스키마로 반환하는 스텁 메서드."},{"_key":"tests_unit_tests_chains_test_graph_qa_py_get_structured_schema","_id":"nodes/tests_unit_tests_chains_test_graph_qa_py_get_structured_schema","_rev":"_jzRpLRW---","type":"function","name":"get_structured_schema","defined_in":"tests_unit_tests_chains_test_graph_qa_py","lineno":46,"source":"def get_structured_schema(self) -> Dict[str, Any]:\n        \"\"\"Returns the schema of the Graph database\"\"\"\n        return {}","docstring":"Returns the schema of the Graph database","args":[{"arg":"self","type":null}],"return_type":"Dict[str, Any]","control_flow":[],"reason_kor":"테스트용 구조화된 그래프 스키마를 빈 딕셔너리로 반환하는 스텁 메서드.","reason":"Stub method returning empty dictionary as the structured graph schema for testing."},{"_key":"tests_unit_tests_chains_test_graph_qa_py_load_schemas","_id":"nodes/tests_unit_tests_chains_test_graph_qa_py_load_schemas","_rev":"_jzRpLRe---","type":"function","name":"load_schemas","defined_in":"tests_unit_tests_chains_test_graph_qa_py","lineno":573,"source":"def load_schemas(str_schemas: str) -> List[Schema]:\n    \"\"\"\n    Args:\n        str_schemas: string of schemas\n    \"\"\"\n    values = str_schemas.replace(\"(\", \"\").replace(\")\", \"\").split(\",\")\n    schemas = []\n    for i in range(len(values) // 3):\n        schemas.append(\n            Schema(\n                values[i * 3].strip(),\n                values[i * 3 + 1].strip(),\n                values[i * 3 + 2].strip(),\n            )\n        )\n    return schemas","docstring":"Args:\n    str_schemas: string of schemas","args":[{"arg":"str_schemas","type":"str"}],"return_type":"List[Schema]","control_flow":[{"type":"for","lineno":580}],"reason_kor":"콤마로 구분된 스키마 세부 정보를 처리해 괄호 제거, 분할, 3개씩 그룹화하여 구조화된 Schema 객체로 변환하는 문자열 처리 및 리스트 반복 결합","reason":"it is about string processing and list iteration to parse a comma-separated string of schema details into structured Schema objects by removing parentheses, splitting, and grouping every three values for each schema."},{"_key":"tests_unit_tests_chains_test_graph_qa_py_query","_id":"nodes/tests_unit_tests_chains_test_graph_qa_py_query","_rev":"_jzRpLRq---","type":"function","name":"query","defined_in":"tests_unit_tests_chains_test_graph_qa_py","lineno":55,"source":"def query(self, query: str, params: dict = {}) -> List[Dict[str, Any]]:\n        \"\"\"Query the graph.\"\"\"\n        return []","docstring":"Query the graph.","args":[{"arg":"self","type":null},{"arg":"query","type":"str"},{"arg":"params","type":"dict"}],"return_type":"List[Dict[str, Any]]","control_flow":[],"reason_kor":"테스트용 쿼리 메서드, 빈 리스트 반환하여 쿼리 결과가 없음을 시뮬레이션.","reason":"Stub query method returning an empty list, simulating no results in test graph queries."},{"_key":"tests_unit_tests_chains_test_graph_qa_py_refresh_schema","_id":"nodes/tests_unit_tests_chains_test_graph_qa_py_refresh_schema","_rev":"_jzRpLR2---","type":"function","name":"refresh_schema","defined_in":"tests_unit_tests_chains_test_graph_qa_py","lineno":59,"source":"def refresh_schema(self) -> None:\n        \"\"\"Refreshes the graph schema information.\"\"\"\n        pass","docstring":"Refreshes the graph schema information.","args":[{"arg":"self","type":null}],"return_type":"None","control_flow":[],"reason_kor":"그래프 스키마 갱신용 테스트 스텁 메서드, 실제 동작 없음.","reason":"Stub method for refreshing graph schema, no actual operation in test."},{"_key":"tests_unit_tests_chains_test_graph_qa_py_test_allow_dangerous_requests_err","_id":"nodes/tests_unit_tests_chains_test_graph_qa_py_test_allow_dangerous_requests_err","_rev":"_jzRpLSC---","type":"function","name":"test_allow_dangerous_requests_err","defined_in":"tests_unit_tests_chains_test_graph_qa_py","lineno":469,"source":"def test_allow_dangerous_requests_err() -> None:\n    with pytest.raises(ValueError) as exc_info:\n        GraphCypherQAChain.from_llm(\n            llm=FakeLLM(),\n            graph=FakeGraphStore(),\n        )\n    assert (\n        \"In order to use this chain, you must acknowledge that it can make \"\n        \"dangerous requests by setting `allow_dangerous_requests` to `True`.\"\n    ) in str(exc_info.value)","docstring":null,"args":[],"return_type":"None","control_flow":[],"reason_kor":"allow_dangerous_requests를 허용하지 않고 생성된 'GraphCypherQAChain' 클래스가 'ValueError'를 발생시키는지, 경고 메시지가 포함되었는지 예외 처리와 함께 단위 테스트합니다.","reason":"it is about a unit test function with exception handling to verify that the 'GraphCypherQAChain' class raises a 'ValueError' when instantiated without allowing dangerous requests, checking the error message for a specific warning about the need to set 'allow_dangerous_requests' to 'True'."},{"_key":"tests_unit_tests_chains_test_graph_qa_py_test_chain_type","_id":"nodes/tests_unit_tests_chains_test_graph_qa_py_test_chain_type","_rev":"_jzRpLSO---","type":"function","name":"test_chain_type","defined_in":"tests_unit_tests_chains_test_graph_qa_py","lineno":254,"source":"def test_chain_type() -> None:\n    chain = GraphCypherQAChain.from_llm(\n        llm=FakeLLM(),\n        graph=FakeGraphStore(),\n        allow_dangerous_requests=True,\n    )\n    assert chain._chain_type == \"graph_cypher_chain\"","docstring":null,"args":[],"return_type":"None","control_flow":[],"reason_kor":"언어 모델(FakeLLM)과 그래프 저장소(FakeGraphStore)에서 위험한 요청 허용 옵션과 함께 GraphCypherQAChain 객체를 생성하고, 체인의 타입 속성이 'graph_cypher_chain'인지 확인합니다.","reason":"it is about the creation of a GraphCypherQAChain object from a language model (FakeLLM) and a graph store (FakeGraphStore), with an option to allow dangerous requests, then it checks if the chain's type attribute is set to 'graph_cypher_chain'."},{"_key":"tests_unit_tests_chains_test_graph_qa_py_test_cypher_generation_failure","_id":"nodes/tests_unit_tests_chains_test_graph_qa_py_test_cypher_generation_failure","_rev":"_jzRpLSa---","type":"function","name":"test_cypher_generation_failure","defined_in":"tests_unit_tests_chains_test_graph_qa_py","lineno":317,"source":"def test_cypher_generation_failure() -> None:\n    \"\"\"Test the chain doesn't fail if the Cypher query fails to be generated.\"\"\"\n    llm = FakeLLM(queries={\"query\": \"\"}, sequential_responses=True)\n    chain = GraphCypherQAChain.from_llm(\n        llm=llm,\n        graph=FakeGraphStore(),\n        allow_dangerous_requests=True,\n        return_direct=True,\n    )\n    response = chain.run(\"Test question\")\n    assert response == []","docstring":"Test the chain doesn't fail if the Cypher query fails to be generated.","args":[],"return_type":"None","control_flow":[],"reason_kor":"미리 정의된 응답을 가진 가짜 언어 모델과 가짜 그래프 저장소를 생성하고, Cypher 쿼리 생성 실패 시 오류 없이 빈 리스트를 반환하는 GraphCypherQAChain의 처리 능력을 테스트합니다.","reason":"it is about creating a fake language model with predefined responses and a fake graph store, then tested the GraphCypherQAChain's ability to handle a failure in Cypher query generation without raising errors, ensuring it returns an empty list as expected."},{"_key":"tests_unit_tests_chains_test_graph_qa_py_test_exclude_types","_id":"nodes/tests_unit_tests_chains_test_graph_qa_py_test_exclude_types","_rev":"_jzRpLSm---","type":"function","name":"test_exclude_types","defined_in":"tests_unit_tests_chains_test_graph_qa_py","lineno":330,"source":"def test_exclude_types() -> None:\n    structured_schema = {\n        \"node_props\": {\n            \"Movie\": [{\"property\": \"title\", \"type\": \"STRING\"}],\n            \"Actor\": [{\"property\": \"name\", \"type\": \"STRING\"}],\n            \"Person\": [{\"property\": \"name\", \"type\": \"STRING\"}],\n        },\n        \"rel_props\": {\"ACTED_IN\": [{\"property\": \"role\", \"type\": \"STRING\"}]},\n        \"relationships\": [\n            {\"start\": \"Actor\", \"end\": \"Movie\", \"type\": \"ACTED_IN\"},\n            {\"start\": \"Person\", \"end\": \"Movie\", \"type\": \"DIRECTED\"},\n        ],\n    }\n    exclude_types = [\"Person\", \"DIRECTED\"]\n    output = construct_schema(structured_schema, [], exclude_types, False)\n    expected_schema = (\n        \"Node properties:\\n\"\n        \"Movie {title: STRING}\\n\"\n        \"Actor {name: STRING}\\n\"\n        \"Relationship properties:\\n\"\n        \"ACTED_IN {role: STRING}\\n\"\n        \"The relationships:\\n\"\n        \"(:Actor)-[:ACTED_IN]->(:Movie)\"\n    )\n    assert output == expected_schema","docstring":null,"args":[],"return_type":"None","control_flow":[],"reason_kor":"특정 노드 및 관계 유형을 제외하여 스키마를 필터링하고, 남은 스키마 세부 정보와 관계를 설명 문자열로 형식화합니다.","reason":"it is about schema filtering by excluding specified node and relationship types, then formatted the remaining schema details and relationships into a descriptive string"},{"_key":"tests_unit_tests_chains_test_graph_qa_py_test_get_function_response","_id":"nodes/tests_unit_tests_chains_test_graph_qa_py_test_get_function_response","_rev":"_jzRpLSu---","type":"function","name":"test_get_function_response","defined_in":"tests_unit_tests_chains_test_graph_qa_py","lineno":451,"source":"def test_get_function_response() -> None:\n    question = \"Who directed Dune?\"\n    context = [{\"director\": \"Denis Villeneuve\"}]\n    messages = get_function_response(question, context)\n    assert len(messages) == 2\n    # Validate AIMessage\n    ai_message = messages[0]\n    assert isinstance(ai_message, AIMessage)\n    assert ai_message.content == \"\"\n    assert \"tool_calls\" in ai_message.additional_kwargs\n    tool_call = ai_message.additional_kwargs[\"tool_calls\"][0]\n    assert tool_call[\"function\"][\"arguments\"] == f'{{\"question\":\"{question}\"}}'\n    # Validate ToolMessage\n    tool_message = messages[1]\n    assert isinstance(tool_message, ToolMessage)\n    assert tool_message.content == str(context)","docstring":null,"args":[],"return_type":"None","control_flow":[],"reason_kor":"get_function_response 함수의 동작을 검증하는 테스트 함수로, 반환된 메시지 수와 유형을 확인하며 AIMessage에 예상 내용과 도구 호출 인자가 포함됐는지, ToolMessage가 제공된 컨텍스트를 올바르게 표현하는지 검증합니다.","reason":"it is about a test function that verifies the behavior of get_function_response by checking the number and types of messages returned, ensuring the AIMessage contains expected content and tool call arguments, and validating that the ToolMessage correctly represents the provided context."},{"_key":"tests_unit_tests_chains_test_graph_qa_py_test_graph_cypher_qa_chain","_id":"nodes/tests_unit_tests_chains_test_graph_qa_py_test_graph_cypher_qa_chain","_rev":"_jzRpLS6---","type":"function","name":"test_graph_cypher_qa_chain","defined_in":"tests_unit_tests_chains_test_graph_qa_py","lineno":263,"source":"def test_graph_cypher_qa_chain() -> None:\n    template = \"\"\"You are a nice chatbot having a conversation with a human.\n\n    Schema:\n    {schema}\n\n    Previous conversation:\n    {chat_history}\n\n    New human question: {question}\n    Response:\"\"\"\n\n    prompt = PromptTemplate(\n        input_variables=[\"schema\", \"question\", \"chat_history\"], template=template\n    )\n\n    memory = ConversationBufferMemory(memory_key=\"chat_history\")\n    readonlymemory = ReadOnlySharedMemory(memory=memory)\n    prompt1 = (\n        \"You are a nice chatbot having a conversation with a human.\\n\\n    \"\n        \"Schema:\\n    Node properties:\\n\\nRelationship \"\n        \"properties:\\n\\nThe relationships\"\n        \":\\n\\n\\n    \"\n        \"Previous conversation:\\n    \\n\\n    New human question: \"\n        \"Test question\\n    Response:\"\n    )\n\n    prompt2 = (\n        \"You are a nice chatbot having a conversation with a human.\\n\\n    \"\n        \"Schema:\\n    Node properties:\\n\\nRelationship \"\n        \"properties:\\n\\nThe relationships\"\n        \":\\n\\n\\n    \"\n        \"Previous conversation:\\n    Human: Test question\\nAI: foo\\n\\n    \"\n        \"New human question: Test new question\\n    Response:\"\n    )\n\n    llm = FakeLLM(queries={prompt1: \"answer1\", prompt2: \"answer2\"})\n    chain = GraphCypherQAChain.from_llm(\n        cypher_llm=llm,\n        qa_llm=FakeLLM(),\n        graph=FakeGraphStore(),\n        verbose=True,\n        return_intermediate_steps=False,\n        cypher_llm_kwargs={\"prompt\": prompt, \"memory\": readonlymemory},\n        memory=memory,\n        allow_dangerous_requests=True,\n    )\n    chain.run(\"Test question\")\n    chain.run(\"Test new question\")\n    # If we get here without a key error, that means memory\n    # was used properly to create prompts.\n    assert True","docstring":null,"args":[],"return_type":"None","control_flow":[],"reason":"it is about template-based prompt creation with in-memory conversation history, utilized a fake language model to simulate responses, and tested the chain's ability to generate queries based on conversation context and schema, ensuring proper memory usage and prompt formation.","reason_kor":"템플릿 기반 프롬프트 생성, 인메모리 대화 기록 활용, 가짜 언어 모델로 응답 시뮬레이션, 대화 컨텍스트 및 스키마에 기반한 쿼리 생성 능력을 테스트합니다."},{"_key":"tests_unit_tests_chains_test_graph_qa_py_test_graph_cypher_qa_chain_prompt_selection_1","_id":"nodes/tests_unit_tests_chains_test_graph_qa_py_test_graph_cypher_qa_chain_prompt_selection_1","_rev":"_jzRpLTG---","type":"function","name":"test_graph_cypher_qa_chain_prompt_selection_1","defined_in":"tests_unit_tests_chains_test_graph_qa_py","lineno":76,"source":"def test_graph_cypher_qa_chain_prompt_selection_1() -> None:\n    # Pass prompts directly. No kwargs is specified.\n    qa_prompt_template = \"QA Prompt\"\n    cypher_prompt_template = \"Cypher Prompt\"\n    qa_prompt = PromptTemplate(template=qa_prompt_template, input_variables=[])\n    cypher_prompt = PromptTemplate(template=cypher_prompt_template, input_variables=[])\n    chain = GraphCypherQAChain.from_llm(\n        llm=FakeLLM(),\n        graph=FakeGraphStore(),\n        verbose=True,\n        return_intermediate_steps=False,\n        qa_prompt=qa_prompt,\n        cypher_prompt=cypher_prompt,\n        allow_dangerous_requests=True,\n    )\n    assert hasattr(chain.qa_chain, \"first\")\n    assert chain.qa_chain.first == qa_prompt\n    assert hasattr(chain.cypher_generation_chain, \"first\")\n    assert chain.cypher_generation_chain.first == cypher_prompt","docstring":null,"args":[],"return_type":"None","control_flow":[],"reason":"it is about the construction of a GraphCypherQAChain object with specific prompt templates, then verified that the qa_prompt and cypher_prompt were correctly assigned to their respective chain attributes, ensuring proper initialization and attribute setting.","reason_kor":"특정 프롬프트 템플릿을 사용해 GraphCypherQAChain 객체를 생성하고, qa_prompt와 cypher_prompt가 각각 체인 속성에 올바르게 할당되었는지 검증합니다."},{"_key":"tests_unit_tests_chains_test_graph_qa_py_test_graph_cypher_qa_chain_prompt_selection_2","_id":"nodes/tests_unit_tests_chains_test_graph_qa_py_test_graph_cypher_qa_chain_prompt_selection_2","_rev":"_jzRpLTS---","type":"function","name":"test_graph_cypher_qa_chain_prompt_selection_2","defined_in":"tests_unit_tests_chains_test_graph_qa_py","lineno":97,"source":"def test_graph_cypher_qa_chain_prompt_selection_2() -> None:\n    # Default case. Pass nothing\n    chain = GraphCypherQAChain.from_llm(\n        llm=FakeLLM(),\n        graph=FakeGraphStore(),\n        verbose=True,\n        return_intermediate_steps=False,\n        allow_dangerous_requests=True,\n    )\n    assert hasattr(chain.qa_chain, \"first\")\n    assert chain.qa_chain.first == CYPHER_QA_PROMPT\n    assert hasattr(chain.cypher_generation_chain, \"first\")\n    assert chain.cypher_generation_chain.first == CYPHER_GENERATION_PROMPT","docstring":null,"args":[],"return_type":"None","control_flow":[],"reason":"it is about the creation of a GraphCypherQAChain object with default parameters, then verified that the 'qa_chain' and 'cypher_generation_chain' attributes have their 'first' element matching the specified prompts, ensuring proper initialization and prompt assignment.","reason_kor":"기본 매개변수로 GraphCypherQAChain 객체를 생성하고, 'qa_chain'과 'cypher_generation_chain' 속성의 첫 번째 요소가 지정된 프롬프트와 일치하는지 확인합니다."},{"_key":"tests_unit_tests_chains_test_graph_qa_py_test_graph_cypher_qa_chain_prompt_selection_3","_id":"nodes/tests_unit_tests_chains_test_graph_qa_py_test_graph_cypher_qa_chain_prompt_selection_3","_rev":"_jzRpLTi---","type":"function","name":"test_graph_cypher_qa_chain_prompt_selection_3","defined_in":"tests_unit_tests_chains_test_graph_qa_py","lineno":112,"source":"def test_graph_cypher_qa_chain_prompt_selection_3() -> None:\n    # Pass non-prompt args only to sub-chains via kwargs\n    memory = ConversationBufferMemory(memory_key=\"chat_history\")\n    readonlymemory = ReadOnlySharedMemory(memory=memory)\n    chain = GraphCypherQAChain.from_llm(\n        llm=FakeLLM(),\n        graph=FakeGraphStore(),\n        verbose=True,\n        return_intermediate_steps=False,\n        cypher_llm_kwargs={\"memory\": readonlymemory},\n        qa_llm_kwargs={\"memory\": readonlymemory},\n        allow_dangerous_requests=True,\n    )\n    assert hasattr(chain.qa_chain, \"first\")\n    assert chain.qa_chain.first == CYPHER_QA_PROMPT\n    assert hasattr(chain.cypher_generation_chain, \"first\")\n    assert chain.cypher_generation_chain.first == CYPHER_GENERATION_PROMPT","docstring":null,"args":[],"return_type":"None","control_flow":[],"reason":"it is about the initialization of a graph query chain with memory management, creating a chain object using a language model and graph store, and then verified that specific prompt attributes are correctly set within the chain components.","reason_kor":"메모리 관리와 함께 그래프 쿼리 체인을 초기화하고, 언어 모델 및 그래프 저장소를 사용해 체인을 생성하며, 체인 구성 요소 내 특정 프롬프트 속성이 올바르게 설정되었는지 검증합니다."},{"_key":"tests_unit_tests_chains_test_graph_qa_py_test_graph_cypher_qa_chain_prompt_selection_4","_id":"nodes/tests_unit_tests_chains_test_graph_qa_py_test_graph_cypher_qa_chain_prompt_selection_4","_rev":"_jzRpLTu---","type":"function","name":"test_graph_cypher_qa_chain_prompt_selection_4","defined_in":"tests_unit_tests_chains_test_graph_qa_py","lineno":131,"source":"def test_graph_cypher_qa_chain_prompt_selection_4() -> None:\n    # Pass prompt, non-prompt args to subchains via kwargs\n    qa_prompt_template = \"QA Prompt\"\n    cypher_prompt_template = \"Cypher Prompt\"\n    memory = ConversationBufferMemory(memory_key=\"chat_history\")\n    readonlymemory = ReadOnlySharedMemory(memory=memory)\n    qa_prompt = PromptTemplate(template=qa_prompt_template, input_variables=[])\n    cypher_prompt = PromptTemplate(template=cypher_prompt_template, input_variables=[])\n    chain = GraphCypherQAChain.from_llm(\n        llm=FakeLLM(),\n        graph=FakeGraphStore(),\n        verbose=True,\n        return_intermediate_steps=False,\n        cypher_llm_kwargs={\"prompt\": cypher_prompt, \"memory\": readonlymemory},\n        qa_llm_kwargs={\"prompt\": qa_prompt, \"memory\": readonlymemory},\n        allow_dangerous_requests=True,\n    )\n    assert hasattr(chain.qa_chain, \"first\")\n    assert chain.qa_chain.first == qa_prompt\n    assert hasattr(chain.cypher_generation_chain, \"first\")\n    assert chain.cypher_generation_chain.first == cypher_prompt","docstring":null,"args":[],"return_type":"None","control_flow":[],"reason":"it is about the creation of a GraphCypherQAChain object using provided prompt templates, memory objects, and keyword arguments for both QA and Cypher subchains, then verified that the subchains correctly stored the prompt templates as attributes.","reason_kor":"제공된 프롬프트 템플릿, 메모리 객체, 키워드 인자를 사용해 GraphCypherQAChain을 생성하고, QA 및 Cypher 서브체인이 프롬프트 템플릿을 속성으로 올바르게 저장했는지 확인합니다."},{"_key":"tests_unit_tests_chains_test_graph_qa_py_test_graph_cypher_qa_chain_prompt_selection_5","_id":"nodes/tests_unit_tests_chains_test_graph_qa_py_test_graph_cypher_qa_chain_prompt_selection_5","_rev":"_jzRpLT6---","type":"function","name":"test_graph_cypher_qa_chain_prompt_selection_5","defined_in":"tests_unit_tests_chains_test_graph_qa_py","lineno":154,"source":"def test_graph_cypher_qa_chain_prompt_selection_5() -> None:\n    # Can't pass both prompt and kwargs at the same time\n    qa_prompt_template = \"QA Prompt\"\n    cypher_prompt_template = \"Cypher Prompt\"\n    memory = ConversationBufferMemory(memory_key=\"chat_history\")\n    readonlymemory = ReadOnlySharedMemory(memory=memory)\n    qa_prompt = PromptTemplate(template=qa_prompt_template, input_variables=[])\n    cypher_prompt = PromptTemplate(template=cypher_prompt_template, input_variables=[])\n    with pytest.raises(ValueError) as exc_info:\n        GraphCypherQAChain.from_llm(\n            llm=FakeLLM(),\n            graph=FakeGraphStore(),\n            verbose=True,\n            return_intermediate_steps=False,\n            cypher_prompt=cypher_prompt,\n            cypher_llm_kwargs={\"memory\": readonlymemory},\n            allow_dangerous_requests=True,\n        )\n    assert (\n        \"Specifying cypher_prompt and cypher_llm_kwargs together is\"\n        \" not allowed. Please pass prompt via cypher_llm_kwargs.\"\n    ) == str(exc_info.value)\n    with pytest.raises(ValueError) as exc_info:\n        GraphCypherQAChain.from_llm(\n            llm=FakeLLM(),\n            graph=FakeGraphStore(),\n            verbose=True,\n            return_intermediate_steps=False,\n            qa_prompt=qa_prompt,\n            qa_llm_kwargs={\"memory\": readonlymemory},\n            allow_dangerous_requests=True,\n        )\n    assert (\n        \"Specifying qa_prompt and qa_llm_kwargs together is\"\n        \" not allowed. Please pass prompt via qa_llm_kwargs.\"\n    ) == str(exc_info.value)","docstring":null,"args":[],"return_type":"None","control_flow":[],"reason":"it is about function testing for GraphCypherQAChain to ensure that passing both specific prompt objects and keyword arguments simultaneously raises ValueError, verifying proper input validation and error messages.","reason_kor":"GraphCypherQAChain 함수 테스트로, 특정 프롬프트 객체와 키워드 인자를 동시에 전달하면 ValueError가 발생하는지, 적절한 입력 검증 및 오류 메시지 확인"},{"_key":"tests_unit_tests_chains_test_graph_qa_py_test_graph_cypher_qa_chain_prompt_selection_6","_id":"nodes/tests_unit_tests_chains_test_graph_qa_py_test_graph_cypher_qa_chain_prompt_selection_6","_rev":"_jzRpLUG---","type":"function","name":"test_graph_cypher_qa_chain_prompt_selection_6","defined_in":"tests_unit_tests_chains_test_graph_qa_py","lineno":192,"source":"def test_graph_cypher_qa_chain_prompt_selection_6() -> None:\n    # Test function response prompt\n    function_response_system = \"Respond as a pirate!\"\n    response_prompt = ChatPromptTemplate.from_messages(\n        [\n            SystemMessage(content=function_response_system),\n            HumanMessagePromptTemplate.from_template(\"{question}\"),\n            MessagesPlaceholder(variable_name=\"function_response\"),\n        ]\n    )\n    chain = GraphCypherQAChain.from_llm(\n        llm=FakeLLM(),\n        graph=FakeGraphStore(),\n        verbose=True,\n        use_function_response=True,\n        function_response_system=function_response_system,\n        allow_dangerous_requests=True,\n    )\n    assert hasattr(chain.qa_chain, \"first\")\n    assert chain.qa_chain.first == response_prompt\n    assert hasattr(chain.cypher_generation_chain, \"first\")\n    assert chain.cypher_generation_chain.first == CYPHER_GENERATION_PROMPT","docstring":null,"args":[],"return_type":"None","control_flow":[],"reason":"it is about the creation of a chat prompt template with specific system and human messages, then configured a GraphCypherQAChain object with parameters to enable function response handling and dangerous requests, finally verifying the chain's prompt attributes.","reason_kor":"특정 시스템 및 인간 메시지로 채팅 프롬프트 템플릿을 생성하고, 함수 응답 처리 및 위험한 요청을 활성화하는 매개변수로 GraphCypherQAChain을 구성, 체인의 프롬프트 속성을 검증합니다."},{"_key":"tests_unit_tests_chains_test_graph_qa_py_test_graph_cypher_qa_chain_prompt_selection_7","_id":"nodes/tests_unit_tests_chains_test_graph_qa_py_test_graph_cypher_qa_chain_prompt_selection_7","_rev":"_jzRpLUS---","type":"function","name":"test_graph_cypher_qa_chain_prompt_selection_7","defined_in":"tests_unit_tests_chains_test_graph_qa_py","lineno":216,"source":"def test_graph_cypher_qa_chain_prompt_selection_7() -> None:\n    # Pass prompts which do not inherit from BasePromptTemplate\n    with pytest.raises(ValueError) as exc_info:\n        GraphCypherQAChain.from_llm(\n            llm=FakeLLM(),\n            graph=FakeGraphStore(),\n            cypher_llm_kwargs={\"prompt\": None},\n            allow_dangerous_requests=True,\n        )\n    assert \"The cypher_llm_kwargs `prompt` must inherit from BasePromptTemplate\" == str(\n        exc_info.value\n    )\n    with pytest.raises(ValueError) as exc_info:\n        GraphCypherQAChain.from_llm(\n            llm=FakeLLM(),\n            graph=FakeGraphStore(),\n            qa_llm_kwargs={\"prompt\": None},\n            allow_dangerous_requests=True,\n        )\n    assert \"The qa_llm_kwargs `prompt` must inherit from BasePromptTemplate\" == str(\n        exc_info.value\n    )","docstring":null,"args":[],"return_type":"None","control_flow":[],"reason":"it is about exception handling to test that the method 'from_llm' in the 'GraphCypherQAChain' class correctly raises ValueError when the 'prompt' in 'cypher_llm_kwargs' or 'qa_llm_kwargs' does not inherit from 'BasePromptTemplate'.","reason_kor":"'GraphCypherQAChain' 클래스의 'from_llm' 메서드가 'cypher_llm_kwargs' 또는 'qa_llm_kwargs'의 'prompt'가 'BasePromptTemplate'을 상속하지 않을 때 ValueError를 발생시키는 예외 처리 테스트"},{"_key":"tests_unit_tests_chains_test_graph_qa_py_test_graph_store","_id":"nodes/tests_unit_tests_chains_test_graph_qa_py_test_graph_store","_rev":"_jzRpLUe---","type":"function","name":"test_graph_store","defined_in":"tests_unit_tests_chains_test_graph_qa_py","lineno":70,"source":"def test_graph_store() -> None:\n    \"\"\"Tests that FakeGraphStore satisfies the GraphStore protocol requirements.\"\"\"\n    graph = FakeGraphStore()\n    assert isinstance(graph, GraphStore)","docstring":"Tests that FakeGraphStore satisfies the GraphStore protocol requirements.","args":[],"return_type":"None","control_flow":[],"reason":"it is about a function that initializes an instance of FakeGraphStore and checks if this instance complies with the GraphStore protocol using isinstance.","reason_kor":"FakeGraphStore 인스턴스를 초기화하고 이 인스턴스가 GraphStore 프로토콜을 준수하는지 isinstance로 확인하는 함수"},{"_key":"tests_unit_tests_chains_test_graph_qa_py_test_include_exclude_types_err","_id":"nodes/tests_unit_tests_chains_test_graph_qa_py_test_include_exclude_types_err","_rev":"_jzRpLUq---","type":"function","name":"test_include_exclude_types_err","defined_in":"tests_unit_tests_chains_test_graph_qa_py","lineno":436,"source":"def test_include_exclude_types_err() -> None:\n    with pytest.raises(ValueError) as exc_info:\n        GraphCypherQAChain.from_llm(\n            llm=FakeLLM(),\n            graph=FakeGraphStore(),\n            include_types=[\"Movie\", \"Actor\"],\n            exclude_types=[\"Person\", \"DIRECTED\"],\n            allow_dangerous_requests=True,\n        )\n    assert (\n        \"Either `exclude_types` or `include_types` can be provided, but not both\"\n        == str(exc_info.value)\n    )","docstring":null,"args":[],"return_type":"None","control_flow":[],"reason":"it is about the creation of a GraphCypherQAChain instance with specific include and exclude types, and it tests that providing both include_types and exclude_types raises a ValueError, ensuring that only one of these filter options is used at a time.","reason_kor":"특정 include 및 exclude 유형으로 GraphCypherQAChain 인스턴스를 생성하고, include_types와 exclude_types를 동시에 제공하면 ValueError가 발생하는지 테스트하여 하나의 필터 옵션만 사용하도록 보장합니다."},{"_key":"tests_unit_tests_chains_test_graph_qa_py_test_include_types","_id":"nodes/tests_unit_tests_chains_test_graph_qa_py_test_include_types","_rev":"_jzRpLU2---","type":"function","name":"test_include_types","defined_in":"tests_unit_tests_chains_test_graph_qa_py","lineno":357,"source":"def test_include_types() -> None:\n    structured_schema = {\n        \"node_props\": {\n            \"Movie\": [{\"property\": \"title\", \"type\": \"STRING\"}],\n            \"Actor\": [{\"property\": \"name\", \"type\": \"STRING\"}],\n            \"Person\": [{\"property\": \"name\", \"type\": \"STRING\"}],\n        },\n        \"rel_props\": {\"ACTED_IN\": [{\"property\": \"role\", \"type\": \"STRING\"}]},\n        \"relationships\": [\n            {\"start\": \"Actor\", \"end\": \"Movie\", \"type\": \"ACTED_IN\"},\n            {\"start\": \"Person\", \"end\": \"Movie\", \"type\": \"DIRECTED\"},\n        ],\n    }\n    include_types = [\"Movie\", \"Actor\", \"ACTED_IN\"]\n    output = construct_schema(structured_schema, include_types, [], False)\n    expected_schema = (\n        \"Node properties:\\n\"\n        \"Movie {title: STRING}\\n\"\n        \"Actor {name: STRING}\\n\"\n        \"Relationship properties:\\n\"\n        \"ACTED_IN {role: STRING}\\n\"\n        \"The relationships:\\n\"\n        \"(:Actor)-[:ACTED_IN]->(:Movie)\"\n    )\n    assert output == expected_schema","docstring":null,"args":[],"return_type":"None","control_flow":[],"reason":"it is about node properties, relationship properties, and relationship descriptions into a formatted string based on the provided schema and included types, filtering the schema elements accordingly.","reason_kor":"제공된 스키마와 포함된 유형에 따라 노드 속성, 관계 속성, 관계 설명을 포맷된 문자열로 결합하고, 스키마 요소를 필터링합니다."},{"_key":"tests_unit_tests_chains_test_graph_qa_py_test_include_types2","_id":"nodes/tests_unit_tests_chains_test_graph_qa_py_test_include_types2","_rev":"_jzRpLVG---","type":"function","name":"test_include_types2","defined_in":"tests_unit_tests_chains_test_graph_qa_py","lineno":384,"source":"def test_include_types2() -> None:\n    structured_schema = {\n        \"node_props\": {\n            \"Movie\": [{\"property\": \"title\", \"type\": \"STRING\"}],\n            \"Actor\": [{\"property\": \"name\", \"type\": \"STRING\"}],\n            \"Person\": [{\"property\": \"name\", \"type\": \"STRING\"}],\n        },\n        \"rel_props\": {\"ACTED_IN\": [{\"property\": \"role\", \"type\": \"STRING\"}]},\n        \"relationships\": [\n            {\"start\": \"Actor\", \"end\": \"Movie\", \"type\": \"ACTED_IN\"},\n            {\"start\": \"Person\", \"end\": \"Movie\", \"type\": \"DIRECTED\"},\n        ],\n    }\n    include_types = [\"Movie\", \"Actor\"]\n    output = construct_schema(structured_schema, include_types, [], False)\n    expected_schema = (\n        \"Node properties:\\n\"\n        \"Movie {title: STRING}\\n\"\n        \"Actor {name: STRING}\\n\"\n        \"Relationship properties:\\n\\n\"\n        \"The relationships:\\n\"\n    )\n    assert output == expected_schema","docstring":null,"args":[],"return_type":"None","control_flow":[],"reason":"it is about structured schema definition with specified types to generate a formatted schema string, including node properties and relationship properties, while excluding relationships from the output","reason_kor":"지정된 유형으로 구조화된 스키마 정의를 생성하고, 노드 속성 및 관계 속성을 포함하며 관계는 출력에서 제외하는 스키마 문자열을 생성합니다."},{"_key":"tests_unit_tests_chains_test_graph_qa_py_test_include_types3","_id":"nodes/tests_unit_tests_chains_test_graph_qa_py_test_include_types3","_rev":"_jzRpLVO---","type":"function","name":"test_include_types3","defined_in":"tests_unit_tests_chains_test_graph_qa_py","lineno":409,"source":"def test_include_types3() -> None:\n    structured_schema = {\n        \"node_props\": {\n            \"Movie\": [{\"property\": \"title\", \"type\": \"STRING\"}],\n            \"Actor\": [{\"property\": \"name\", \"type\": \"STRING\"}],\n            \"Person\": [{\"property\": \"name\", \"type\": \"STRING\"}],\n        },\n        \"rel_props\": {\"ACTED_IN\": [{\"property\": \"role\", \"type\": \"STRING\"}]},\n        \"relationships\": [\n            {\"start\": \"Actor\", \"end\": \"Movie\", \"type\": \"ACTED_IN\"},\n            {\"start\": \"Person\", \"end\": \"Movie\", \"type\": \"DIRECTED\"},\n        ],\n    }\n    include_types = [\"Movie\", \"Actor\", \"ACTED_IN\"]\n    output = construct_schema(structured_schema, include_types, [], False)\n    expected_schema = (\n        \"Node properties:\\n\"\n        \"Movie {title: STRING}\\n\"\n        \"Actor {name: STRING}\\n\"\n        \"Relationship properties:\\n\"\n        \"ACTED_IN {role: STRING}\\n\"\n        \"The relationships:\\n\"\n        \"(:Actor)-[:ACTED_IN]->(:Movie)\"\n    )\n    assert output == expected_schema","docstring":null,"args":[],"return_type":"None","control_flow":[],"reason":"it is about node properties, relationship properties, and relationships into a formatted string, selecting only the provided include_types and arranging the information hierarchy logically.","reason_kor":"노드 속성, 관계 속성, 관계를 포함하여 지정된 include_types만 선택하고 정보 계층을 논리적으로 정리한 문자열로 변환합니다."},{"_key":"tests_unit_tests_chains_test_graph_qa_py_test_llm_arg_combinations","_id":"nodes/tests_unit_tests_chains_test_graph_qa_py_test_llm_arg_combinations","_rev":"_jzRpLVa---","type":"function","name":"test_llm_arg_combinations","defined_in":"tests_unit_tests_chains_test_graph_qa_py","lineno":481,"source":"def test_llm_arg_combinations() -> None:\n    # No llm\n    with pytest.raises(ValueError) as exc_info:\n        GraphCypherQAChain.from_llm(\n            graph=FakeGraphStore(), allow_dangerous_requests=True\n        )\n    assert \"At least one LLM must be provided\" == str(exc_info.value)\n    # llm only\n    GraphCypherQAChain.from_llm(\n        llm=FakeLLM(), graph=FakeGraphStore(), allow_dangerous_requests=True\n    )\n    # qa_llm only\n    with pytest.raises(ValueError) as exc_info:\n        GraphCypherQAChain.from_llm(\n            qa_llm=FakeLLM(), graph=FakeGraphStore(), allow_dangerous_requests=True\n        )\n    assert (\n        \"If `llm` is not provided, both `qa_llm` and `cypher_llm` must be provided.\"\n        == str(exc_info.value)\n    )\n    # cypher_llm only\n    with pytest.raises(ValueError) as exc_info:\n        GraphCypherQAChain.from_llm(\n            cypher_llm=FakeLLM(), graph=FakeGraphStore(), allow_dangerous_requests=True\n        )\n    assert (\n        \"If `llm` is not provided, both `qa_llm` and `cypher_llm` must be provided.\"\n        == str(exc_info.value)\n    )\n    # llm + qa_llm\n    GraphCypherQAChain.from_llm(\n        llm=FakeLLM(),\n        qa_llm=FakeLLM(),\n        graph=FakeGraphStore(),\n        allow_dangerous_requests=True,\n    )\n    # llm + cypher_llm\n    GraphCypherQAChain.from_llm(\n        llm=FakeLLM(),\n        cypher_llm=FakeLLM(),\n        graph=FakeGraphStore(),\n        allow_dangerous_requests=True,\n    )\n    # qa_llm + cypher_llm\n    GraphCypherQAChain.from_llm(\n        qa_llm=FakeLLM(),\n        cypher_llm=FakeLLM(),\n        graph=FakeGraphStore(),\n        allow_dangerous_requests=True,\n    )\n    # llm + qa_llm + cypher_llm\n    with pytest.raises(ValueError) as exc_info:\n        GraphCypherQAChain.from_llm(\n            llm=FakeLLM(),\n            qa_llm=FakeLLM(),\n            cypher_llm=FakeLLM(),\n            graph=FakeGraphStore(),\n            allow_dangerous_requests=True,\n        )\n    assert (\n        \"You can specify up to two of 'cypher_llm', 'qa_llm'\"\n        \", and 'llm', but not all three simultaneously.\"\n    ) == str(exc_info.value)","docstring":null,"args":[],"return_type":"None","control_flow":[],"reason":"it is about various argument validation cases for the `from_llm` method of `GraphCypherQAChain`, testing the presence and combinations of `llm`, `qa_llm`, and `cypher_llm`, ensuring proper error handling and correct instantiation scenarios.","reason_kor":"`GraphCypherQAChain`의 `from_llm` 메서드에 대한 다양한 인자 검증 케이스를 포함하며, `llm`, `qa_llm`, `cypher_llm`의 존재 및 조합을 테스트하고, 적절한 오류 처리와 올바른 인스턴스화 시나리오를 보장합니다."},{"_key":"tests_unit_tests_chains_test_graph_qa_py_test_use_function_response_err","_id":"nodes/tests_unit_tests_chains_test_graph_qa_py_test_use_function_response_err","_rev":"_jzRpLVm---","type":"function","name":"test_use_function_response_err","defined_in":"tests_unit_tests_chains_test_graph_qa_py","lineno":546,"source":"def test_use_function_response_err() -> None:\n    llm = MagicMock(spec=LLM)\n    with pytest.raises(ValueError) as exc_info:\n        GraphCypherQAChain.from_llm(\n            llm=llm,\n            graph=FakeGraphStore(),\n            allow_dangerous_requests=True,\n            use_function_response=True,\n        )\n    assert \"Provided LLM does not support native tools/functions\" == str(exc_info.value)","docstring":null,"args":[],"return_type":"None","control_flow":[],"reason":"it tests the creation of GraphCypherQAChain with a mocked LLM to ensure that if use_function_response is enabled but the LLM does not support native tools/functions, it raises a ValueError with an appropriate message","reason_kor":"함수 응답 사용이 활성화되었으나 LLM이 네이티브 도구/함수를 지원하지 않을 때 GraphCypherQAChain 생성 시 ValueError가 발생하는지 테스트합니다."},{"_key":"tests_unit_tests_chains_test_graph_qa_py_test_validate_cypher","_id":"nodes/tests_unit_tests_chains_test_graph_qa_py_test_validate_cypher","_rev":"_jzRpLVy---","type":"function","name":"test_validate_cypher","defined_in":"tests_unit_tests_chains_test_graph_qa_py","lineno":240,"source":"def test_validate_cypher() -> None:\n    with patch(\n        \"langchain_neo4j.chains.graph_qa.cypher.CypherQueryCorrector\",\n        autospec=True,\n    ) as cypher_query_corrector_mock:\n        GraphCypherQAChain.from_llm(\n            llm=FakeLLM(),\n            graph=FakeGraphStore(),\n            validate_cypher=True,\n            allow_dangerous_requests=True,\n        )\n        cypher_query_corrector_mock.assert_called_once_with([])","docstring":null,"args":[],"return_type":"None","control_flow":[],"reason":"it creates a mock for CypherQueryCorrector, instantiates GraphCypherQAChain with specific parameters, and verifies that CypherQueryCorrector is called once with an empty list.","reason_kor":"CypherQueryCorrector를 모킹하고, 특정 매개변수로 GraphCypherQAChain을 인스턴스화하며, CypherQueryCorrector가 빈 리스트로 한 번 호출되는지 검증합니다."},{"_key":"tests_unit_tests_chains_test_graph_qa_py_test_validating_cypher_statements","_id":"nodes/tests_unit_tests_chains_test_graph_qa_py_test_validating_cypher_statements","_rev":"_jzRpLW----","type":"function","name":"test_validating_cypher_statements","defined_in":"tests_unit_tests_chains_test_graph_qa_py","lineno":563,"source":"def test_validating_cypher_statements() -> None:\n    cypher_file = str(UNIT_TESTS_ROOT / \"data/cypher_corrector.csv\")\n    with open(cypher_file, newline=\"\") as csvfile:\n        csv_reader = DictReader(csvfile)\n        for row in csv_reader:\n            schema = load_schemas(row[\"schema\"])\n            corrector = CypherQueryCorrector(schema)\n            assert corrector(row[\"statement\"]) == row[\"correct_query\"]","docstring":null,"args":[],"return_type":"None","control_flow":[{"type":"for","lineno":567}],"reason":"it is about reading a CSV file containing cypher statements and their correct versions, loading schemas from the 'schema' column, creating a CypherQueryCorrector instance with the loaded schema, and asserting that the corrector's output matches the expected 'correct_query' for each statement.","reason_kor":"Cypher 문장과 정정 문장이 포함된 CSV 파일을 읽고, 'schema' 열에서 스키마를 로드, 로드된 스키마로 CypherQueryCorrector 인스턴스를 생성, 정정된 쿼리가 예상 'correct_query'와 일치하는지 단언합니다."},{"_key":"tests_unit_tests_chat_message_histories","_id":"nodes/tests_unit_tests_chat_message_histories","_rev":"_jzRpEGu---","type":"directory","name":"chat_message_histories","path":"C:\\workspace\\langchain-neo4j\\tests\\unit_tests\\chat_message_histories"},{"_key":"tests_unit_tests_chat_message_histories___init___py","_id":"nodes/tests_unit_tests_chat_message_histories___init___py","_rev":"_jzRpEKm---","type":"file","name":"__init__.py","path":"C:\\workspace\\langchain-neo4j\\tests\\unit_tests\\chat_message_histories\\__init__.py"},{"_key":"tests_unit_tests_chat_message_histories_test_neo4j_chat_message_history_py","_id":"nodes/tests_unit_tests_chat_message_histories_test_neo4j_chat_message_history_py","_rev":"_jzRpEHG---","type":"file","name":"test_neo4j_chat_message_history.py","path":"C:\\workspace\\langchain-neo4j\\tests\\unit_tests\\chat_message_histories\\test_neo4j_chat_message_history.py"},{"_key":"tests_unit_tests_chat_message_histories_test_neo4j_chat_message_history_py_test_driver_closed_on_delete","_id":"nodes/tests_unit_tests_chat_message_histories_test_neo4j_chat_message_history_py_test_driver_closed_on_delete","_rev":"_jzRpLWK---","type":"function","name":"test_driver_closed_on_delete","defined_in":"tests_unit_tests_chat_message_histories_test_neo4j_chat_message_history_py","lineno":33,"source":"def test_driver_closed_on_delete() -> None:\n    \"\"\"Test that the driver is closed when the object is deleted.\"\"\"\n    with patch(\"neo4j.GraphDatabase.driver\", autospec=True):\n        message_store = Neo4jChatMessageHistory(\n            session_id=\"test_session\",\n            url=\"bolt://url\",\n            username=\"username\",\n            password=\"password\",\n        )\n        mock_driver = message_store._driver\n        assert isinstance(mock_driver.close, MagicMock)\n        message_store.__del__()\n        gc.collect()\n        mock_driver.close.assert_called_once()","docstring":"Test that the driver is closed when the object is deleted.","args":[],"return_type":"None","control_flow":[],"reason":"it is about a test case that uses patch to mock the Neo4j driver, created an instance of Neo4jChatMessageHistory, checked that the driver's close method was mocked as a MagicMock, invoked the destructor, performed garbage collection, and verified that the close method was called once upon deletion.","reason_kor":"patch를 사용해 Neo4j 드라이버를 모킹, Neo4jChatMessageHistory 인스턴스를 생성하고, 드라이버의 close 메서드가 MagicMock인지 확인, 소멸자를 호출하고 가비지 컬렉션 수행 후 close가 한 번 호출되었는지 검증합니다."},{"_key":"tests_unit_tests_chat_message_histories_test_neo4j_chat_message_history_py_test_init_without_session_id","_id":"nodes/tests_unit_tests_chat_message_histories_test_neo4j_chat_message_history_py_test_init_without_session_id","_rev":"_jzRpLWW---","type":"function","name":"test_init_without_session_id","defined_in":"tests_unit_tests_chat_message_histories_test_neo4j_chat_message_history_py","lineno":9,"source":"def test_init_without_session_id() -> None:\n    \"\"\"Test initializing without session_id raises ValueError.\"\"\"\n    with pytest.raises(ValueError) as exc_info:\n        Neo4jChatMessageHistory(None)  # type: ignore[arg-type]\n    assert \"Please ensure that the session_id parameter is provided\" in str(\n        exc_info.value\n    )","docstring":"Test initializing without session_id raises ValueError.","args":[],"return_type":"None","control_flow":[],"reason":"it is about a test function that checks whether creating a Neo4jChatMessageHistory object without a session_id raises a ValueError with an appropriate message.","reason_kor":"session_id 없이 Neo4jChatMessageHistory 객체 생성 시 ValueError가 발생하는지 확인하는 테스트 함수"},{"_key":"tests_unit_tests_chat_message_histories_test_neo4j_chat_message_history_py_test_messages_setter","_id":"nodes/tests_unit_tests_chat_message_histories_test_neo4j_chat_message_history_py_test_messages_setter","_rev":"_jzRpLWi---","type":"function","name":"test_messages_setter","defined_in":"tests_unit_tests_chat_message_histories_test_neo4j_chat_message_history_py","lineno":18,"source":"def test_messages_setter() -> None:\n    \"\"\"Test that assigning to messages raises NotImplementedError.\"\"\"\n    with patch(\"neo4j.GraphDatabase.driver\", autospec=True):\n        message_store = Neo4jChatMessageHistory(\n            session_id=\"test_session\",\n            url=\"bolt://url\",\n            username=\"username\",\n            password=\"password\",\n        )\n\n        with pytest.raises(NotImplementedError) as exc_info:\n            message_store.messages = []\n        assert \"Direct assignment to 'messages' is not allowed.\" in str(exc_info.value)","docstring":"Test that assigning to messages raises NotImplementedError.","args":[],"return_type":"None","control_flow":[],"reason":"it is about a test function that ensures assigning to the 'messages' attribute raises a NotImplementedError, using mocking to simulate the database driver and asserting the proper exception and message.","reason_kor":"'messages' 속성에 할당할 때 NotImplementedError가 발생하는지 확인하는 테스트 함수로, 데이터베이스 드라이버를 모킹하고 올바른 예외와 메시지 단언 수행"},{"_key":"tests_unit_tests_data","_id":"nodes/tests_unit_tests_data","_rev":"_jzRpELC---","type":"directory","name":"data","path":"C:\\workspace\\langchain-neo4j\\tests\\unit_tests\\data"},{"_key":"tests_unit_tests_data_cypher_corrector_csv","_id":"nodes/tests_unit_tests_data_cypher_corrector_csv","_rev":"_jzRpELa---","type":"file","name":"cypher_corrector.csv","path":"C:\\workspace\\langchain-neo4j\\tests\\unit_tests\\data\\cypher_corrector.csv"},{"_key":"tests_unit_tests_graphs","_id":"nodes/tests_unit_tests_graphs","_rev":"_jzRpEL6---","type":"directory","name":"graphs","path":"C:\\workspace\\langchain-neo4j\\tests\\unit_tests\\graphs"},{"_key":"tests_unit_tests_graphs___init___py","_id":"nodes/tests_unit_tests_graphs___init___py","_rev":"_jzRpEgC---","type":"file","name":"__init__.py","path":"C:\\workspace\\langchain-neo4j\\tests\\unit_tests\\graphs\\__init__.py"},{"_key":"tests_unit_tests_graphs_test_neo4j_graph_py","_id":"nodes/tests_unit_tests_graphs_test_neo4j_graph_py","_rev":"_jzRpEMW---","type":"file","name":"test_neo4j_graph.py","path":"C:\\workspace\\langchain-neo4j\\tests\\unit_tests\\graphs\\test_neo4j_graph.py"},{"_key":"tests_unit_tests_graphs_test_neo4j_graph_py_mock_neo4j_driver","_id":"nodes/tests_unit_tests_graphs_test_neo4j_graph_py_mock_neo4j_driver","_rev":"_jzRpLWy---","type":"function","name":"mock_neo4j_driver","defined_in":"tests_unit_tests_graphs_test_neo4j_graph_py","lineno":15,"source":"def mock_neo4j_driver() -> Generator[MagicMock, None, None]:\n    with patch(\"neo4j.GraphDatabase.driver\", autospec=True) as mock_driver:\n        mock_driver_instance = MagicMock()\n        mock_driver.return_value = mock_driver_instance\n        mock_driver_instance.verify_connectivity.return_value = None\n        mock_driver_instance.execute_query = MagicMock(\n            return_value=MagicMock(\n                records=[], summary=MagicMock(spec=ResultSummary), keys=[]\n            )\n        )\n        mock_driver_instance._closed = False\n        yield mock_driver_instance","docstring":null,"args":[],"return_type":"Generator[MagicMock, None, None]","control_flow":[],"reason":"it is about patching of neo4j's GraphDatabase.driver with mock objects, setting up return values and method behaviors to facilitate unit testing of code that interacts with Neo4j, using context management and mock configurations for predictability and isolation.","reason_kor":"neo4j.GraphDatabase.driver를 모킹하고 patch하여 Neo4j와 상호작용하는 코드를 위한 단위 테스트 준비, 컨텍스트 관리 및 모킹 구성을 통해 예측 가능하고 독립적인 테스트 환경 제공"},{"_key":"tests_unit_tests_graphs_test_neo4j_graph_py_test_add_graph_docs_inc_src_err","_id":"nodes/tests_unit_tests_graphs_test_neo4j_graph_py_test_add_graph_docs_inc_src_err","_rev":"_jzRpLX----","type":"function","name":"test_add_graph_docs_inc_src_err","defined_in":"tests_unit_tests_graphs_test_neo4j_graph_py","lineno":285,"source":"def test_add_graph_docs_inc_src_err(mock_neo4j_driver: MagicMock) -> None:\n    \"\"\"Tests an error is raised when using add_graph_documents with include_source set\n    to True and a document is missing a source.\"\"\"\n    graph = Neo4jGraph(\n        url=\"bolt://localhost:7687\",\n        username=\"neo4j\",\n        password=\"password\",\n        refresh_schema=False,\n    )\n    node_1 = Node(id=1)\n    node_2 = Node(id=2)\n    rel = Relationship(source=node_1, target=node_2, type=\"REL\")\n\n    graph_doc = GraphDocument(\n        nodes=[node_1, node_2],\n        relationships=[rel],\n    )\n    with pytest.raises(TypeError) as exc_info:\n        graph.add_graph_documents(graph_documents=[graph_doc], include_source=True)\n\n    assert (\n        \"include_source is set to True, but at least one document has no `source`.\"\n        in str(exc_info.value)\n    )","docstring":"Tests an error is raised when using add_graph_documents with include_source set\nto True and a document is missing a source.","args":[{"arg":"mock_neo4j_driver","type":"MagicMock"}],"return_type":"None","control_flow":[],"reason":"it is about a test function that verifies an error is raised when add_graph_documents is called with include_source=True and some documents lack a source, by creating a Neo4jGraph instance, nodes, relationships, and a GraphDocument, then asserting a TypeError is raised with an appropriate message.","reason_kor":"include_source=True 상태에서 소스가 없는 문서가 있을 경우 add_graph_documents 호출 시 오류가 발생하는지, Neo4jGraph 인스턴스 및 관련 노드, 관계, GraphDocument를 생성해 TypeError 발생 여부 검증"},{"_key":"tests_unit_tests_graphs_test_neo4j_graph_py_test_close_method_removes_driver","_id":"nodes/tests_unit_tests_graphs_test_neo4j_graph_py_test_close_method_removes_driver","_rev":"_jzRpLXK---","type":"function","name":"test_close_method_removes_driver","defined_in":"tests_unit_tests_graphs_test_neo4j_graph_py","lineno":75,"source":"def test_close_method_removes_driver(mock_neo4j_driver: MagicMock) -> None:\n    \"\"\"Test that close method removes the _driver attribute.\"\"\"\n    graph = Neo4jGraph(\n        url=\"bolt://localhost:7687\", username=\"neo4j\", password=\"password\"\n    )\n\n    # Store a reference to the original driver\n    original_driver = graph._driver\n    assert isinstance(original_driver.close, MagicMock)\n\n    # Call close method\n    graph.close()\n\n    # Verify driver.close was called\n    original_driver.close.assert_called_once()\n\n    # Verify _driver attribute is removed\n    assert not hasattr(graph, \"_driver\")\n\n    # Verify second close does not raise an error\n    graph.close()","docstring":"Test that close method removes the _driver attribute.","args":[{"arg":"mock_neo4j_driver","type":"MagicMock"}],"return_type":"None","control_flow":[],"reason":"it is about a test setup for Neo4jGraph, using a mock driver, with assertions to verify that the close method calls the driver's close function, removes the _driver attribute from the graph object, and handles multiple close calls gracefully.","reason_kor":"모킹된 드라이버를 사용해 Neo4jGraph 테스트 환경을 설정하고, close 메서드가 드라이버의 close 함수 호출 및 '_driver' 속성 제거, 다중 close 호출 처리 가능 여부 단언"},{"_key":"tests_unit_tests_graphs_test_neo4j_graph_py_test_driver_state_management","_id":"nodes/tests_unit_tests_graphs_test_neo4j_graph_py_test_driver_state_management","_rev":"_jzRpLXW---","type":"function","name":"test_driver_state_management","defined_in":"tests_unit_tests_graphs_test_neo4j_graph_py","lineno":29,"source":"def test_driver_state_management(mock_neo4j_driver: MagicMock) -> None:\n    \"\"\"Comprehensive test for driver state management.\"\"\"\n    # Create graph instance\n    graph = Neo4jGraph(\n        url=\"bolt://localhost:7687\", username=\"neo4j\", password=\"password\"\n    )\n\n    # Store original driver\n    original_driver = graph._driver\n    assert isinstance(original_driver.close, MagicMock)\n\n    # Test initial state\n    assert hasattr(graph, \"_driver\")\n\n    # First close\n    graph.close()\n    original_driver.close.assert_called_once()\n    assert not hasattr(graph, \"_driver\")\n\n    # Verify methods raise error when driver is closed\n    with pytest.raises(\n        RuntimeError,\n        match=\"Cannot perform operations - Neo4j connection has been closed\",\n    ):\n        graph.query(\"RETURN 1\")\n\n    with pytest.raises(\n        RuntimeError,\n        match=\"Cannot perform operations - Neo4j connection has been closed\",\n    ):\n        graph.refresh_schema()","docstring":"Comprehensive test for driver state management.","args":[{"arg":"mock_neo4j_driver","type":"MagicMock"}],"return_type":"None","control_flow":[],"reason":"it is about the creation of a Neo4j graph object, checks initial driver state, closes the driver, verifies that the driver close method is called, removes the driver attribute, and then ensures that subsequent operations raise a RuntimeError indicating the connection is closed.","reason_kor":"Neo4j 그래프 객체를 생성하고, 초기 드라이버 상태 점검, 드라이버 닫기, 드라이버 close 메서드 호출 검증, 드라이버 속성 제거 및 이후 동작 시 연결 종료 RuntimeError 발생 여부 확인"},{"_key":"tests_unit_tests_graphs_test_neo4j_graph_py_test_get_schema","_id":"nodes/tests_unit_tests_graphs_test_neo4j_graph_py_test_get_schema","_rev":"_jzRpLXi---","type":"function","name":"test_get_schema","defined_in":"tests_unit_tests_graphs_test_neo4j_graph_py","lineno":273,"source":"def test_get_schema(mock_neo4j_driver: MagicMock) -> None:\n    \"\"\"Tests the get_schema property.\"\"\"\n    graph = Neo4jGraph(\n        url=\"bolt://localhost:7687\",\n        username=\"neo4j\",\n        password=\"password\",\n        refresh_schema=False,\n    )\n    graph.schema = \"test\"\n    assert graph.get_schema == \"test\"","docstring":"Tests the get_schema property.","args":[{"arg":"mock_neo4j_driver","type":"MagicMock"}],"return_type":"None","control_flow":[],"reason":"it is about creating a Neo4jGraph instance with specific connection parameters, setting its schema attribute to 'test', and asserting that the get_schema property correctly returns the 'test' value","reason_kor":"특정 연결 매개변수로 Neo4jGraph 인스턴스를 생성하고, 스키마 속성을 'test'로 설정한 후 get_schema 속성이 'test'를 올바르게 반환하는지 검증"},{"_key":"tests_unit_tests_graphs_test_neo4j_graph_py_test_init_apoc_procedure_not_found","_id":"nodes/tests_unit_tests_graphs_test_neo4j_graph_py_test_init_apoc_procedure_not_found","_rev":"_jzRpLXu---","type":"function","name":"test_init_apoc_procedure_not_found","defined_in":"tests_unit_tests_graphs_test_neo4j_graph_py","lineno":148,"source":"def test_init_apoc_procedure_not_found(\n    mock_neo4j_driver: MagicMock,\n) -> None:\n    \"\"\"Test an error is raised when APOC is not installed.\"\"\"\n    with patch(\"langchain_neo4j.Neo4jGraph.refresh_schema\") as mock_refresh_schema:\n        err = ClientError()\n        err.code = \"Neo.ClientError.Procedure.ProcedureNotFound\"\n        mock_refresh_schema.side_effect = err\n        with pytest.raises(ValueError) as exc_info:\n            Neo4jGraph(url=\"bolt://localhost:7687\", username=\"\", password=\"\")\n        assert \"Could not use APOC procedures.\" in str(exc_info.value)","docstring":"Test an error is raised when APOC is not installed.","args":[{"arg":"mock_neo4j_driver","type":"MagicMock"}],"return_type":"None","control_flow":[],"reason":"it is about the use of mocking a Neo4j driver and patching a method to simulate the absence of APOC procedures, then it checks that initializing Neo4jGraph raises a ValueError with a specific message when the procedure is not found.","reason_kor":"APOC 프로시저 부재를 시뮬레이션하기 위해 Neo4j 드라이버 모킹 및 patch를 사용, 프로시저 미존재 시 Neo4jGraph 초기화가 특정 메시지와 함께 ValueError를 발생시키는지 검증"},{"_key":"tests_unit_tests_graphs_test_neo4j_graph_py_test_init_refresh_schema_other_err","_id":"nodes/tests_unit_tests_graphs_test_neo4j_graph_py_test_init_refresh_schema_other_err","_rev":"_jzRpLX2---","type":"function","name":"test_init_refresh_schema_other_err","defined_in":"tests_unit_tests_graphs_test_neo4j_graph_py","lineno":161,"source":"def test_init_refresh_schema_other_err(\n    mock_neo4j_driver: MagicMock,\n) -> None:\n    \"\"\"Test any other ClientErrors raised when calling refresh_schema in __init__ are\n    re-raised.\"\"\"\n    with patch(\"langchain_neo4j.Neo4jGraph.refresh_schema\") as mock_refresh_schema:\n        err = ClientError()\n        err.code = \"other_error\"\n        mock_refresh_schema.side_effect = err\n        with pytest.raises(ClientError) as exc_info:\n            Neo4jGraph(url=\"bolt://localhost:7687\", username=\"\", password=\"\")\n        assert exc_info.value == err","docstring":"Test any other ClientErrors raised when calling refresh_schema in __init__ are\nre-raised.","args":[{"arg":"mock_neo4j_driver","type":"MagicMock"}],"return_type":"None","control_flow":[],"reason_kor":"Neo4jGraph 초기화 중 refresh_schema 메서드 호출에서 ClientError가 발생하는 상황을 모킹 및 patch로 시뮬레이션하고, 초기화 시 이 오류가 올바르게 재발생하는지 검증","reason":"it is about mocking and patching to simulate a ClientError during the refresh_schema method call within the Neo4jGraph initialization, then verifying that this error is properly re-raised when instantiating Neo4jGraph."},{"_key":"tests_unit_tests_graphs_test_neo4j_graph_py_test_multiple_close_calls_safe","_id":"nodes/tests_unit_tests_graphs_test_neo4j_graph_py_test_multiple_close_calls_safe","_rev":"_jzRpLYC---","type":"function","name":"test_multiple_close_calls_safe","defined_in":"tests_unit_tests_graphs_test_neo4j_graph_py","lineno":98,"source":"def test_multiple_close_calls_safe(mock_neo4j_driver: MagicMock) -> None:\n    \"\"\"Test that multiple close calls do not raise errors.\"\"\"\n    graph = Neo4jGraph(\n        url=\"bolt://localhost:7687\", username=\"neo4j\", password=\"password\"\n    )\n\n    # Store a reference to the original driver\n    original_driver = graph._driver\n    assert isinstance(original_driver.close, MagicMock)\n\n    # First close\n    graph.close()\n    original_driver.close.assert_called_once()\n\n    # Verify _driver attribute is removed\n    assert not hasattr(graph, \"_driver\")\n\n    # Second close should not raise an error\n    graph.close()","docstring":"Test that multiple close calls do not raise errors.","args":[{"arg":"mock_neo4j_driver","type":"MagicMock"}],"return_type":"None","control_flow":[],"reason_kor":"Neo4jGraph 인스턴스를 생성하고, 드라이버 확인, close 메서드를 두 번 호출, 드라이버가 올바르게 닫히고 제거되었으며 두 번째 호출 시 오류 없음 확인, 다중 close 안전성 검증","reason":"it is about the creation of a Neo4jGraph instance, verifying its driver, calling close method twice, checking that the driver is properly closed and removed, and ensuring no errors occur on the second call, demonstrating safe handling of multiple close calls."},{"_key":"tests_unit_tests_graphs_test_neo4j_graph_py_test_neo4j_graph_del_method","_id":"nodes/tests_unit_tests_graphs_test_neo4j_graph_py_test_neo4j_graph_del_method","_rev":"_jzRpLYO---","type":"function","name":"test_neo4j_graph_del_method","defined_in":"tests_unit_tests_graphs_test_neo4j_graph_py","lineno":62,"source":"def test_neo4j_graph_del_method(mock_neo4j_driver: MagicMock) -> None:\n    \"\"\"Test the __del__ method.\"\"\"\n    with patch.object(Neo4jGraph, \"close\") as mock_close:\n        graph = Neo4jGraph(\n            url=\"bolt://localhost:7687\", username=\"neo4j\", password=\"password\"\n        )\n        # Ensure exceptions are suppressed when the graph's destructor is called\n        mock_close.side_effect = Exception()\n        mock_close.assert_not_called()\n        graph.__del__()\n        mock_close.assert_called_once()","docstring":"Test the __del__ method.","args":[{"arg":"mock_neo4j_driver","type":"MagicMock"}],"return_type":"None","control_flow":[],"reason_kor":"Neo4jGraph 클래스 close 메서드 모킹과 소멸자 동작 테스트를 결합해 close가 정확히 한 번 호출되고 close 내 예외가 우아하게 처리되는지 확인","reason":"it is about mocking of the Neo4jGraph class's close method with testing the destructor behavior to ensure that the close method is called exactly once and exceptions in close are handled gracefully."},{"_key":"tests_unit_tests_graphs_test_neo4j_graph_py_test_neo4j_graph_init_driver_config_err","_id":"nodes/tests_unit_tests_graphs_test_neo4j_graph_py_test_neo4j_graph_init_driver_config_err","_rev":"_jzRpLYa---","type":"function","name":"test_neo4j_graph_init_driver_config_err","defined_in":"tests_unit_tests_graphs_test_neo4j_graph_py","lineno":131,"source":"def test_neo4j_graph_init_driver_config_err() -> None:\n    \"\"\"Test the __init__ method with an incorrect driver config.\"\"\"\n    with patch(\"neo4j.GraphDatabase.driver\", autospec=True) as mock_driver:\n        mock_driver_instance = MagicMock()\n        mock_driver.return_value = mock_driver_instance\n        err = ConfigurationError()\n        mock_driver_instance.verify_connectivity.side_effect = err\n        with pytest.raises(ValueError) as exc_info:\n            Neo4jGraph(\n                url=\"bolt://localhost:7687\",\n                username=\"username\",\n                password=\"password\",\n                refresh_schema=False,\n            )\n        assert \"Please ensure that the driver config is correct\" in str(exc_info.value)","docstring":"Test the __init__ method with an incorrect driver config.","args":[],"return_type":"None","control_flow":[],"reason_kor":"Neo4j 드라이버 모킹으로 구성 오류 시뮬레이션 후 Neo4jGraph 클래스가 초기화 중 드라이버 연결 검증 실패 시 올바른 메시지의 ValueError를 발생시키는지 테스트","reason":"it is about the mocking of neo4j driver to simulate a configuration error, then tested that the Neo4jGraph class raises a ValueError with the correct message when driver connectivity verification fails during initialization"},{"_key":"tests_unit_tests_graphs_test_neo4j_graph_py_test_neo4j_graph_init_with_empty_credentials","_id":"nodes/tests_unit_tests_graphs_test_neo4j_graph_py_test_neo4j_graph_init_with_empty_credentials","_rev":"_jzRpLYm---","type":"function","name":"test_neo4j_graph_init_with_empty_credentials","defined_in":"tests_unit_tests_graphs_test_neo4j_graph_py","lineno":119,"source":"def test_neo4j_graph_init_with_empty_credentials() -> None:\n    \"\"\"Test the __init__ method when no credentials have been provided.\"\"\"\n    with patch(\"neo4j.GraphDatabase.driver\", autospec=True) as mock_driver:\n        mock_driver_instance = MagicMock()\n        mock_driver.return_value = mock_driver_instance\n        mock_driver_instance.verify_connectivity.return_value = None\n        Neo4jGraph(\n            url=\"bolt://localhost:7687\", username=\"\", password=\"\", refresh_schema=False\n        )\n        mock_driver.assert_called_with(\"bolt://localhost:7687\", auth=None)","docstring":"Test the __init__ method when no credentials have been provided.","args":[],"return_type":"None","control_flow":[],"reason_kor":"Neo4jGraph **init** 메서드에 대한 단위 테스트로, neo4j.GraphDatabase.driver가 올바른 URL과 인증 매개변수로 호출되는지 패치 및 모킹으로 검증","reason":"it is about a unit test for Neo4jGraph's __init__ method with mocking, patching neo4j.GraphDatabase.driver to verify that it is called with the correct URL and authentication parameters when credentials are empty."},{"_key":"tests_unit_tests_graphs_test_neo4j_graph_py_test_query_fallback_execution","_id":"nodes/tests_unit_tests_graphs_test_neo4j_graph_py_test_query_fallback_execution","_rev":"_jzRpLYy---","type":"function","name":"test_query_fallback_execution","defined_in":"tests_unit_tests_graphs_test_neo4j_graph_py","lineno":175,"source":"def test_query_fallback_execution(mock_neo4j_driver: MagicMock) -> None:\n    \"\"\"Test the fallback to allow for implicit transactions in query.\"\"\"\n    err = Neo4jError()\n    err.code = \"Neo.DatabaseError.Statement.ExecutionFailed\"\n    err.message = \"in an implicit transaction\"\n    mock_neo4j_driver.execute_query.side_effect = err\n    graph = Neo4jGraph(\n        url=\"bolt://localhost:7687\",\n        username=\"neo4j\",\n        password=\"password\",\n        database=\"test_db\",\n        sanitize=True,\n        refresh_schema=False,\n    )\n    mock_session = MagicMock()\n    mock_result = MagicMock()\n    mock_result.data.return_value = {\n        \"key1\": \"value1\",\n        \"oversized_list\": list(range(LIST_LIMIT + 1)),\n    }\n    mock_session.run.return_value = [mock_result]\n    mock_neo4j_driver.session.return_value.__enter__.return_value = mock_session\n    mock_neo4j_driver.session.return_value.__exit__.return_value = None\n    query = \"MATCH (n) RETURN n;\"\n    params = {\"param1\": \"value1\"}\n    json_data = graph.query(query, params)\n    mock_neo4j_driver.session.assert_called_with(database=\"test_db\")\n    called_args, _ = mock_session.run.call_args\n    called_query = called_args[0]\n    assert called_query.text == query\n    assert called_query.timeout == graph.timeout\n    assert called_args[1] == params\n    assert json_data == [{\"key1\": \"value1\"}]","docstring":"Test the fallback to allow for implicit transactions in query.","args":[{"arg":"mock_neo4j_driver","type":"MagicMock"}],"return_type":"None","control_flow":[],"reason_kor":"Neo4j 드라이버와 세션을 모킹해 오류를 시뮬레이션하고, query 메서드의 암묵적 트랜잭션 폴백이 올바르게 처리되고 데이터를 반환하는지 테스트","reason":"it is about mocking of Neo4j driver and session to simulate an error, then tested the query method's fallback for implicit transactions, ensuring proper handling and data retrieval based on the mock setup."},{"_key":"tests_unit_tests_graphs_test_neo4j_graph_py_test_refresh_schema_handles_client_error","_id":"nodes/tests_unit_tests_graphs_test_neo4j_graph_py_test_refresh_schema_handles_client_error","_rev":"_jzRpLZ----","type":"function","name":"test_refresh_schema_handles_client_error","defined_in":"tests_unit_tests_graphs_test_neo4j_graph_py","lineno":210,"source":"def test_refresh_schema_handles_client_error(mock_neo4j_driver: MagicMock) -> None:\n    \"\"\"Test refresh schema handles a client error which might arise due to a user\n    not having access to schema information\"\"\"\n\n    graph = Neo4jGraph(\n        url=\"bolt://localhost:7687\",\n        username=\"neo4j\",\n        password=\"password\",\n        database=\"test_db\",\n        refresh_schema=False,\n    )\n    node_properties = [\n        Record(\n            {\n                \"output\": {\n                    \"properties\": [{\"property\": \"property_a\", \"type\": \"STRING\"}],\n                    \"label\": \"LabelA\",\n                }\n            }\n        )\n    ]\n    relationships_properties = [\n        Record(\n            {\n                \"output\": {\n                    \"type\": \"REL_TYPE\",\n                    \"properties\": [{\"property\": \"rel_prop\", \"type\": \"STRING\"}],\n                }\n            }\n        )\n    ]\n    relationships = [\n        Record({\"output\": {\"start\": \"LabelA\", \"type\": \"REL_TYPE\", \"end\": \"LabelB\"}}),\n        Record({\"output\": {\"start\": \"LabelA\", \"type\": \"REL_TYPE\", \"end\": \"LabelC\"}}),\n    ]\n\n    mock_neo4j_driver.execute_query.side_effect = [\n        MagicMock(\n            records=node_properties, summary=MagicMock(spec=ResultSummary), keys=[]\n        ),\n        MagicMock(\n            records=relationships_properties,\n            summary=MagicMock(spec=ResultSummary),\n            keys=[],\n        ),\n        MagicMock(\n            records=relationships, summary=MagicMock(spec=ResultSummary), keys=[]\n        ),\n        ClientError(\"Mock ClientError\"),\n    ]\n    graph.refresh_schema()\n\n    # Assertions\n    # Ensure constraints and indexes are empty due to the ClientError\n    assert graph.structured_schema[\"metadata\"][\"constraint\"] == []\n    assert graph.structured_schema[\"metadata\"][\"index\"] == []\n\n    # Ensure the query method was called as expected\n    assert mock_neo4j_driver.execute_query.call_count == 4\n    calls = mock_neo4j_driver.execute_query.call_args_list\n    assert any(call.args[0].text == \"SHOW CONSTRAINTS\" for call in calls)","docstring":"Test refresh schema handles a client error which might arise due to a user\nnot having access to schema information","args":[{"arg":"mock_neo4j_driver","type":"MagicMock"}],"return_type":"None","control_flow":[],"reason_kor":"Neo4jGraph 인스턴스 설정, 쿼리 응답 모킹(클라이언트 오류 발생 포함), refresh_schema 호출 및 오류 우아한 처리, 제약 조건 및 인덱스가 빈 상태 유지, 쿼리 수행 검증","reason":"it is about setting up a Neo4jGraph instance, mocking query responses including raising a ClientError, calling the refresh_schema method which handles the error gracefully, and then verifying that constraints and indexes remain empty and that the appropriate queries were made."},{"_key":"tests_unit_tests_query_constructors","_id":"nodes/tests_unit_tests_query_constructors","_rev":"_jzRpEge---","type":"directory","name":"query_constructors","path":"C:\\workspace\\langchain-neo4j\\tests\\unit_tests\\query_constructors"},{"_key":"tests_unit_tests_query_constructors___init___py","_id":"nodes/tests_unit_tests_query_constructors___init___py","_rev":"_jzRpEly---","type":"file","name":"__init__.py","path":"C:\\workspace\\langchain-neo4j\\tests\\unit_tests\\query_constructors\\__init__.py"},{"_key":"tests_unit_tests_query_constructors_test_neo4j_py","_id":"nodes/tests_unit_tests_query_constructors_test_neo4j_py","_rev":"_jzRpEg2---","type":"file","name":"test_neo4j.py","path":"C:\\workspace\\langchain-neo4j\\tests\\unit_tests\\query_constructors\\test_neo4j.py"},{"_key":"tests_unit_tests_query_constructors_test_neo4j_py_test_visit_comparison","_id":"nodes/tests_unit_tests_query_constructors_test_neo4j_py_test_visit_comparison","_rev":"_jzRpLZK---","type":"function","name":"test_visit_comparison","defined_in":"tests_unit_tests_query_constructors_test_neo4j_py","lineno":16,"source":"def test_visit_comparison() -> None:\n    comp = Comparison(comparator=Comparator.LT, attribute=\"foo\", value=[\"1\", \"2\"])\n    expected = {\"foo\": {\"$lt\": [\"1\", \"2\"]}}\n    actual = DEFAULT_TRANSLATOR.visit_comparison(comp)\n    assert expected == actual","docstring":null,"args":[],"return_type":"None","control_flow":[],"reason_kor":"less-than 비교자, 'foo' 속성, 값 리스트를 가진 Comparison 객체 생성 후, MongoDB 쿼리와 유사한 딕셔너리 포맷으로 변환하여 'foo': {'$lt': 리스트} 구조를 생성하고, 변환이 예상 구조와 일치하는지 단언","reason":"It creates a Comparison object with a less-than comparator, an attribute 'foo', and a list of values. Then it translates this comparison into a dictionary format suitable for a query, specifically mapping 'foo' to a '$lt' key with the list as value, and asserts this translation matches the expected structure."},{"_key":"tests_unit_tests_query_constructors_test_neo4j_py_test_visit_operation","_id":"nodes/tests_unit_tests_query_constructors_test_neo4j_py_test_visit_operation","_rev":"_jzRpLZW---","type":"function","name":"test_visit_operation","defined_in":"tests_unit_tests_query_constructors_test_neo4j_py","lineno":23,"source":"def test_visit_operation() -> None:\n    op = Operation(\n        operator=Operator.AND,\n        arguments=[\n            Comparison(comparator=Comparator.LT, attribute=\"foo\", value=2),\n            Comparison(comparator=Comparator.EQ, attribute=\"bar\", value=\"baz\"),\n            Comparison(comparator=Comparator.LT, attribute=\"abc\", value=[\"1\", \"2\"]),\n        ],\n    )\n    expected = {\n        \"$and\": [\n            {\"foo\": {\"$lt\": 2}},\n            {\"bar\": {\"$eq\": \"baz\"}},\n            {\"abc\": {\"$lt\": [\"1\", \"2\"]}},\n        ]\n    }\n    actual = DEFAULT_TRANSLATOR.visit_operation(op)\n    assert expected == actual","docstring":null,"args":[],"return_type":"None","control_flow":[],"reason_kor":"특정 비교자와 속성을 가진 Operation 객체 생성, 방문자 메서드를 통해 AND 논리 연산자를 $and 키로 매핑하고 각 비교를 적절한 키-값 구조로 변환하여 MongoDB 쿼리 유사 딕셔너리 생성","reason":"it is about the creation of an Operation object with specific comparators and attributes, then used a visitor method to translate the operation into a dictionary format that resembles a MongoDB query, by mapping the logical operator AND to an $and key and translating each comparison into the appropriate key-value structure."},{"_key":"tests_unit_tests_query_constructors_test_neo4j_py_test_visit_structured_query","_id":"nodes/tests_unit_tests_query_constructors_test_neo4j_py_test_visit_structured_query","_rev":"_jzRpLZe---","type":"function","name":"test_visit_structured_query","defined_in":"tests_unit_tests_query_constructors_test_neo4j_py","lineno":43,"source":"def test_visit_structured_query() -> None:\n    query = \"What is the capital of France?\"\n    structured_query = StructuredQuery(\n        query=query,\n        filter=None,\n    )\n    expected: Tuple[str, Dict] = (query, {})\n    actual = DEFAULT_TRANSLATOR.visit_structured_query(structured_query)\n    assert expected == actual\n\n    comp = Comparison(comparator=Comparator.LT, attribute=\"foo\", value=[\"1\", \"2\"])\n    expected = (\n        query,\n        {\"filter\": {\"foo\": {\"$lt\": [\"1\", \"2\"]}}},\n    )\n    structured_query = StructuredQuery(\n        query=query,\n        filter=comp,\n    )\n    actual = DEFAULT_TRANSLATOR.visit_structured_query(structured_query)\n    assert expected == actual\n\n    op = Operation(\n        operator=Operator.AND,\n        arguments=[\n            Comparison(comparator=Comparator.LT, attribute=\"foo\", value=2),\n            Comparison(comparator=Comparator.EQ, attribute=\"bar\", value=\"baz\"),\n            Comparison(comparator=Comparator.LT, attribute=\"abc\", value=[\"1\", \"2\"]),\n        ],\n    )\n    structured_query = StructuredQuery(\n        query=query,\n        filter=op,\n    )\n    expected = (\n        query,\n        {\n            \"filter\": {\n                \"$and\": [\n                    {\"foo\": {\"$lt\": 2}},\n                    {\"bar\": {\"$eq\": \"baz\"}},\n                    {\"abc\": {\"$lt\": [\"1\", \"2\"]}},\n                ]\n            }\n        },\n    )\n    actual = DEFAULT_TRANSLATOR.visit_structured_query(structured_query)\n    assert expected == actual","docstring":null,"args":[],"return_type":"None","control_flow":[],"reason_kor":"null 필터, 비교, 연산 등 다양한 구조화된 쿼리 컴포넌트를 방문자 visit 메서드로 처리해 예상 튜플 출력을 생성하는 테스트 결합","reason":"it is about different structured query components (null filter, comparison, operation) with a translator's visit method to produce expected tuple outputs for each case"},{"_key":"tests_unit_tests_test_imports_py","_id":"nodes/tests_unit_tests_test_imports_py","_rev":"_jzRpDYa---","type":"file","name":"test_imports.py","path":"C:\\workspace\\langchain-neo4j\\tests\\unit_tests\\test_imports.py"},{"_key":"tests_unit_tests_test_imports_py_test_all_imports","_id":"nodes/tests_unit_tests_test_imports_py_test_all_imports","_rev":"_jzRpLZq---","type":"function","name":"test_all_imports","defined_in":"tests_unit_tests_test_imports_py","lineno":12,"source":"def test_all_imports() -> None:\n    assert sorted(EXPECTED_ALL) == sorted(__all__)","docstring":null,"args":[],"return_type":"None","control_flow":[],"reason_kor":"EXPECTED_ALL과 __all__의 정렬된 리스트를 단언해 모든 예상 모듈이나 컴포넌트가 올바르게 임포트 및 등록되었는지 확인","reason":"It is about import statement checks by asserting that the sorted list EXPECTED_ALL matches the sorted list __all__, ensuring all expected modules or components are properly imported and registered."},{"_key":"tests_unit_tests_vectorstores","_id":"nodes/tests_unit_tests_vectorstores","_rev":"_jzRpEmS---","type":"directory","name":"vectorstores","path":"C:\\workspace\\langchain-neo4j\\tests\\unit_tests\\vectorstores"},{"_key":"tests_unit_tests_vectorstores___init___py","_id":"nodes/tests_unit_tests_vectorstores___init___py","_rev":"_jzRpFie---","type":"file","name":"__init__.py","path":"C:\\workspace\\langchain-neo4j\\tests\\unit_tests\\vectorstores\\__init__.py"},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py","_rev":"_jzRpEmy---","type":"file","name":"test_neo4j.py","path":"C:\\workspace\\langchain-neo4j\\tests\\unit_tests\\vectorstores\\test_neo4j.py"},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_mock_vector_store","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_mock_vector_store","_rev":"_jzRpLZ2---","type":"function","name":"mock_vector_store","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":20,"source":"def mock_vector_store() -> Neo4jVector:\n    mock_neo4j = MagicMock()\n    mock_driver_instance = MagicMock()\n    mock_driver_instance.verify_connectivity.return_value = None\n    mock_driver_instance.execute_query.return_value = (\n        [{\"versions\": [\"5.23.0\"], \"edition\": \"enterprise\"}],\n        None,\n        None,\n    )\n    mock_neo4j.GraphDatabase.driver.return_value = mock_driver_instance\n    mock_neo4j.exceptions.ServiceUnavailable = Exception\n    mock_neo4j.exceptions.AuthError = Exception\n\n    with patch(\n        \"langchain_neo4j.vectorstores.neo4j_vector.neo4j\",\n        new=mock_neo4j,\n    ):\n        with patch.object(\n            Neo4jVector,\n            \"query\",\n            return_value=[{\"versions\": [\"5.23.0\"], \"edition\": \"enterprise\"}],\n        ):\n            vector_store = Neo4jVector(\n                embedding=MagicMock(),\n                url=\"bolt://localhost:7687\",\n                username=\"neo4j\",\n                password=\"password\",\n            )\n\n        vector_store.node_label = \"Chunk\"\n        vector_store.embedding_node_property = \"embedding\"\n        vector_store.text_node_property = \"text\"\n\n        return vector_store","docstring":null,"args":[],"return_type":"Neo4jVector","control_flow":[],"reason_kor":"Neo4j 드라이버 인스턴스와 예외를 모킹 및 패치해 Neo4j 데이터베이스 동작을 시뮬레이션, 모킹된 의존성으로 Neo4jVector 인스턴스를 생성하고 테스트용 노드 속성을 설정","reason":"it is about mocking of Neo4j driver instance and exceptions with patching of neo4j module to simulate Neo4j database behavior, then instantiated Neo4jVector with mocked dependencies, setting node properties for testing."},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_neo4j_vector_factory","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_neo4j_vector_factory","_rev":"_jzRpLaC---","type":"function","name":"neo4j_vector_factory","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":57,"source":"def neo4j_vector_factory() -> Any:\n    def _create_vector_store(\n        method: Optional[str] = None,\n        texts: Optional[list[str]] = None,\n        text_embeddings: Optional[list[tuple[str, list[float]]]] = None,\n        query_return_value: Optional[dict] = None,\n        verify_connectivity_side_effect: Optional[Exception] = None,\n        auth_error_class: Type[Exception] = Exception,\n        service_unavailable_class: Type[Exception] = Exception,\n        search_type: SearchType = SearchType.VECTOR,\n        **kwargs: Any,\n    ) -> Any:\n        mock_neo4j = MagicMock()\n        mock_driver_instance = MagicMock()\n\n        # Configure verify_connectivity\n        if verify_connectivity_side_effect:\n            mock_driver_instance.verify_connectivity.side_effect = (\n                verify_connectivity_side_effect\n            )\n        else:\n            mock_driver_instance.verify_connectivity.return_value = None\n\n        # Configure execute_query\n        if query_return_value is not None:\n            mock_driver_instance.execute_query.return_value = (\n                [query_return_value],\n                None,\n                None,\n            )\n        else:\n            mock_driver_instance.execute_query.return_value = (\n                [{\"versions\": [\"5.23.0\"], \"edition\": \"enterprise\"}],\n                None,\n                None,\n            )\n\n        # Assign the mocked driver to GraphDatabase.driver\n        mock_neo4j.GraphDatabase.driver.return_value = mock_driver_instance\n        mock_neo4j.exceptions.ServiceUnavailable = service_unavailable_class\n        mock_neo4j.exceptions.AuthError = auth_error_class\n\n        with patch(\n            \"langchain_neo4j.vectorstores.neo4j_vector.neo4j\",\n            new=mock_neo4j,\n        ):\n            query_return = (\n                [query_return_value]\n                if query_return_value\n                else [{\"versions\": [\"5.23.0\"], \"edition\": \"enterprise\"}]\n            )\n            with patch.object(Neo4jVector, \"query\", return_value=query_return):\n                embedding = kwargs.pop(\"embedding\", MagicMock())\n                common_kwargs = {\n                    \"embedding\": embedding,\n                    \"url\": \"bolt://localhost:7687\",\n                    \"username\": \"neo4j\",\n                    \"password\": \"password\",\n                    \"search_type\": search_type,\n                    **kwargs,\n                }\n\n                if texts and method == \"from_texts\":\n                    vector_store = Neo4jVector.from_texts(texts=texts, **common_kwargs)\n                elif text_embeddings and method == \"from_embeddings\":\n                    vector_store = Neo4jVector.from_embeddings(\n                        text_embeddings=text_embeddings, **common_kwargs\n                    )\n                elif method == \"from_existing_index\":\n                    vector_store = Neo4jVector.from_existing_index(**common_kwargs)\n                elif method == \"from_existing_relationship_index\":\n                    vector_store = Neo4jVector.from_existing_relationship_index(\n                        **common_kwargs\n                    )\n                elif method == \"from_existing_graph\":\n                    vector_store = Neo4jVector.from_existing_graph(**common_kwargs)\n                else:\n                    vector_store = Neo4jVector(**common_kwargs)\n\n                vector_store.node_label = \"Chunk\"\n                vector_store.embedding_node_property = \"embedding\"\n                vector_store.text_node_property = \"text\"\n                return vector_store\n\n    return _create_vector_store","docstring":null,"args":[],"return_type":"Any","control_flow":[{"type":"if","lineno":73},{"type":"if","lineno":81},{"type":"if","lineno":119},{"type":"if","lineno":121},{"type":"if","lineno":125},{"type":"if","lineno":127},{"type":"if","lineno":131}],"reason_kor":"neo4j_vector_factory라는 팩토리 함수 생성 및 반환, 내부 함수는 선택적 인자에 기반해 모킹된 Neo4j 데이터베이스 연결과 동작을 설정, neo4j 모듈과 Neo4jVector 클래스 메서드 패치, 입력 매개변수에 따라 적절한 클래스 메서드 호출, 특정 노드 및 속성 라벨로 Neo4jVector 인스턴스를 초기화, 구성, 반환합니다.","reason":"it is about a factory function `neo4j_vector_factory` that creates and returns another function `_create_vector_store`. this inner function sets up mock neo4j database connections and configures their behaviors based on optional arguments, patches the neo4j module and `Neo4jVector` class methods for testing purposes, processes input parameters to determine which class method to invoke (`from_texts`, `from_embeddings`, etc.), and finally initializes, configures, and returns a `Neo4jVector` instance with specific node and property labels."},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_build_delete_query_version_below_5_23","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_build_delete_query_version_below_5_23","_rev":"_jzRpLaO---","type":"function","name":"test_build_delete_query_version_below_5_23","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":289,"source":"def test_build_delete_query_version_below_5_23(mock_vector_store: Neo4jVector) -> None:\n    mock_vector_store.neo4j_version_is_5_23_or_above = False\n    expected_query = (\n        f\"MATCH (n:`{mock_vector_store.node_label}`) \"\n        \"CALL { WITH n DETACH DELETE n } \"\n        \"IN TRANSACTIONS OF 10000 ROWS;\"\n    )\n\n    actual_query = mock_vector_store._build_delete_query()\n\n    assert actual_query == expected_query","docstring":null,"args":[{"arg":"mock_vector_store","type":"Neo4jVector"}],"return_type":"None","control_flow":[],"reason_kor":"Neo4j 버전 5.23 미만에서 올바른 Cypher 삭제 쿼리 문자열이 생성되는지 검증하는 테스트.","reason":"Test verifying correct Cypher delete query string is generated for Neo4j versions below 5.23."},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_build_delete_query_version_is_or_above_5_23","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_build_delete_query_version_is_or_above_5_23","_rev":"_jzRpLaa---","type":"function","name":"test_build_delete_query_version_is_or_above_5_23","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":274,"source":"def test_build_delete_query_version_is_or_above_5_23(\n    mock_vector_store: Neo4jVector,\n) -> None:\n    mock_vector_store.neo4j_version_is_5_23_or_above = True\n    expected_query = (\n        f\"MATCH (n:`{mock_vector_store.node_label}`) \"\n        \"CALL (n) { DETACH DELETE n } \"\n        \"IN TRANSACTIONS OF 10000 ROWS;\"\n    )\n\n    actual_query = mock_vector_store._build_delete_query()\n\n    assert actual_query == expected_query","docstring":null,"args":[{"arg":"mock_vector_store","type":"Neo4jVector"}],"return_type":"None","control_flow":[],"reason_kor":"Neo4j 버전 5.23 이상에서 올바른 Cypher 삭제 쿼리 문자열이 생성되는지 검증하는 테스트.","reason":"Test verifying correct Cypher delete query string is generated for Neo4j versions 5.23 and above."},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_build_import_query_version_below_5_23","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_build_import_query_version_below_5_23","_rev":"_jzRpLam---","type":"function","name":"test_build_import_query_version_below_5_23","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":254,"source":"def test_build_import_query_version_below_5_23(mock_vector_store: Neo4jVector) -> None:\n    mock_vector_store.neo4j_version_is_5_23_or_above = False\n\n    expected_query = (\n        \"UNWIND $data AS row \"\n        \"CALL { WITH row \"\n        \"MERGE (c:`Chunk` {id: row.id}) \"\n        \"WITH c, row \"\n        \"CALL db.create.setNodeVectorProperty(c, \"\n        \"'embedding', row.embedding) \"\n        \"SET c.`text` = row.text \"\n        \"SET c += row.metadata \"\n        \"} IN TRANSACTIONS OF 1000 ROWS \"\n    )\n\n    actual_query = mock_vector_store._build_import_query()\n\n    assert actual_query == expected_query","docstring":null,"args":[{"arg":"mock_vector_store","type":"Neo4jVector"}],"return_type":"None","control_flow":[],"reason_kor":"Neo4j 버전 5.23 미만에서 올바른 Cypher 임포트 쿼리 문자열이 생성되는지 검증하는 테스트.","reason":"Test verifying correct Cypher import query string is generated for Neo4j versions below 5.23."},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_build_import_query_version_is_or_above_5_23","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_build_import_query_version_is_or_above_5_23","_rev":"_jzRpLay---","type":"function","name":"test_build_import_query_version_is_or_above_5_23","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":232,"source":"def test_build_import_query_version_is_or_above_5_23(\n    mock_vector_store: Neo4jVector,\n) -> None:\n    mock_vector_store.neo4j_version_is_5_23_or_above = True\n\n    expected_query = (\n        \"UNWIND $data AS row \"\n        \"CALL (row) { \"\n        \"MERGE (c:`Chunk` {id: row.id}) \"\n        \"WITH c, row \"\n        \"CALL db.create.setNodeVectorProperty(c, \"\n        \"'embedding', row.embedding) \"\n        \"SET c.`text` = row.text \"\n        \"SET c += row.metadata \"\n        \"} IN TRANSACTIONS OF 1000 ROWS \"\n    )\n\n    actual_query = mock_vector_store._build_import_query()\n\n    assert actual_query == expected_query","docstring":null,"args":[{"arg":"mock_vector_store","type":"Neo4jVector"}],"return_type":"None","control_flow":[],"reason_kor":"Neo4j 버전이 5.23 이상일 때 Neo4jVector 클래스가 올바른 Cypher 임포트 쿼리를 생성하는지, 적절한 CALL 구문을 사용하는지 검증하는 테스트.","reason":"Test verifying that the Neo4jVector class generates the correct Cypher import query when the Neo4j version is 5.23 or higher, using the appropriate CALL syntax."},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_check_if_not_null_happy_case","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_check_if_not_null_happy_case","_rev":"_jzRpLb----","type":"function","name":"test_check_if_not_null_happy_case","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":302,"source":"def test_check_if_not_null_happy_case() -> None:\n    props = [\"prop1\", \"prop2\", \"prop3\"]\n    values = [\"value1\", 123, True]\n    check_if_not_null(props, values)","docstring":null,"args":[],"return_type":"None","control_flow":[],"reason_kor":"속성 이름 리스트 'props'와 대응하는 'values'를 결합하여 값 중 None이 없음을 확인, 모든 속성에 값이 할당되었음을 검증","reason":"it is about the list of property names 'props' with their corresponding 'values' and checks that none of the values are null (None), ensuring all properties have assigned values."},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_check_if_not_null_with_empty_string","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_check_if_not_null_with_empty_string","_rev":"_jzRpLbK---","type":"function","name":"test_check_if_not_null_with_empty_string","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":308,"source":"def test_check_if_not_null_with_empty_string() -> None:\n    props = [\"prop1\", \"prop2\", \"prop3\"]\n    values = [\"valid\", \"valid\", \"\"]\n\n    with pytest.raises(ValueError) as exc_info:\n        check_if_not_null(props, values)\n\n    assert \"must not be None or empty string\" in str(exc_info.value)","docstring":null,"args":[],"return_type":"None","control_flow":[],"reason_kor":"빈 문자열을 포함한 'values' 리스트에서 함수 check_if_not_null이 ValueError를 올바르게 발생시키는지 테스트하는 함수 정의, pytest로 호출 시 \"must not be None or empty string\" 메시지 포함 여부 단언","reason":"The code defines a test function that checks whether the function `check_if_not_null` properly raises a ValueError when any value in the `values` list is an empty string. It sets up `props` and `values`, then uses pytest to assert that calling `check_if_not_null` results in a ValueError containing the message \"must not be None or empty string\" due to the empty string in `values`."},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_check_if_not_null_with_none_value","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_check_if_not_null_with_none_value","_rev":"_jzRpLbW---","type":"function","name":"test_check_if_not_null_with_none_value","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":318,"source":"def test_check_if_not_null_with_none_value() -> None:\n    props = [\"prop1\", \"prop2\", \"prop3\"]\n    values = [\"valid\", None, \"valid\"]\n\n    with pytest.raises(ValueError) as exc_info:\n        check_if_not_null(props, values)\n\n    assert \"must not be None or empty string\" in str(exc_info.value)","docstring":null,"args":[],"return_type":"None","control_flow":[],"reason_kor":"'check_if_not_null' 함수가 값 중 하나가 None일 때 ValueError를 발생시키는지, 특정 메시지 포함 여부를 검증하는 테스트 함수","reason":"it is about a test function that verifies the behavior of 'check_if_not_null' when one of the values is None, expecting a ValueError with a specific message."},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_converting_to_yaml","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_converting_to_yaml","_rev":"_jzRpLbm---","type":"function","name":"test_converting_to_yaml","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":213,"source":"def test_converting_to_yaml() -> None:\n    example_dict = {\n        \"name\": \"John Doe\",\n        \"age\": 30,\n        \"skills\": [\"Python\", \"Data Analysis\", \"Machine Learning\"],\n        \"location\": {\"city\": \"Ljubljana\", \"country\": \"Slovenia\"},\n    }\n\n    yaml_str = dict_to_yaml_str(example_dict)\n\n    expected_output = (\n        \"name: John Doe\\nage: 30\\nskills:\\n- Python\\n- \"\n        \"Data Analysis\\n- Machine Learning\\nlocation:\\n  city: Ljubljana\\n\"\n        \"  country: Slovenia\\n\"\n    )\n\n    assert yaml_str == expected_output","docstring":null,"args":[],"return_type":"None","control_flow":[],"reason":"it is about creating a dictionary, converting it to a YAML string using dict_to_yaml_str, and then asserting that the generated YAML string matches the expected output to verify correct serialization.","reason_kor":"딕셔너리를 생성하고 dict_to_yaml_str로 YAML 문자열로 변환, 생성된 YAML 문자열이 기대 출력과 일치하는지 단언하여 올바른 직렬화를 검증"},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_embedding_dimension_inconsistent_raises_value_error","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_embedding_dimension_inconsistent_raises_value_error","_rev":"_jzRpLby---","type":"function","name":"test_embedding_dimension_inconsistent_raises_value_error","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":820,"source":"def test_embedding_dimension_inconsistent_raises_value_error(\n    neo4j_vector_factory: Any,\n) -> None:\n    mock_embedding = MagicMock()\n    mock_embedding.embed_query.return_value = [0.1] * 64\n\n    with patch.object(\n        Neo4jVector, \"retrieve_existing_index\", return_value=(128, \"NODE\")\n    ):\n        with pytest.raises(ValueError) as exc_info:\n            neo4j_vector_factory(\n                method=\"from_existing_index\",\n                embedding=mock_embedding,\n                index_name=\"test_index\",\n            )\n    assert (\n        \"The provided embedding function and vector index dimensions do not match.\"\n        in str(exc_info.value)\n    )","docstring":null,"args":[{"arg":"neo4j_vector_factory","type":"Any"}],"return_type":"None","control_flow":[],"reason":"it is about mocking, patching, and exception testing to verify that the function raises a ValueError when the embedding dimension does not match the expected index dimension","reason_kor":"임베딩 차원이 예상 인덱스 차원과 일치하지 않을 때 함수가 ValueError를 발생시키는지 모킹, 패치, 예외 테스트를 결합해 검증"},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_escaping_lucene","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_escaping_lucene","_rev":"_jzRpLc----","type":"function","name":"test_escaping_lucene","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":167,"source":"def test_escaping_lucene() -> None:\n    \"\"\"Test escaping lucene characters\"\"\"\n    assert remove_lucene_chars(\"Hello+World\") == \"Hello World\"\n    assert remove_lucene_chars(\"Hello World\\\\\") == \"Hello World\"\n    assert (\n        remove_lucene_chars(\"It is the end of the world. Take shelter!\")\n        == \"It is the end of the world. Take shelter\"\n    )\n    assert (\n        remove_lucene_chars(\"It is the end of the world. Take shelter&&\")\n        == \"It is the end of the world. Take shelter\"\n    )\n    assert (\n        remove_lucene_chars(\"Bill&&Melinda Gates Foundation\")\n        == \"Bill  Melinda Gates Foundation\"\n    )\n    assert (\n        remove_lucene_chars(\"It is the end of the world. Take shelter(&&)\")\n        == \"It is the end of the world. Take shelter\"\n    )\n    assert (\n        remove_lucene_chars(\"It is the end of the world. Take shelter??\")\n        == \"It is the end of the world. Take shelter\"\n    )\n    assert (\n        remove_lucene_chars(\"It is the end of the world. Take shelter^\")\n        == \"It is the end of the world. Take shelter\"\n    )\n    assert (\n        remove_lucene_chars(\"It is the end of the world. Take shelter+\")\n        == \"It is the end of the world. Take shelter\"\n    )\n    assert (\n        remove_lucene_chars(\"It is the end of the world. Take shelter-\")\n        == \"It is the end of the world. Take shelter\"\n    )\n    assert (\n        remove_lucene_chars(\"It is the end of the world. Take shelter~\")\n        == \"It is the end of the world. Take shelter\"\n    )\n    assert (\n        remove_lucene_chars(\"It is the end of the world. Take shelter/\")\n        == \"It is the end of the world. Take shelter\"\n    )","docstring":"Test escaping lucene characters","args":[],"return_type":"None","control_flow":[],"reason":"it is about multiple assertions to verify that the function remove_lucene_chars effectively removes or replaces special Lucene characters and symbols such as +, \\, &&, ??, ^, -, ~, / from various input strings, ensuring the output strings are cleaned of these characters.","reason_kor":"특수 Lucene 문자 및 기호(+, , &&, ??, ^, -, ~, /)가 입력 문자열에서 효과적으로 제거 또는 치환되는지 여러 단언으로 검증"},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_from_existing_graph_embedding_dimension_mismatch","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_from_existing_graph_embedding_dimension_mismatch","_rev":"_jzRpLcS---","type":"function","name":"test_from_existing_graph_embedding_dimension_mismatch","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":673,"source":"def test_from_existing_graph_embedding_dimension_mismatch(\n    neo4j_vector_factory: Any,\n) -> None:\n    mock_embedding = MagicMock()\n    mock_embedding.embed_query.return_value = [0.1] * 64\n\n    with patch.object(\n        Neo4jVector, \"retrieve_existing_index\", return_value=(128, \"NODE\")\n    ):\n        with pytest.raises(ValueError) as exc_info:\n            neo4j_vector_factory(\n                method=\"from_existing_graph\",\n                embedding=mock_embedding,\n                node_label=\"TestLabel\",\n                embedding_node_property=\"embedding\",\n                text_node_properties=[\"text_property\"],\n                search_type=SearchType.VECTOR,\n            )\n\n    assert (\n        \"The provided embedding function and vector index dimensions do not match\"\n        in str(exc_info.value)\n    )","docstring":null,"args":[{"arg":"neo4j_vector_factory","type":"Any"}],"return_type":"None","control_flow":[],"reason":"it is about the creation of a mock embedding, patching a method to simulate existing index retrieval, invoking the neo4j_vector_factory with specific arguments, and asserting that a ValueError is raised when the embedding dimension does not match the existing index dimension.","reason_kor":"모킹된 임베딩 생성, 기존 인덱스 검색 모킹, 특정 인자와 함께 neo4j_vector_factory 호출, 임베딩 차원이 기존 인덱스 차원과 불일치할 때 ValueError 발생 단언"},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_from_existing_graph_empty_text_node_properties","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_from_existing_graph_empty_text_node_properties","_rev":"_jzRpLci---","type":"function","name":"test_from_existing_graph_empty_text_node_properties","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":636,"source":"def test_from_existing_graph_empty_text_node_properties() -> None:\n    with pytest.raises(ValueError) as exc_info:\n        Neo4jVector.from_existing_graph(\n            embedding=MagicMock(),\n            node_label=\"TestLabel\",\n            embedding_node_property=\"embedding\",\n            text_node_properties=[],\n        )\n    assert \"Parameter `text_node_properties` must not be an empty list\" in str(\n        exc_info.value\n    )","docstring":null,"args":[],"return_type":"None","control_flow":[],"reason":"it is about a unit test function that checks whether the method Neo4jVector.from_existing_graph raises a ValueError when the text_node_properties parameter is an empty list, and verifies the error message for correctness.","reason_kor":"텍스트 노드 속성 리스트가 빈 경우 Neo4jVector.from_existing_graph 메서드가 ValueError를 발생시키는지 단위 테스트 함수"},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_from_existing_graph_fts_vector_node_label_mismatch","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_from_existing_graph_fts_vector_node_label_mismatch","_rev":"_jzRpLcu---","type":"function","name":"test_from_existing_graph_fts_vector_node_label_mismatch","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":698,"source":"def test_from_existing_graph_fts_vector_node_label_mismatch(\n    neo4j_vector_factory: Any,\n) -> None:\n    mock_embedding = MagicMock()\n    mock_embedding.embed_query.return_value = [0.1] * 64\n    with patch.object(\n        Neo4jVector, \"retrieve_existing_index\", return_value=(64, \"NODE\")\n    ), patch.object(\n        Neo4jVector, \"retrieve_existing_fts_index\", return_value=\"DifferentNodeLabel\"\n    ):\n        with pytest.raises(ValueError) as exc_info:\n            neo4j_vector_factory(\n                method=\"from_existing_graph\",\n                embedding=mock_embedding,\n                node_label=\"TestLabel\",\n                embedding_node_property=\"embedding\",\n                text_node_properties=[\"text_property\"],\n                search_type=SearchType.HYBRID,\n                keyword_index_name=\"keyword_index\",\n            )\n\n    assert \"Vector and keyword index don't index the same node label\" in str(\n        exc_info.value\n    )","docstring":null,"args":[{"arg":"neo4j_vector_factory","type":"Any"}],"return_type":"None","control_flow":[],"reason":"it is about mocking of methods 'retrieve_existing_index' and 'retrieve_existing_fts_index' to simulate a mismatch in node labels between vector and keyword index, then it tested that a ValueError is raised with an appropriate message when 'neo4j_vector_factory' is invoked with these conditions.","reason_kor":"벡터 인덱스와 키워드 인덱스 간 노드 라벨 불일치 상황을 시뮬레이션하는 'retrieve_existing_index'와 'retrieve_existing_fts_index' 메서드 모킹, 이러한 조건에서 neo4j_vector_factory 호출 시 ValueError 발생 여부 테스트"},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_from_existing_graph_relationship_index_error","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_from_existing_graph_relationship_index_error","_rev":"_jzRpLd----","type":"function","name":"test_from_existing_graph_relationship_index_error","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":649,"source":"def test_from_existing_graph_relationship_index_error(\n    neo4j_vector_factory: Any,\n) -> None:\n    with patch.object(\n        Neo4jVector, \"retrieve_existing_index\", return_value=(64, \"RELATIONSHIP\")\n    ):\n        with pytest.raises(ValueError) as exc_info:\n            neo4j_vector_factory(\n                method=\"from_existing_graph\",\n                embedding=MagicMock(),\n                node_label=\"TestLabel\",\n                embedding_node_property=\"embedding\",\n                text_node_properties=[\"text_property\"],\n                search_type=SearchType.HYBRID,\n                keyword_index_name=\"keyword_index\",\n            )\n\n        assert (\n            \"`from_existing_graph` method does not support  existing relationship \"\n            \"vector index. Please use `from_existing_relationship_index` method\"\n            in str(exc_info.value)\n        )","docstring":null,"args":[{"arg":"neo4j_vector_factory","type":"Any"}],"return_type":"None","control_flow":[],"reason":"it is about mocking a method 'retrieve_existing_index' to return a specific value (64, 'RELATIONSHIP'), then tested that calling 'neo4j_vector_factory' with 'method' set to 'from_existing_graph' raises a ValueError with a specific message, ensuring the code properly handles unsupported relationship vector index types in this scenario.","reason_kor":"특정 값(64, 'RELATIONSHIP')을 반환하는 'retrieve_existing_index' 메서드 모킹 후, 'from_existing_graph' 메서드로 neo4j_vector_factory 호출 시 지원하지 않는 관계 벡터 인덱스 유형에 대해 ValueError 발생 확인"},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_from_existing_index_fts_vector_node_label_mismatch","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_from_existing_index_fts_vector_node_label_mismatch","_rev":"_jzRpLdO---","type":"function","name":"test_from_existing_index_fts_vector_node_label_mismatch","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":542,"source":"def test_from_existing_index_fts_vector_node_label_mismatch(\n    neo4j_vector_factory: Any,\n) -> None:\n    embedding_dimension = 64\n\n    mock_embedding = MagicMock()\n    mock_embedding.embed_query.return_value = [0.1] * embedding_dimension\n\n    with patch.object(\n        Neo4jVector,\n        \"retrieve_existing_index\",\n        return_value=(embedding_dimension, \"NODE\"),\n    ), patch.object(\n        Neo4jVector, \"retrieve_existing_fts_index\", return_value=\"DifferentNodeLabel\"\n    ):\n        with pytest.raises(ValueError) as exc_info:\n            neo4j_vector_factory(\n                method=\"from_existing_index\",\n                embedding=mock_embedding,\n                index_name=\"test_index\",\n                search_type=SearchType.HYBRID,\n                keyword_index_name=\"keyword_index\",\n            )\n\n    assert \"Vector and keyword index don't index the same node label\" in str(\n        exc_info.value\n    )","docstring":null,"args":[{"arg":"neo4j_vector_factory","type":"Any"}],"return_type":"None","control_flow":[],"reason":"it is about mock setup for Neo4jVector methods with patching to simulate index retrievals, then tested that a ValueError is raised when the node label from the existing index does not match the expected label, verifying proper error handling for label mismatches","reason_kor":"Neo4jVector 메서드들에 대한 모킹 설정과 인덱스 검색 시뮬레이션 후, 기존 인덱스의 노드 라벨이 예상과 다를 경우 ValueError 발생 여부 테스트"},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_from_existing_index_index_not_found","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_from_existing_index_index_not_found","_rev":"_jzRpLdi---","type":"function","name":"test_from_existing_index_index_not_found","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":529,"source":"def test_from_existing_index_index_not_found(neo4j_vector_factory: Any) -> None:\n    with patch.object(\n        Neo4jVector, \"retrieve_existing_index\", return_value=(None, None)\n    ):\n        with pytest.raises(ValueError) as exc_info:\n            neo4j_vector_factory(\n                method=\"from_existing_index\",\n                embedding=MagicMock(),\n                index_name=\"non_existent_index\",\n            )\n    assert \"The specified vector index name does not exist.\" in str(exc_info.value)","docstring":null,"args":[{"arg":"neo4j_vector_factory","type":"Any"}],"return_type":"None","control_flow":[],"reason":"it is about mocking a method 'retrieve_existing_index' to simulate a non-existent index, then tested that calling 'neo4j_vector_factory' with method 'from_existing_index' raises a ValueError with a specific message when the index is not found.","reason_kor":"'retrieve_existing_index' 메서드를 모킹해 인덱스 미존재 시뮬레이션, 'from_existing_index' 메서드로 neo4j_vector_factory 호출 시 인덱스가 없을 때 ValueError 발생 여부 테스트"},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_from_existing_index_keyword_index_not_exist","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_from_existing_index_keyword_index_not_exist","_rev":"_jzRpLdu---","type":"function","name":"test_from_existing_index_keyword_index_not_exist","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":773,"source":"def test_from_existing_index_keyword_index_not_exist(neo4j_vector_factory: Any) -> None:\n    mock_embedding = MagicMock()\n    mock_embedding.embed_query.return_value = [0.1] * 64\n\n    with (\n        patch.object(Neo4jVector, \"retrieve_existing_index\", return_value=(64, \"NODE\")),\n        patch.object(Neo4jVector, \"retrieve_existing_fts_index\", return_value=None),\n    ):\n        with pytest.raises(ValueError) as exc_info:\n            neo4j_vector_factory(\n                method=\"from_existing_index\",\n                embedding=mock_embedding,\n                index_name=\"vector_index\",\n                search_type=SearchType.HYBRID,\n                keyword_index_name=\"nonexistent_keyword_index\",\n            )\n    expected_message = (\n        \"The specified keyword index name does not exist. \"\n        \"Make sure to check if you spelled it correctly\"\n    )\n    assert expected_message in str(exc_info.value)","docstring":null,"args":[{"arg":"neo4j_vector_factory","type":"Any"}],"return_type":"None","control_flow":[],"reason":"it is about mocking of Neo4j methods to simulate the absence of a keyword index, then checked that the function raises a ValueError with an appropriate message when attempting to create a vector index with a non-existent keyword index.","reason_kor":"키워드 인덱스가 없음을 시뮬레이션하는 Neo4j 메서드 모킹, 존재하지 않는 키워드 인덱스로 벡터 인덱스 생성 시도 시 적절한 메시지의 ValueError 발생 여부 확인"},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_from_existing_index_relationship_index_error","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_from_existing_index_relationship_index_error","_rev":"_jzRpLeC---","type":"function","name":"test_from_existing_index_relationship_index_error","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":511,"source":"def test_from_existing_index_relationship_index_error(\n    neo4j_vector_factory: Any,\n) -> None:\n    with patch.object(\n        Neo4jVector, \"retrieve_existing_index\", return_value=(64, \"RELATIONSHIP\")\n    ):\n        with pytest.raises(ValueError) as exc_info:\n            neo4j_vector_factory(\n                method=\"from_existing_index\",\n                index_name=\"test_index\",\n                search_type=SearchType.VECTOR,\n            )\n    assert (\n        \"Relationship vector index is not supported with `from_existing_index` \"\n        \"method.\" in str(exc_info.value)\n    )","docstring":null,"args":[{"arg":"neo4j_vector_factory","type":"Any"}],"return_type":"None","control_flow":[],"reason":"it is about a patching of the Neo4jVector class method 'retrieve_existing_index' to simulate a specific return value, then tested if calling 'neo4j_vector_factory' with 'from_existing_index' method raises a ValueError with a specific message, ensuring proper error handling when an unsupported relationship index type is encountered.","reason_kor":"'retrieve_existing_index' 메서드 모킹으로 특정 반환값 시뮬레이션, 'from_existing_index' 호출 시 지원하지 않는 관계 인덱스 유형에 대해 ValueError 발생 여부 검증"},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_from_existing_relationship_index_embedding_dimension_mismatch","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_from_existing_relationship_index_embedding_dimension_mismatch","_rev":"_jzRpLeW---","type":"function","name":"test_from_existing_relationship_index_embedding_dimension_mismatch","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":614,"source":"def test_from_existing_relationship_index_embedding_dimension_mismatch(\n    neo4j_vector_factory: Any,\n) -> None:\n    mock_embedding = MagicMock()\n    mock_embedding.embed_query.return_value = [0.1] * 64\n    with patch.object(\n        Neo4jVector, \"retrieve_existing_index\", return_value=(128, \"RELATIONSHIP\")\n    ):\n        with pytest.raises(ValueError) as exc_info:\n            neo4j_vector_factory(\n                method=\"from_existing_relationship_index\",\n                embedding=mock_embedding,\n                index_name=\"test_index\",\n                search_type=SearchType.VECTOR,\n            )\n\n    assert (\n        \"The provided embedding function and vector index dimensions do not match\"\n        in str(exc_info.value)\n    )","docstring":null,"args":[{"arg":"neo4j_vector_factory","type":"Any"}],"return_type":"None","control_flow":[],"reason":"it is about mocking a method to simulate a specific return value, patching a class method to raise an error when a dimension mismatch occurs, and asserting that the error message is as expected, thus testing the mismatch handling in the vector factory creation process.","reason_kor":"특정 반환값 시뮬레이션과 차원 불일치 시 오류 발생을 위한 클래스 메서드 패치, 오류 메시지 단언을 통해 벡터 팩토리 생성 과정의 불일치 처리 테스트"},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_from_existing_relationship_index_hybrid_not_supported","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_from_existing_relationship_index_hybrid_not_supported","_rev":"_jzRpLeq---","type":"function","name":"test_from_existing_relationship_index_hybrid_not_supported","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":571,"source":"def test_from_existing_relationship_index_hybrid_not_supported() -> None:\n    with pytest.raises(ValueError) as exc_info:\n        Neo4jVector.from_existing_relationship_index(\n            embedding=MagicMock(),\n            index_name=\"test_index\",\n            search_type=SearchType.HYBRID,\n        )\n    assert (\n        \"Hybrid search is not supported in combination with relationship vector index\"\n        in str(exc_info.value)\n    )","docstring":null,"args":[],"return_type":"None","control_flow":[],"reason":"it is about a test function that verifies if a ValueError is raised when attempting to create a Neo4jVector from an existing relationship index with a hybrid search type, which is not supported, and checks if the exception message contains the appropriate error message indicating the unsupported operation.","reason_kor":"하이브리드 검색 타입을 가진 기존 관계 인덱스에서 Neo4jVector 생성 시 ValueError 발생 여부 및 예외 메시지 적절성 검증 테스트 함수"},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_from_existing_relationship_index_index_not_found","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_from_existing_relationship_index_index_not_found","_rev":"_jzRpLe6---","type":"function","name":"test_from_existing_relationship_index_index_not_found","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":584,"source":"def test_from_existing_relationship_index_index_not_found(\n    neo4j_vector_factory: Any,\n) -> None:\n    with patch.object(\n        Neo4jVector, \"retrieve_existing_index\", return_value=(None, None)\n    ):\n        with pytest.raises(ValueError) as exc_info:\n            neo4j_vector_factory(\n                method=\"from_existing_relationship_index\",\n                index_name=\"non_existent_index\",\n            )\n    assert \"The specified vector index name does not exist\" in str(exc_info.value)","docstring":null,"args":[{"arg":"neo4j_vector_factory","type":"Any"}],"return_type":"None","control_flow":[],"reason":"it is about function definition, patching a method, handling exception with pytest, and assertion to verify error message when a nonexistent index is referenced in Neo4j vector factory","reason_kor":"존재하지 않는 인덱스 참조 시 Neo4j 벡터 팩토리에서 오류 메시지를 검증하는 함수 정의, 메서드 패치와 pytest 예외 처리 결합"},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_from_existing_relationship_index_node_index_error","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_from_existing_relationship_index_node_index_error","_rev":"_jzRpLfK---","type":"function","name":"test_from_existing_relationship_index_node_index_error","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":598,"source":"def test_from_existing_relationship_index_node_index_error() -> None:\n    with patch.object(Neo4jVector, \"__init__\", return_value=None):\n        with patch.object(\n            Neo4jVector, \"retrieve_existing_index\", return_value=(64, \"NODE\")\n        ):\n            with pytest.raises(ValueError) as exc_info:\n                Neo4jVector.from_existing_relationship_index(\n                    embedding=MagicMock(),\n                    index_name=\"test_index\",\n                )\n            assert (\n                \"Node vector index is not supported with \"\n                \"`from_existing_relationship_index` method\" in str(exc_info.value)\n            )","docstring":null,"args":[],"return_type":"None","control_flow":[],"reason":"it is about mock patching of class methods, exception handling, and assertion to test a specific error scenario in the method Neo4jVector.from_existing_relationship_index.","reason_kor":"Neo4jVector.from_existing_relationship_index 메서드에서 특정 오류 시나리오를 테스트하기 위한 모킹 패치, 예외 처리 및 단언 포합니다."},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_neo4jvector_auth_error","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_neo4jvector_auth_error","_rev":"_jzRpLfa---","type":"function","name":"test_neo4jvector_auth_error","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":365,"source":"def test_neo4jvector_auth_error(neo4j_vector_factory: Any) -> None:\n    class MockAuthError(Exception):\n        pass\n\n    class MockServiceUnavailable(Exception):\n        pass\n\n    with pytest.raises(ValueError) as exc_info:\n        neo4j_vector_factory(\n            verify_connectivity_side_effect=MockAuthError(\"Authentication Failed\"),\n            auth_error_class=MockAuthError,\n            service_unavailable_class=MockServiceUnavailable,\n        )\n\n    assert (\n        \"Could not connect to Neo4j database. Please ensure that the username \"\n        \"and password are correct\" in str(exc_info.value)\n    )","docstring":null,"args":[{"arg":"neo4j_vector_factory","type":"Any"}],"return_type":"None","control_flow":[],"reason":"it is about a test function that uses mock exceptions to simulate connection errors in Neo4j, then asserts that the appropriate ValueError message is raised when authentication fails, indicating proper error handling in the neural vector database connection logic.","reason_kor":"Neo4j 연결 오류를 모의하는 예외 모킹을 사용한 테스트 함수로, 인증 실패 시 적절한 ValueError 메시지 발생 여부를 확인하여 신경망 벡터 데이터베이스 연결 오류 처리 검증"},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_neo4jvector_embedding_dimension_mismatch","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_neo4jvector_embedding_dimension_mismatch","_rev":"_jzRpLfu---","type":"function","name":"test_neo4jvector_embedding_dimension_mismatch","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":421,"source":"def test_neo4jvector_embedding_dimension_mismatch(neo4j_vector_factory: Any) -> None:\n    texts = [\"text1\", \"text2\"]\n\n    mock_embedding = MagicMock()\n    mock_embedding.embed_query.return_value = [0.1] * 64\n\n    with patch.object(\n        Neo4jVector, \"retrieve_existing_index\", return_value=(128, \"NODE\")\n    ):\n        with pytest.raises(ValueError) as exc_info:\n            neo4j_vector_factory(\n                method=\"from_texts\",\n                texts=texts,\n                embedding=mock_embedding,\n                search_type=SearchType.VECTOR,\n            )\n    assert (\n        \"The provided embedding function and vector index dimensions do not match.\"\n        in str(exc_info.value)\n    )","docstring":null,"args":[{"arg":"neo4j_vector_factory","type":"Any"}],"return_type":"None","control_flow":[],"reason":"it is about mocking, patching, and exception handling to test if the function correctly raises a ValueError when the embedding dimension does not match the expected index dimension in a Neo4j vector embedding context.","reason_kor":"임베딩 차원이 예상 인덱스 차원과 일치하지 않을 때 함수가 ValueError를 올바르게 발생시키는지 모킹, 패치, 예외 처리로 테스트"},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_neo4jvector_fts_vector_node_label_mismatch","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_neo4jvector_fts_vector_node_label_mismatch","_rev":"_jzRpLgC---","type":"function","name":"test_neo4jvector_fts_vector_node_label_mismatch","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":443,"source":"def test_neo4jvector_fts_vector_node_label_mismatch(neo4j_vector_factory: Any) -> None:\n    texts = [\"text1\", \"text2\"]\n    embedding_dimension = 64\n\n    mock_embedding = MagicMock()\n    mock_embedding.embed_query.return_value = [0.1] * embedding_dimension\n\n    with patch.object(\n        Neo4jVector,\n        \"retrieve_existing_index\",\n        return_value=(embedding_dimension, \"NODE\"),\n    ), patch.object(\n        Neo4jVector, \"retrieve_existing_fts_index\", return_value=\"DifferentNodeLabel\"\n    ):\n        with pytest.raises(ValueError) as exc_info:\n            neo4j_vector_factory(\n                method=\"from_texts\",\n                texts=texts,\n                embedding=mock_embedding,\n                search_type=SearchType.HYBRID,\n                node_label=\"TestLabel\",\n                keyword_index_name=\"keyword_index\",\n            )\n    assert \"Vector and keyword index don't index the same node label\" in str(\n        exc_info.value\n    )","docstring":null,"args":[{"arg":"neo4j_vector_factory","type":"Any"}],"return_type":"None","control_flow":[],"reason":"it is about mocking of Neo4jVector methods to simulate index retrievals and checked for label mismatch during initialization, ensuring a ValueError is raised when the node labels differ between vector and keyword indices.","reason_kor":"Neo4jVector 메서드 모킹을 통해 인덱스 검색 시뮬레이션 및 노드 라벨 불일치 점검, 벡터 및 키워드 인덱스 간 라벨 차이 발생 시 ValueError가 발생하는지 검증"},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_neo4jvector_invalid_distance_strategy","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_neo4jvector_invalid_distance_strategy","_rev":"_jzRpLgW---","type":"function","name":"test_neo4jvector_invalid_distance_strategy","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":328,"source":"def test_neo4jvector_invalid_distance_strategy() -> None:\n    with pytest.raises(ValueError) as exc_info:\n        Neo4jVector(\n            embedding=MagicMock(),\n            url=\"bolt://localhost:7687\",\n            username=\"neo4j\",\n            password=\"password\",\n            distance_strategy=\"INVALID_STRATEGY\",  # type: ignore[arg-type]\n        )\n    assert \"distance_strategy must be either 'EUCLIDEAN_DISTANCE' or 'COSINE'\" in str(\n        exc_info.value\n    )","docstring":null,"args":[],"return_type":"None","control_flow":[],"reason":"it is about a function that tests invalid input handling for the Neo4jVector class by asserting that a ValueError is raised when an incorrect distance_strategy value is provided. it verifies the error message contains specific guidance on valid options.","reason_kor":"잘못된 distance_strategy 값 입력 시 Neo4jVector 클래스에서 ValueError를 발생시키며, 올바른 옵션 안내 메시지를 포함하는지 테스트하는 함수"},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_neo4jvector_metadata_filter_version","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_neo4jvector_metadata_filter_version","_rev":"_jzRpLgq---","type":"function","name":"test_neo4jvector_metadata_filter_version","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":400,"source":"def test_neo4jvector_metadata_filter_version(neo4j_vector_factory: Any) -> None:\n    version_response = {\"versions\": [\"5.17.0\"], \"edition\": \"enterprise\"}\n    vector_store = neo4j_vector_factory(query_return_value=version_response)\n    assert vector_store.support_metadata_filter is False","docstring":null,"args":[{"arg":"neo4j_vector_factory","type":"Any"}],"return_type":"None","control_flow":[],"reason":"it is about a mock neo4j vector factory with a version response to test if the 'support_metadata_filter' attribute is correctly set to False for the given version '5.17.0' and enterprise edition","reason_kor":"'5.17.0' 버전 및 엔터프라이즈 에디션을 가진 모의 neo4j 벡터 팩토리에서 'support_metadata_filter' 속성이 False로 올바르게 설정되는지 검증"},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_neo4jvector_relationship_index_error","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_neo4jvector_relationship_index_error","_rev":"_jzRpLhC---","type":"function","name":"test_neo4jvector_relationship_index_error","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":406,"source":"def test_neo4jvector_relationship_index_error(neo4j_vector_factory: Any) -> None:\n    texts = [\"text1\", \"text2\"]\n\n    with patch.object(\n        Neo4jVector, \"retrieve_existing_index\", return_value=(None, \"RELATIONSHIP\")\n    ):\n        with pytest.raises(ValueError) as exc_info:\n            neo4j_vector_factory(\n                method=\"from_texts\", texts=texts, search_type=SearchType.VECTOR\n            )\n    assert \"Data ingestion is not supported with relationship vector index.\" in str(\n        exc_info.value\n    )","docstring":null,"args":[{"arg":"neo4j_vector_factory","type":"Any"}],"return_type":"None","control_flow":[],"reason":"it is about patching of Neo4jVector.retrieve_existing_index to simulate a specific return value, then called neo4j_vector_factory with method 'from_texts' and search_type 'SearchType.VECTOR', expecting a ValueError to be raised, and finally verified that the error message contains a specific substring.","reason_kor":"Neo4jVector.retrieve_existing_index 메서드를 패치해 특정 반환값을 시뮬레이션하고, 'from_texts' 메서드와 'SearchType.VECTOR'를 사용해 neo4j_vector_factory 호출 시 ValueError 발생 여부 및 메시지 일부 포함 확인"},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_neo4jvector_service_unavailable","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_neo4jvector_service_unavailable","_rev":"_jzRpLha---","type":"function","name":"test_neo4jvector_service_unavailable","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":342,"source":"def test_neo4jvector_service_unavailable() -> None:\n    mock_driver_instance = MagicMock()\n    mock_driver_instance.verify_connectivity.side_effect = (\n        neo4j.exceptions.ServiceUnavailable\n    )\n\n    with patch(\n        \"langchain_neo4j.vectorstores.neo4j_vector.neo4j.GraphDatabase.driver\",\n        return_value=mock_driver_instance,\n    ):\n        with pytest.raises(ValueError) as exc_info:\n            Neo4jVector(\n                embedding=MagicMock(),\n                url=\"bolt://invalid_host:7687\",\n                username=\"neo4j\",\n                password=\"password\",\n            )\n    assert (\n        \"Could not connect to Neo4j database. Please ensure that the url is correct\"\n        in str(exc_info.value)\n    )","docstring":null,"args":[],"return_type":"None","control_flow":[],"reason":"it is about mocking of Neo4j driver to simulate a ServiceUnavailable exception, patching the GraphDatabase.driver method to use this mock, then testing that creating a Neo4jVector instance raises a ValueError with the appropriate message when the connection fails.","reason_kor":"서비스 이용 불가 예외를 모킹하고, GraphDatabase.driver 메서드를 패치하여 연결 실패를 시뮬레이션한 후, Neo4jVector 인스턴스 생성 시 적절한 메시지의 ValueError 발생 여부 테스트"},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_neo4jvector_version_too_low","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_neo4jvector_version_too_low","_rev":"_jzRpLi----","type":"function","name":"test_neo4jvector_version_too_low","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":391,"source":"def test_neo4jvector_version_too_low(neo4j_vector_factory: Any) -> None:\n    low_version_response = {\"versions\": [\"5.10.0\"], \"edition\": \"enterprise\"}\n    with pytest.raises(ValueError) as exc_info:\n        neo4j_vector_factory(query_return_value=low_version_response)\n    assert \"Vector index is only supported in Neo4j version 5.11 or greater\" in str(\n        exc_info.value\n    )","docstring":null,"args":[{"arg":"neo4j_vector_factory","type":"Any"}],"return_type":"None","control_flow":[],"reason":"it is about version checking, pytest exception handling, and assertion to verify that the neo4j_vector_factory raises a ValueError with the correct message when the Neo4j version is below 5.11.","reason_kor":"버전 체크, pytest 예외 처리, Neo4j 버전이 5.11 미만일 때 neo4j_vector_factory가 올바른 메시지의 ValueError를 발생시키는지 검증"},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_neo4jvector_version_with_aura","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_neo4jvector_version_with_aura","_rev":"_jzRpLia---","type":"function","name":"test_neo4jvector_version_with_aura","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":385,"source":"def test_neo4jvector_version_with_aura(neo4j_vector_factory: Any) -> None:\n    aura_version_response = {\"versions\": [\"5.11.0-aura\"], \"edition\": \"enterprise\"}\n    vector_store = neo4j_vector_factory(query_return_value=aura_version_response)\n    assert not vector_store.neo4j_version_is_5_23_or_above","docstring":null,"args":[{"arg":"neo4j_vector_factory","type":"Any"}],"return_type":"None","control_flow":[],"reason":"it is about a mock response for Aura version info with a Neo4j vector factory to test if the version is below 5.23, asserting that the version check evaluates to True for the mock response","reason_kor":"Aura 버전 정보에 대한 모의 응답과 Neo4j 벡터 팩토리를 사용해 버전이 5.23 미만인지 테스트하고, 모의 응답에 대해 버전 체크가 True로 평가되는지 검증"},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_select_relevance_score_fn_cosine","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_select_relevance_score_fn_cosine","_rev":"_jzRpLim---","type":"function","name":"test_select_relevance_score_fn_cosine","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":765,"source":"def test_select_relevance_score_fn_cosine(neo4j_vector_factory: Any) -> None:\n    vector_store = neo4j_vector_factory(\n        embedding=MagicMock(), distance_strategy=DistanceStrategy.COSINE\n    )\n\n    assert vector_store._distance_strategy == DistanceStrategy.COSINE","docstring":null,"args":[{"arg":"neo4j_vector_factory","type":"Any"}],"return_type":"None","control_flow":[],"reason":"it is about creating a vector store with a specified distance strategy, specifically COSINE, using a mock embedding, and then checked if the store's distance strategy attribute correctly set to COSINE","reason_kor":"특정 거리 전략(COSINE)을 사용하여 벡터 스토어를 생성하고, 모의 임베딩으로 초기화하여 벡터 스토어의 거리 전략 속성이 COSINE으로 올바르게 설정되었는지 확인"},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_select_relevance_score_fn_euclidean_distance","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_select_relevance_score_fn_euclidean_distance","_rev":"_jzRpLiy---","type":"function","name":"test_select_relevance_score_fn_euclidean_distance","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":755,"source":"def test_select_relevance_score_fn_euclidean_distance(\n    neo4j_vector_factory: Any,\n) -> None:\n    vector_store = neo4j_vector_factory(\n        embedding=MagicMock(), distance_strategy=DistanceStrategy.EUCLIDEAN_DISTANCE\n    )\n\n    assert vector_store._distance_strategy == DistanceStrategy.EUCLIDEAN_DISTANCE","docstring":null,"args":[{"arg":"neo4j_vector_factory","type":"Any"}],"return_type":"None","control_flow":[],"reason":"It initializes a vector store using a provided factory with a mock embedding and sets the distance strategy to Euclidean Distance, then verifies that the internal distance strategy attribute is correctly set to EUCLIDEAN_DISTANCE.","reason_kor":"제공된 팩토리를 사용해 모의 임베딩과 함께 벡터 스토어를 초기화하고 거리 전략을 유클리드 거리로 설정, 내부 거리 전략 속성이 EUCLIDEAN_DISTANCE로 올바르게 설정되었는지 검증"},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_select_relevance_score_fn_invalid_distance_strategy","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_select_relevance_score_fn_invalid_distance_strategy","_rev":"_jzRpLj----","type":"function","name":"test_select_relevance_score_fn_invalid_distance_strategy","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":738,"source":"def test_select_relevance_score_fn_invalid_distance_strategy(\n    neo4j_vector_factory: Any,\n) -> None:\n    vector_store = neo4j_vector_factory(\n        embedding=MagicMock(), search_type=SearchType.VECTOR\n    )\n    vector_store._distance_strategy = \"INVALID_STRATEGY\"\n\n    with pytest.raises(ValueError) as exc_info:\n        vector_store._select_relevance_score_fn()\n\n    assert (\n        \"No supported normalization function for distance_strategy of INVALID_STRATEGY\"\n        in str(exc_info.value)\n    )","docstring":null,"args":[{"arg":"neo4j_vector_factory","type":"Any"}],"return_type":"None","control_flow":[],"reason":"it is about setting an invalid distance strategy to trigger a ValueError and then checks if the correct error message is raised when the method _select_relevance_score_fn is called with this invalid configuration.","reason_kor":"잘못된 거리 전략을 설정하여 ValueError를 유발시키고, _select_relevance_score_fn 메서드 호출 시 올바른 오류 메시지가 발생하는지 확인"},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_select_relevance_score_fn_override","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_select_relevance_score_fn_override","_rev":"_jzRpLjK---","type":"function","name":"test_select_relevance_score_fn_override","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":724,"source":"def test_select_relevance_score_fn_override(neo4j_vector_factory: Any) -> None:\n    def override_fn(x: int) -> int:\n        return x * 2\n\n    vector_store = neo4j_vector_factory(\n        embedding=MagicMock(),\n        search_type=SearchType.VECTOR,\n        relevance_score_fn=override_fn,\n    )\n    fn = vector_store._select_relevance_score_fn()\n\n    assert fn(2) == 4","docstring":null,"args":[{"arg":"neo4j_vector_factory","type":"Any"}],"return_type":"None","control_flow":[],"reason":"it is about the custom relevance_score_fn override_fn with the vector_store by passing it as an argument during its creation, then retrieves and tests this function to ensure it performs as expected.","reason_kor":"사용자 지정 relevance_score_fn 오버라이드 함수와 벡터 스토어를 결합해 생성 시 전달하고, 이 함수를 가져와 테스트하여 예상대로 동작하는지 검증"},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_select_relevance_score_fn_unsupported_strategy","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_select_relevance_score_fn_unsupported_strategy","_rev":"_jzRpLjW---","type":"function","name":"test_select_relevance_score_fn_unsupported_strategy","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":796,"source":"def test_select_relevance_score_fn_unsupported_strategy(\n    neo4j_vector_factory: Any,\n) -> None:\n    vector_store = neo4j_vector_factory(\n        embedding=MagicMock(), distance_strategy=DistanceStrategy.COSINE\n    )\n\n    vector_store._distance_strategy = \"UNSUPPORTED_STRATEGY\"\n\n    with pytest.raises(ValueError) as exc_info:\n        vector_store._select_relevance_score_fn()\n\n    expected_message = (\n        \"No supported normalization function for distance_strategy \"\n        \"of UNSUPPORTED_STRATEGY.\"\n        \"Consider providing relevance_score_fn to PGVector constructor.\"\n    )\n\n    assert expected_message in str(exc_info.value), (\n        f\"Expected error message to contain '{expected_message}' \"\n        f\"but got '{str(exc_info.value)}'\"\n    )","docstring":null,"args":[{"arg":"neo4j_vector_factory","type":"Any"}],"return_type":"None","control_flow":[],"reason":"it is about a test function that mocks a vector store object with a specific unsupported distance strategy, then verifies that the method _select_relevance_score_fn() raises a ValueError with an appropriate message when an unsupported strategy is set.","reason_kor":"지원하지 않는 거리 전략을 가진 벡터 스토어 객체를 모킹하고, _select_relevance_score_fn() 호출 시 적절한 메시지와 함께 ValueError가 발생하는지 검증하는 테스트 함수"},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_similarity_search_by_vector_metadata_filter_hybrid","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_similarity_search_by_vector_metadata_filter_hybrid","_rev":"_jzRpLjm---","type":"function","name":"test_similarity_search_by_vector_metadata_filter_hybrid","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":494,"source":"def test_similarity_search_by_vector_metadata_filter_hybrid(\n    neo4j_vector_factory: Any,\n) -> None:\n    vector_store = neo4j_vector_factory()\n\n    vector_store.support_metadata_filter = True\n    vector_store.search_type = SearchType.HYBRID\n    vector_store.embedding_dimension = 64\n\n    with pytest.raises(Exception) as exc_info:\n        vector_store.similarity_search_by_vector(\n            embedding=[0] * 64,\n            filter={\"field\": \"value\"},\n        )\n    assert \"Filters are not supported with hybrid search\" in str(exc_info.value)","docstring":null,"args":[{"arg":"neo4j_vector_factory","type":"Any"}],"return_type":"None","control_flow":[],"reason":"it is about setting up a vector store with specific configurations, enabling metadata filter support and hybrid search mode, then tested that an exception is raised when attempting to perform a similarity search with a filter, verifying the error message indicates filters are unsupported in hybrid search mode.","reason_kor":"특정 구성으로 벡터 스토어를 설정하고, 메타데이터 필터 지원과 하이브리드 검색 모드를 활성화한 후 필터를 사용해 유사도 검색 시도 시 예외가 발생하는지, 오류 메시지가 하이브리드 모드에서 필터가 지원되지 않음을 알리는지 테스트"},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_similarity_search_by_vector_metadata_filter_unsupported","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_similarity_search_by_vector_metadata_filter_unsupported","_rev":"_jzRpLj2---","type":"function","name":"test_similarity_search_by_vector_metadata_filter_unsupported","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":471,"source":"def test_similarity_search_by_vector_metadata_filter_unsupported(\n    neo4j_vector_factory: Any,\n) -> None:\n    \"\"\"\n    Test that similarity_search_by_vector raises ValueError when metadata\n    filtering is unsupported.\n    \"\"\"\n    vector_store = neo4j_vector_factory()\n    vector_store.support_metadata_filter = False\n    vector_store.search_type = SearchType.VECTOR\n    vector_store.embedding_dimension = 64\n\n    with pytest.raises(ValueError) as exc_info:\n        vector_store.similarity_search_by_vector(\n            embedding=[0] * 64,\n            filter={\"field\": \"value\"},\n        )\n    assert (\n        \"Metadata filtering is only supported in Neo4j version 5.18 or greater\"\n        in str(exc_info.value)\n    )","docstring":"Test that similarity_search_by_vector raises ValueError when metadata\nfiltering is unsupported.","args":[{"arg":"neo4j_vector_factory","type":"Any"}],"return_type":"None","control_flow":[],"reason":"it tests that the method similarity_search_by_vector raises a ValueError when trying to perform metadata filtering with a vector store that does not support metadata filtering, by setting support_metadata_filter to False and then calling the method with a filter, expecting an exception with a specific message.","reason_kor":"지원되지 않는 메타데이터 필터링 기능을 가진 벡터 스토어에서 필터와 함께 similarity_search_by_vector 메서드를 호출할 때 ValueError가 발생하는지, 메시지가 적절한지 검증"},{"_key":"tests_unit_tests_vectorstores_test_neo4j_py_test_versioning_check","_id":"nodes/tests_unit_tests_vectorstores_test_neo4j_py_test_versioning_check","_rev":"_jzRpLkG---","type":"function","name":"test_versioning_check","defined_in":"tests_unit_tests_vectorstores_test_neo4j_py","lineno":153,"source":"def test_versioning_check(\n    mock_get_version: MagicMock,\n    mock_vector_store: Neo4jVector,\n    description: str,\n    version: tuple[int, int, int],\n    is_5_23_or_above: bool,\n) -> None:\n    mock_get_version.return_value = version, False, False\n    mock_vector_store.verify_version()\n    assert (\n        mock_vector_store.neo4j_version_is_5_23_or_above is is_5_23_or_above\n    ), f\"Failed test case: {description}\"","docstring":null,"args":[{"arg":"mock_get_version","type":"MagicMock"},{"arg":"mock_vector_store","type":"Neo4jVector"},{"arg":"description","type":"str"},{"arg":"version","type":"tuple[int, int, int]"},{"arg":"is_5_23_or_above","type":"bool"}],"return_type":"None","control_flow":[],"reason":"Test to check that the Neo4jVector.verify_version() correctly sets the neo4j_version_is_5_23_or_above flag based on the mocked version returned by the version retrieval function.","reason_kor":"Neo4jVector.verify_version() 메서드가 버전 조회 함수에서 반환된 모의 버전을 기준으로 neo4j_version_is_5_23_or_above 플래그를 올바르게 설정하는지 검증하는 테스트."}]